<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Text Parser & Colorizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif;
      padding: 1rem;
      max-width: 1200px;
      margin: auto;
    }

    /* Tab Styles */
    .tab-container {
      margin-top: 2rem;
    }

    .tab-buttons {
      display: flex;
      border-bottom: 2px solid #e0e0e0;
      margin-bottom: 1rem;
    }

    .tab-button {
      padding: 0.75rem 1.5rem;
      border: none;
      background: none;
      cursor: pointer;
      font-weight: 500;
      color: #666;
      border-bottom: 3px solid transparent;
      transition: all 0.2s ease;
    }

    .tab-button.active {
      color: #007aff;
      border-bottom-color: #007aff;
      background: #f8f9fa;
    }

    .tab-button:hover {
      color: #007aff;
      background: #f8f9fa;
    }

    .tab-content {
      display: none;
      padding: 1rem 0;
    }

    .tab-content.active {
      display: block;
    }

    /* Existing Styles */
    textarea {
      width: 100%;
      height: 120px;
      font-family: monospace;
    }

    .preview {
      border: 1px solid #ccc;
      padding: 0.5rem;
      min-height: 100px;
      white-space: pre-wrap;
    }

    .word {
      padding: 2px 3px;
      border-radius: 3px;
      display: inline-block;
      margin: 1px;
    }

    .rule-row {
      display: flex;
      gap: 0;
      margin-bottom: 0;
      flex-wrap: nowrap;
      align-items: center;
      min-width: 0;
    }

    .small {
      font-size: 0.75rem;
      color: #555;
    }

    .flex {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      cursor: pointer;
      border-radius: 5px;
      background: #007aff;
      color: white;
      font-weight: 600;
    }

    .btn-secondary {
      background: #555;
    }

    input,
    select {
      padding: 6px;
    }

    .code {
      background: #f5f5f5;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: monospace;
    }

    .inline-form {
      display: none;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      margin: 0.5rem 0;
      animation: slideDown 0.2s ease-out;
    }

    .inline-form.show {
      display: block;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .inline-form-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .inline-form-row label {
      font-weight: 500;
      min-width: 80px;
    }

    .inline-form-row input {
      flex: 1;
      min-width: 80px;
    }

    .inline-form-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      margin-top: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.5rem;
      font-size: 0.875rem;
    }

    .btn-xs {
      padding: 0.125rem 0.25rem;
      font-size: 0.75rem;
    }

    .btn-success {
      background: #28a745;
    }

    .btn-danger {
      background: #dc3545;
    }

    .custom-toggle-container {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin: 0.25rem 0;
    }

    .toggle-button {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.5rem 0.75rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.875rem;
      transition: background-color 0.2s;
    }

    .toggle-button.active {
      background: #28a745;
      color: white;
    }

    .toggle-button.inactive {
      background: #555;
      color: white;
    }

    .toggle-delete {
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      margin-left: 0.25rem;
    }

    .list-container {
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 1rem;
      background: #f8f9fa;
    }

    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #dee2e6;
    }

    .list-title {
      font-weight: 600;
      font-size: 1.1rem;
      margin: 0;
    }

    .list-type {
      font-size: 0.75rem;
      color: #6c757d;
      background: #e9ecef;
      padding: 0.25rem 0.5rem;
      border-radius: 3px;
    }

    .list-content {
      margin-top: 0.5rem;
    }

    .key-value-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
      align-items: center;
    }

    .key-value-row input {
      flex: 1;
      min-width: 100px;
    }

    .array-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
      align-items: center;
    }

    .array-row input {
      flex: 1;
      min-width: 100px;
    }

    .list-actions {
      display: flex;
      gap: 0.25rem;
      margin-top: 0.5rem;
    }

    .btn-xs {
      padding: 0.125rem 0.25rem;
      font-size: 0.75rem;
    }

    .color-btn {
      position: relative;
      border: 2px solid #dee2e6;
      transition: all 0.2s ease;
    }

    .color-btn:hover {
      border-color: #007aff;
    }

    #defaultColor1Panel,
    #defaultColor2Panel {
      position: absolute;
      min-width: 250px;
      background: white;
      border: 1px solid #dee2e6;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    #defaultColor1Display,
    #defaultColor2Display {
      display: inline-block;
      max-width: 40px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: 600;
    }

    /* JSON Display */
    .json-display {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      max-height: 400px;
      overflow: auto;
      font-family: monospace;
      font-size: 0.875rem;
      line-height: 1.4;
      white-space: pre;
    }

    /* JSON Syntax Highlighting */
    .json-key {
      color: #0066cc;
      font-weight: 600;
    }

    .json-string {
      color: #28a745;
    }

    .json-number {
      color: #fd7e14;
    }

    .json-boolean {
      color: #6f42c1;
    }

    .json-null {
      color: #6c757d;
    }

    .json-punctuation {
      color: #495057;
    }

    /* Refresh Button */
    .refresh-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #007aff;
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      font-size: 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.2s ease;
      z-index: 1000;
    }

    .refresh-btn:hover {
      background: #0056b3;
      transform: scale(1.1);
    }

    .refresh-btn:active {
      transform: scale(0.95);
    }

    /* Section headers */
    .section-header {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #e0e0e0;
    }

    .section-header h3 {
      margin: 0;
      color: #333;
    }

    /* Dropdown styling */
    .dropdown-option:hover {
      background-color: #f8f9fa;
    }

    .dropdown-option:last-child {
      border-bottom: none !important;
    }

    /* Style abbreviation styling */
    .style1-display,
    .style2-display {
      font-size: 0.7em;
      opacity: 0.8;
      margin-left: 2px;
    }

    /* Group regex field width */
    .rule-row .match {
      width: 80px;
      min-width: 80px;
      flex-shrink: 0;
    }

    /* Prevent wrapping in rule rows */
    .rule-row>* {
      flex-shrink: 0;
    }

    .rule-row .category {
      flex-shrink: 0;
    }

    .rule-row .label {
      flex-shrink: 0;
    }

    .rule-row .color-btn {
      flex-shrink: 0;
    }

    /* Move buttons for group reordering */
    .move-buttons {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-right: 8px;
    }

    .move-btn {
      width: 24px;
      height: 20px;
      padding: 0;
      border: 1px solid #dee2e6;
      background: #f8f9fa;
      color: #6c757d;
      cursor: pointer;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 2px;
      transition: all 0.2s ease;
    }

    .move-btn:hover {
      background: #e9ecef;
      color: #495057;
    }

    .move-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .move-btn:disabled:hover {
      background: #f8f9fa;
      color: #6c757d;
    }

    .group-priority-info {
      font-size: 0.75rem;
      color: #6c757d;
      margin-top: 0.5rem;
      padding: 0.5rem;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
    }
  </style>
</head>

<body>
  <!-- Refresh Button -->
  <button class="refresh-btn" id="refreshBtn" title="Refresh from bob.json and switch to JSON tab">🔄</button>

  <div class="tab-container">
    <div class="tab-buttons">
      <button class="tab-button active" data-tab="input-preview">Input Text + Preview + Export</button>
      <button class="tab-button" data-tab="search-dictionary">Default Search Pattern + Groups</button>
      <button class="tab-button" data-tab="lists-arrays">Lists and Arrays Manager</button>
      <button class="tab-button" data-tab="json-view">bob.json</button>
    </div>

    <!-- Tab 1: Input Text + Preview + Export -->
    <div id="input-preview" class="tab-content active">
      <div style="margin-bottom:0.5rem;">
        <button class="btn" id="loadSampleMd">Load Sample.md</button>
        <button class="btn btn-secondary" id="convertBob">Convert Bob</button>
      </div>

      <div class="section-header">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <h3>Input Text</h3>
          <button class="btn btn-secondary" id="clearBtn">Clear</button>
        </div>
      </div>
      <textarea id="sourceText" placeholder="Paste OCR text here..."></textarea>

      <div class="section-header">
        <h3>Preview</h3>
      </div>
      <div class="preview" id="preview"></div>

      <div class="section-header">
        <h3>Export</h3>
        <p class="small">💡 <strong>URL Sharing:</strong> Use the "Copy Shareable URL" button to create a link that
          automatically loads your text when opened. You can also manually add parameters like
          <code>?text=your_text_here&export=markdown</code> to the URL. Available export options: markdown, pdf, html,
          plain. Use <code>?clear=true</code> to clear the textarea. For very long text, use
          <code>?clipboard=message</code> or <code>?file=message</code> to show instructions.
        </p>
      </div>
      <div class="flex">
        <div>
          <label>Markdown filename: <input id="mdName" value="export.md"></label>
          <div style="margin-top:0.25rem;">
            <button class="btn" id="downloadMd">Download Markdown</button>
          </div>
        </div>
        <div>
          <label>PDF filename: <input id="pdfName" value="export.pdf"></label>
          <div style="margin-top:0.25rem;">
            <button class="btn" id="downloadPdf">Download PDF</button>
          </div>
        </div>
        <div>
          <div style="margin-bottom:4px;">Clipboard:</div>
          <button class="btn" id="copyHtml">Copy Styled HTML</button>
          <button class="btn" id="copyPlain">Copy Plain Text</button>
          <button class="btn btn-secondary" id="copyShareableUrl">Copy Shareable URL</button>
        </div>
        <div>
          <div style="margin-bottom:4px;">Quick Export URLs:</div>
          <button class="btn btn-secondary btn-small" id="copyMarkdownUrl">Markdown URL</button>
          <button class="btn btn-secondary btn-small" id="copyPdfUrl">PDF URL</button>
          <button class="btn btn-secondary btn-small" id="testUrlLength">Test URL Length</button>
        </div>
      </div>
    </div>

    <!-- Tab 2: Default Search Pattern + Dictionary / Rules -->
    <div id="search-dictionary" class="tab-content">
      <div class="section-header">
        <div style="display: flex; align-items: center; gap: 10px;">
          <h3>Default Search Pattern</h3>
          <button id="debugToggle" class="btn btn-secondary" style="font-size: 12px; padding: 4px 8px;">Debug:
            OFF</button>
        </div>
      </div>
      <div style="margin-bottom:0.5rem;">
        <label>
          <input type="checkbox" id="defaultPatternEnabled" checked>
          Enable default search pattern
        </label>
      </div>
      <div id="defaultPatternContainer">
        <div class="rule-row" data-step="0">
          <button id="defaultColor1Btn" class="btn btn-secondary color-btn"
            style="width: 80px; text-align: left; position: relative;">
            <span id="defaultColor1Display">magenta</span>
            <span id="defaultStyle1Display">bg</span>
          </button>
          <button id="defaultColor2Btn" class="btn btn-secondary color-btn"
            style="width: 80px; text-align: left; position: relative;">
            <span id="defaultColor2Display">-</span>
            <span id="defaultStyle2Display"></span>
          </button>
          <div id="defaultColor1Panel" class="inline-form">
            <div class="inline-form-row">
              <label for="defaultColor1Text">Color 1:</label>
              <input id="defaultColor1Text" type="text" placeholder="color (e.g. #ff0000)" value="magenta"
                style="flex: 1;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultColor1Picker">Picker:</label>
              <input id="defaultColor1Picker" type="color" value="#ff00ff" style="width: 50px; height: 30px;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultStyle1Select">Style:</label>
              <select id="defaultStyle1Select" style="flex: 1;">
                <option value="">None</option>
                <option value="background">Background</option>
                <option value="color">Text Color</option>
                <option value="underline">Underline</option>
                <option value="border">Border</option>
                <option value="symbol">Symbol</option>
              </select>
            </div>
            <div class="inline-form-actions">
              <button class="btn btn-success btn-small" id="applyDefaultColor1">Apply</button>
              <button class="btn btn-danger btn-small" id="cancelDefaultColor1">Cancel</button>
            </div>
          </div>
          <div id="defaultColor2Panel" class="inline-form">
            <div class="inline-form-row">
              <label for="defaultColor2Text">Color 2:</label>
              <input id="defaultColor2Text" type="text" placeholder="color (e.g. #ff0000)" value="" style="flex: 1;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultColor2Picker">Picker:</label>
              <input id="defaultColor2Picker" type="color" value="#0000ff" style="width: 50px; height: 30px;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultStyle2Select">Style:</label>
              <select id="defaultStyle2Select" style="flex: 1;">
                <option value="">None</option>
                <option value="background">Background</option>
                <option value="color">Text Color</option>
                <option value="underline">Underline</option>
                <option value="border">Border</option>
                <option value="symbol">Symbol</option>
              </select>
            </div>
            <div class="inline-form-actions">
              <button class="btn btn-success btn-small" id="applyDefaultColor2">Apply</button>
              <button class="btn btn-danger btn-small" id="cancelDefaultColor2">Cancel</button>
            </div>
          </div>
          <button class="btn btn-secondary wrapper-toggle" data-wrapper="start-anchor" data-active="false">^</button>
          <button class="btn btn-secondary" id="addPrependRegexToggle">+</button>
          <div id="prependTogglesContainer" style="display: flex; gap: 0; align-items: center;"></div>
          <input id="basePatternInput" placeholder="Base pattern (e.g. [A-Z])" value="[A-Z]{1,4}"
            style="width: 70px;" />
          <div id="appendTogglesContainer" style="display: flex; gap: 0; align-items: center;"></div>
          <button class="btn btn-secondary" id="addRegexToggle">+</button>
          <button class="btn btn-secondary wrapper-toggle" data-wrapper="word-boundary" data-active="false">\b</button>
          <button class="btn btn-secondary wrapper-toggle" data-wrapper="end-anchor" data-active="false">$</button>
        </div>

        <!-- Inline form for adding regex toggles -->
        <div id="inlineRegexForm" class="inline-form">
          <div class="inline-form-row">
            <label for="newRegexValue">Regex:</label>
            <input type="text" id="newRegexValue" placeholder="Enter regex string (e.g. [0-9]+)" />
            <button class="btn btn-secondary btn-small" id="togglePrependMode"
              title="Toggle between append (+) and prepend (^) mode">+</button>
          </div>
          <div class="inline-form-row">
            <label for="newRegexLabel">Label:</label>
            <input type="text" id="newRegexLabel" placeholder="Enter button label (e.g. Numbers)" />
          </div>
          <div class="inline-form-actions">
            <button class="btn btn-success btn-small" id="saveRegexToggle">Add Toggle</button>
            <button class="btn btn-danger btn-small" id="cancelRegexToggle">Cancel</button>
          </div>
        </div>
      </div>

      <div style="margin-top: 0.5rem;">
        <strong>Constructed Pattern:</strong> <code id="constructedPattern">[A-Z]{1,4}</code>
      </div>
      <div style="margin-top: 0.5rem;">
        <strong>Current Matches:</strong>
        <pre id="currentMatches" class="code" style="max-height:100px; overflow:auto; font-size: 0.875rem;"></pre>
      </div>
      <p class="small">This pattern will be applied to any text that doesn't match other rules. Build your pattern
        progressively by adding wrappers to each step.</p>

      <div class="section-header">
        <h3>Groups</h3>
      </div>
      <div style="margin-top:0.5rem;">
        <div id="rulesContainer"></div>
        <div style="margin-top:0.5rem;">
          <div class="dropdown-container" style="position: relative; display: inline-block;">
            <button class="btn" id="addRule">+ Add Group</button>
            <div id="categoryDropdown" class="dropdown-menu"
              style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #dee2e6; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 1000; max-width: 100px;">
              <!-- Categories will be populated dynamically -->
            </div>
          </div>
        </div>
        <div class="group-priority-info">
          <strong>Priority Order:</strong> Groups are applied in the order shown above. Use the ▲▼ buttons to reorder
          groups and change priority. The first matching group's style will be applied.
          <div id="currentPriorityOrder" style="margin-top: 0.5rem; font-size: 0.7rem; color: #495057;"></div>
          <div style="margin-top: 0.5rem;">
            <button class="btn btn-secondary btn-small" id="showPriorityOrder" style="font-size: 0.75rem;">Show Current
              Order</button>
            <button class="btn btn-secondary btn-small" id="resetPriorityOrder" style="font-size: 0.75rem;">Reset to
              Alphabetical</button>
          </div>
        </div>
      </div>
      <p class="small">Groups match words using JavaScript regular expressions (case-insensitive by default). First
        matching group applies.</p>

      <div class="section-header">
        <h3>Objects</h3>
      </div>

      <!-- Bulk Load Objects Section -->
      <div
        style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px;">
        <h4 style="margin: 0 0 0.5rem 0; font-size: 1rem;">Bulk Load Objects</h4>
        <p class="small" style="margin: 0 0 0.5rem 0;">Import multiple objects using CSV format:
          label,color1,color2,style1,style2,match,group,enabled</p>
        <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
          <textarea id="bulkObjectsInput"
            placeholder="label,color1,color2,style1,style2,match,group,enabled&#10;red,#ff0000,#ffffff,background,color,red,color,true&#10;blue,#0000ff,#ffffff,background,color,blue,color,true"
            style="width: 100%; height: 100px; font-family: monospace; font-size: 0.875rem;"></textarea>
        </div>
        <div style="margin-top: 0.5rem;">
          <button class="btn btn-success" id="bulkLoadObjects">Load Objects</button>
          <button class="btn btn-secondary" id="clearBulkObjects">Clear</button>
          <button class="btn btn-secondary" id="downloadObjectsTemplate">Download Template</button>
        </div>
      </div>

      <div style="margin-top:0.5rem;">
        <div id="objectsContainer"></div>
        <div style="margin-top:0.5rem;">
          <div class="dropdown-container" style="position: relative; display: inline-block;">
            <button class="btn" id="addObject">+ Add Object</button>
            <div id="objectCategoryDropdown" class="dropdown-menu"
              style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #dee2e6; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 1000; max-width: 100px;">
              <!-- Categories will be populated dynamically -->
            </div>
          </div>
        </div>
      </div>
      <p class="small">Objects are specific items within Groups. If a Group has no regex, its Objects are searched when
        the Group is enabled.</p>
    </div>

    <!-- Tab 3: Lists and Arrays Manager -->
    <div id="lists-arrays" class="tab-content">
      <div class="section-header">
        <h3>Lists and Arrays Manager</h3>
      </div>
      <div style="margin-bottom:0.5rem;">
        <button class="btn" id="addKeyValueList">+ Add Key-Value List</button>
        <button class="btn btn-secondary" id="addArray">+ Add Array</button>
      </div>
      <div id="listsContainer"></div>
      <p class="small">Manage lists of key:value pairs and arrays that sync with bob.json. Use these for storing
        configuration data, mappings, or any structured data.</p>
    </div>

    <!-- Tab 4: bob.json -->
    <div id="json-view" class="tab-content">
      <div class="section-header">
        <h3>bob.json</h3>
        <p class="small">This shows the current state of your configuration data. The data is automatically saved to
          localStorage and can be exported to bob.json.</p>
      </div>
      <div style="margin-bottom:1rem;">
        <button class="btn btn-secondary" id="loadBobJson">Load from Storage</button>
        <button class="btn btn-secondary" id="saveBobJson">Export to File</button>
      </div>
      <div class="json-display" id="rawJson"></div>
    </div>
  </div>

  <template id="ruleTemplate">
    <div class="rule-row">
      <div class="move-buttons">
        <button class="move-btn move-up" title="Move group up">▲</button>
        <button class="move-btn move-down" title="Move group down">▼</button>
      </div>
      <button class="btn btn-secondary group-toggle" style="width: 40px; font-weight: bold;"
        title="Toggle group on/off">✓</button>
      <select class="category" style="width: 150px;">
        <option value="">💜</option>
      </select>
      <button class="style1-btn btn btn-secondary color-btn" style="width: 80px; text-align: left; position: relative;">
        <span class="style1-display">background</span>
      </button>
      <button class="style2-btn btn btn-secondary color-btn" style="width: 80px; text-align: left; position: relative;">
        <span class="style2-display">-</span>
      </button>
      <button class="btn btn-secondary removeRule">✕</button>
    </div>
  </template>

  <template id="objectTemplate">
    <div class="rule-row">
      <button class="btn btn-secondary object-toggle" style="width: 40px; font-weight: bold;"
        title="Toggle object on/off">✓</button>
      <input aria-label="label" placeholder="label (optional)" class="label" style="width: 120px;" />
      <button class="color1-btn btn btn-secondary color-btn" style="width: 80px; text-align: left; position: relative;">
        <span class="color1-display">magenta</span>
      </button>
      <button class="color2-btn btn btn-secondary color-btn" style="width: 80px; text-align: left; position: relative;">
        <span class="color2-display">-</span>
      </button>
      <input aria-label="match" placeholder="regex (e.g. ^[A-M])" class="match" />
      <button class="btn btn-secondary removeObject">✕</button>
    </div>
  </template>

  <!-- jsPDF from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    integrity="sha512-your-integrity-placeholder" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
    // Tab functionality
    function initTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const targetTab = button.getAttribute('data-tab');

          // Remove active class from all buttons and contents
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));

          // Add active class to clicked button and corresponding content
          button.classList.add('active');
          document.getElementById(targetTab).classList.add('active');
        });
      });
    }

    // URL Parameter Handling
    function handleURLParameters() {
      try {
        const params = new URLSearchParams(window.location.search);
        const incomingText = params.get("text");
        const textId = params.get("textId");
        const clipboardHint = params.get("clipboard");
        const fileHint = params.get("file");
        const autoParse = params.get("parse") === "true";
        const autoExport = params.get("export");
        const clearText = params.get("clear") === "true";

        if (incomingText) {
          // Decode the incoming text
          const decodedText = decodeURIComponent(incomingText);
          console.log("Received text from URL parameter:", decodedText);

          loadTextFromParameter(decodedText);
        } else if (textId) {
          // Load text from localStorage using textId
          const storedText = localStorage.getItem(textId);
          if (storedText) {
            console.log("Received text from localStorage ID:", textId);
            loadTextFromParameter(storedText);

            // Clean up the stored text after loading
            localStorage.removeItem(textId);
          } else {
            console.error("Text not found in localStorage for ID:", textId);
            alert("Shared text not found or has expired.");
          }
        } else if (clipboardHint) {
          // Show clipboard instruction
          showClipboardInstruction(clipboardHint);
        } else if (fileHint) {
          // Show file upload instruction
          showFileUploadInstruction(fileHint);
        }

        function loadTextFromParameter(text) {

          // Set the text in the source textarea
          const sourceTextArea = document.getElementById('sourceText');
          if (sourceTextArea) {
            sourceTextArea.value = decodedText;

            // Apply rules to show the preview
            if (typeof applyRules === 'function') {
              applyRules();
            }

            // Switch to the input-preview tab
            const inputPreviewTab = document.querySelector('[data-tab="input-preview"]');
            if (inputPreviewTab) {
              // Remove active class from all buttons and contents
              document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
              document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

              // Add active class to input-preview tab
              inputPreviewTab.classList.add('active');
              document.getElementById('input-preview').classList.add('active');
            }

            // Handle auto-export if specified
            if (autoExport && typeof applyRules === 'function') {
              // Wait a bit for the preview to update, then export
              setTimeout(() => {
                switch (autoExport.toLowerCase()) {
                  case 'markdown':
                    downloadMarkdown();
                    break;
                  case 'pdf':
                    downloadPDF();
                    break;
                  case 'html':
                    copyStyledHTML();
                    break;
                  case 'plain':
                    copyPlainText();
                    break;
                }
              }, 1000);
            }

            // Show a brief notification
            showURLParameterNotification(text);
          } else {
            console.error('Source textarea not found');
          }
        }

        // Handle clear parameter
        if (clearText) {
          const sourceTextArea = document.getElementById('sourceText');
          if (sourceTextArea) {
            sourceTextArea.value = '';
            if (typeof applyRules === 'function') {
              applyRules();
            }
            showURLParameterNotification('Text cleared');
          }
        }
      } catch (error) {
        console.error('Error handling URL parameters:', error);
      }
    }

    function showURLParameterNotification(text) {
      // Create notification element
      const notification = document.createElement('div');
      notification.id = 'urlParameterNotification';
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #28a745;
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        font-size: 14px;
        z-index: 1001;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        max-width: 80%;
        word-wrap: break-word;
      `;

      // Truncate text if too long
      const displayText = text.length > 100 ? text.substring(0, 100) + '...' : text;
      notification.textContent = `Loaded text from URL: "${displayText}"`;

      document.body.appendChild(notification);

      // Remove notification after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }

    function generateShareableURL(text, exportType = null) {
      if (!text || text.trim() === '') {
        return window.location.href.split('?')[0]; // Return base URL without parameters
      }

      const encodedText = encodeURIComponent(text);
      const urlLength = encodedText.length;

      // Check if URL would be too long (conservative limit of 2000 chars)
      if (urlLength > 2000) {
        const truncatedText = text.substring(0, Math.floor(text.length * 0.8)) + '...';
        const truncatedEncoded = encodeURIComponent(truncatedText);

        // Show warning to user with options
        const choice = confirm(
          `Warning: Your text is very long (${text.length} characters). ` +
          `The URL would be ${urlLength} characters long, which may not work in all browsers.\n\n` +
          `Click OK to create a URL with truncated text (${truncatedText.length} characters).\n` +
          `Click Cancel to use localStorage sharing instead (works for any length).`
        );

        if (choice) {
          // User chose truncated URL
          const baseURL = window.location.href.split('?')[0];
          let url = `${baseURL}?text=${truncatedEncoded}`;

          if (exportType && ['markdown', 'pdf', 'html', 'plain'].includes(exportType.toLowerCase())) {
            url += `&export=${exportType.toLowerCase()}`;
          }

          return url;
        } else {
          // User chose localStorage approach
          return generateLocalStorageURL(text, exportType);
        }
      }

      const baseURL = window.location.href.split('?')[0];
      let url = `${baseURL}?text=${encodedText}`;

      if (exportType && ['markdown', 'pdf', 'html', 'plain'].includes(exportType.toLowerCase())) {
        url += `&export=${exportType.toLowerCase()}`;
      }

      return url;
    }

    function generateLocalStorageURL(text, exportType = null) {
      // Generate a unique ID for this text
      const textId = 'shared_text_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

      // Store the text in localStorage
      localStorage.setItem(textId, text);

      // Create URL with the text ID
      const baseURL = window.location.href.split('?')[0];
      let url = `${baseURL}?textId=${textId}`;

      if (exportType && ['markdown', 'pdf', 'html', 'plain'].includes(exportType.toLowerCase())) {
        url += `&export=${exportType.toLowerCase()}`;
      }

      return url;
    }

    function showClipboardInstruction(message = "Text is on your clipboard") {
      // Switch to input-preview tab
      const inputPreviewTab = document.querySelector('[data-tab="input-preview"]');
      if (inputPreviewTab) {
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

        inputPreviewTab.classList.add('active');
        document.getElementById('input-preview').classList.add('active');
      }

      // Create instruction overlay
      const overlay = document.createElement('div');
      overlay.id = 'clipboardInstruction';
      overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;

      const instructionBox = document.createElement('div');
      instructionBox.style.cssText = `
          background: white;
          padding: 2rem;
          border-radius: 8px;
          max-width: 500px;
          text-align: center;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        `;

      instructionBox.innerHTML = `
          <h3 style="margin: 0 0 1rem 0; color: #007aff;">📋 Clipboard Instructions</h3>
          <p style="margin: 0 0 1.5rem 0; font-size: 1.1rem;">${message}</p>
          <p style="margin: 0 0 1.5rem 0; color: #666;">Please paste the text into the textarea below, then click "Got it!"</p>
          <button id="dismissClipboardInstruction" style="
            background: #007aff;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
          ">Got it!</button>
        `;

      overlay.appendChild(instructionBox);
      document.body.appendChild(overlay);

      // Focus on textarea
      const textarea = document.getElementById('sourceText');
      if (textarea) {
        textarea.focus();
      }

      // Dismiss instruction
      document.getElementById('dismissClipboardInstruction').addEventListener('click', () => {
        document.body.removeChild(overlay);
      });
    }

    function showFileUploadInstruction(message = "Please upload your text file") {
      // Switch to input-preview tab
      const inputPreviewTab = document.querySelector('[data-tab="input-preview"]');
      if (inputPreviewTab) {
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

        inputPreviewTab.classList.add('active');
        document.getElementById('input-preview').classList.add('active');
      }

      // Create instruction overlay
      const overlay = document.createElement('div');
      overlay.id = 'fileUploadInstruction';
      overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;

      const instructionBox = document.createElement('div');
      instructionBox.style.cssText = `
          background: white;
          padding: 2rem;
          border-radius: 8px;
          max-width: 500px;
          text-align: center;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        `;

      instructionBox.innerHTML = `
          <h3 style="margin: 0 0 1rem 0; color: #007aff;">📁 File Upload Instructions</h3>
          <p style="margin: 0 0 1.5rem 0; font-size: 1.1rem;">${message}</p>
          <p style="margin: 0 0 1.5rem 0; color: #666;">Please upload your text file below, then click "Got it!"</p>
          <input type="file" id="fileUploadInput" accept=".txt,.md,.csv" style="
            margin: 0 0 1rem 0;
            padding: 0.5rem;
            border: 2px dashed #007aff;
            border-radius: 5px;
            width: 100%;
          ">
          <button id="dismissFileInstruction" style="
            background: #007aff;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
          ">Got it!</button>
        `;

      overlay.appendChild(instructionBox);
      document.body.appendChild(overlay);

      // Handle file upload
      const fileInput = document.getElementById('fileUploadInput');
      fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            const text = e.target.result;
            document.getElementById('sourceText').value = text;
            applyRules();
          };
          reader.readAsText(file);
        }
      });

      // Dismiss instruction
      document.getElementById('dismissFileInstruction').addEventListener('click', () => {
        document.body.removeChild(overlay);
      });
    }

    // Test function to demonstrate URL length limits
    function testURLLength() {
      const testTexts = [
        "Short text", // ~20 chars encoded
        "This is a medium length text that should work fine in most browsers", // ~80 chars encoded
        "A".repeat(500), // ~1500 chars encoded
        "A".repeat(1000), // ~3000 chars encoded
        "A".repeat(2000) // ~6000 chars encoded
      ];

      console.log("URL Length Test Results:");
      testTexts.forEach((text, index) => {
        const encoded = encodeURIComponent(text);
        const url = `bob.html?text=${encoded}`;
        console.log(`Test ${index + 1}: Original=${text.length} chars, Encoded=${encoded.length} chars, URL=${url.length} chars`);

        if (encoded.length > 2000) {
          console.log(`  ⚠️  Would trigger warning dialog`);
        } else if (encoded.length > 1000) {
          console.log(`  ⚠️  Getting close to limit`);
        } else {
          console.log(`  ✅  Safe to use`);
        }
      });
    }

    // Helper functions for external URL building
    function buildExternalURL(text, exportType = null) {
      const encodedText = encodeURIComponent(text);
      const urlLength = encodedText.length;

      // Conservative limit for external URLs
      if (urlLength > 4000) {
        throw new Error(`Text too long for external URL: ${text.length} chars (${urlLength} encoded)`);
      }

      let url = `https://yourdomain.com/bob.html?text=${encodedText}`;

      if (exportType) {
        url += `&export=${exportType}`;
      }

      return url;
    }

    function buildClipboardURL(message = "Text is on your clipboard", exportType = null) {
      let url = `https://yourdomain.com/bob.html?clipboard=${encodeURIComponent(message)}`;

      if (exportType) {
        url += `&export=${exportType}`;
      }

      return url;
    }

    function buildFileUploadURL(message = "Please upload your text file", exportType = null) {
      let url = `https://yourdomain.com/bob.html?file=${encodeURIComponent(message)}`;

      if (exportType) {
        url += `&export=${exportType}`;
      }

      return url;
    }

    function copyShareableURL() {
      const text = document.getElementById('sourceText').value || '';

      if (!text || text.trim() === '') {
        alert('Please enter some text first before copying a shareable URL.');
        return;
      }

      const shareableURL = generateShareableURL(text);
      if (!shareableURL) {
        return; // User cancelled or URL generation failed
      }

      navigator.clipboard.writeText(shareableURL).then(() => {
        // Show success notification
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: #007aff;
          color: white;
          padding: 12px 20px;
          border-radius: 6px;
          font-size: 14px;
          z-index: 1001;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        `;
        notification.textContent = 'Shareable URL copied to clipboard!';
        document.body.appendChild(notification);

        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      }).catch(err => {
        console.error('Failed to copy URL:', err);
        alert('Failed to copy URL to clipboard');
      });
    }

    // minimal dictionary structure
    let dictionary = { rules: [] };

    // Objects data structure
    let objectsData = { objects: [] };

    // Default pattern JSON structure
    let defaultPattern = {
      label: "Default",
      color1: "magenta",
      color2: "",
      style1: "background",
      style2: "",
      structure: {
        startAnchor: false,
        startWordBoundary: false,
        customPrependToggles: [],
        basePattern: "[A-Z]{1,4}",
        customAppendToggles: [],
        endWordBoundary: false,
        endAnchor: false
      }
    };

    // Lists and Arrays Management
    let listsData = {
      keyValueLists: [],
      arrays: []
    };

    // Function to load pattern hierarchy from localStorage or bob.json
    async function loadPatternHierarchy() {
      // First try to load from localStorage
      const localStorageData = localStorage.getItem('bobPatternHierarchy');
      if (localStorageData) {
        try {
          const data = JSON.parse(localStorageData);

          // Load default pattern
          if (data.defaultPattern) {
            defaultPattern = data.defaultPattern;
          }

          // Load dictionary
          if (data.dictionary) {
            dictionary = data.dictionary;
          }

          // Load lists and arrays data
          if (data.listsData) {
            listsData = data.listsData;
          }

          // Load objects data
          if (data.objectsData) {
            objectsData = data.objectsData;
          }

          // Update UI
          updatePatternUI();
          refreshRuleUI();
          refreshObjectsUI();
          refreshListsUI();
          applyRules();

          console.log('Pattern hierarchy loaded from localStorage');
          return;
        } catch (error) {
          console.error('Error parsing localStorage data:', error);
        }
      }

      // Fallback to loading from bob.json file
      try {
        const response = await fetch('bob.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        // Load default pattern
        if (data.defaultPattern) {
          defaultPattern = data.defaultPattern;
        }

        // Load dictionary
        if (data.dictionary) {
          dictionary = data.dictionary;
        }

        // Load lists and arrays data
        if (data.listsData) {
          listsData = data.listsData;
        }

        // Update UI
        updatePatternUI();
        refreshRuleUI();
        refreshListsUI();
        applyRules();

        console.log('Pattern hierarchy loaded from bob.json');
      } catch (error) {
        console.error('Error loading bob.json:', error);
        // If neither localStorage nor file exists, start with empty data
        console.log('No existing data found, starting with empty configuration');
      }
    }

    // Function to refresh from bob.json and switch to JSON tab
    async function refreshFromBobJson() {
      try {
        const response = await fetch('bob.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        // Load default pattern
        if (data.defaultPattern) {
          defaultPattern = data.defaultPattern;
        }

        // Load dictionary
        if (data.dictionary) {
          dictionary = data.dictionary;
        }

        // Load lists and arrays data
        if (data.listsData) {
          listsData = data.listsData;
        }

        // Load objects data
        if (data.objectsData) {
          objectsData = data.objectsData;
        }

        // Update UI
        updatePatternUI();
        refreshRuleUI();
        refreshObjectsUI();
        refreshListsUI();
        applyRules();
        updateRawJson();

        // Note: Removed auto-switching to JSON tab as requested

        console.log('Refreshed from bob.json');

        // Show success indicator
        showRefreshIndicator();
      } catch (error) {
        console.error('Error refreshing from bob.json:', error);
        alert('Error loading bob.json. Make sure the file exists and is valid JSON.');
      }
    }

    // Function to show refresh indicator
    function showRefreshIndicator() {
      // Create or update refresh indicator
      let indicator = document.getElementById('refreshIndicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'refreshIndicator';
        indicator.style.cssText = `
          position: fixed;
          top: 80px;
          right: 20px;
          background: #28a745;
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-size: 12px;
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.3s ease;
        `;
        document.body.appendChild(indicator);
      }

      indicator.textContent = '✓ Refreshed from bob.json';
      indicator.style.opacity = '1';

      // Hide after 2 seconds
      setTimeout(() => {
        indicator.style.opacity = '0';
      }, 2000);
    }

    // Function to save pattern hierarchy to localStorage (silent)
    function savePatternHierarchy() {
      try {
        const data = {
          defaultPattern: defaultPattern,
          dictionary: dictionary,
          listsData: listsData,
          objectsData: objectsData
        };

        // Save to localStorage for immediate syncing
        localStorage.setItem('bobPatternHierarchy', JSON.stringify(data));
        console.log('Pattern hierarchy saved to localStorage');
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }
    }

    // Function to export pattern hierarchy to file (with user interaction)
    async function exportPatternHierarchy() {
      try {
        const data = {
          defaultPattern: defaultPattern,
          dictionary: dictionary,
          listsData: listsData,
          objectsData: objectsData
        };

        // Try to use File System Access API for silent saving
        if ('showSaveFilePicker' in window) {
          try {
            const handle = await window.showSaveFilePicker({
              suggestedName: 'bob.json',
              types: [{
                description: 'JSON files',
                accept: { 'application/json': ['.json'] }
              }]
            });
            const writable = await handle.createWritable();
            await writable.write(JSON.stringify(data, null, 2));
            await writable.close();
            console.log('Pattern hierarchy exported to bob.json via File System Access API');
            return;
          } catch (e) {
            console.log('File System Access API failed, falling back to download');
          }
        }

        // Fallback to download method
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'bob.json';
        a.click();

        console.log('Pattern hierarchy exported to bob.json via download');
      } catch (error) {
        console.error('Error exporting bob.json:', error);
      }
    }

    // Function to auto-save pattern hierarchy
    function autoSavePatternHierarchy() {
      // Debounce the save operation
      clearTimeout(window.autoSaveTimeout);
      window.autoSaveTimeout = setTimeout(() => {
        savePatternHierarchy();
        // Show a brief visual indicator
        showSaveIndicator();
      }, 1000); // Save after 1 second of inactivity
    }

    // Function to show save indicator
    function showSaveIndicator() {
      // Create or update save indicator
      let indicator = document.getElementById('saveIndicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'saveIndicator';
        indicator.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #28a745;
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-size: 12px;
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.3s ease;
        `;
        document.body.appendChild(indicator);
      }

      indicator.textContent = '✓ Saved';
      indicator.style.opacity = '1';

      // Hide after 2 seconds
      setTimeout(() => {
        indicator.style.opacity = '0';
      }, 2000);
    }

    function refreshRuleUI() {
      const container = document.getElementById('rulesContainer');
      container.innerHTML = '';
      dictionary.rules.forEach((r, idx) => {
        const tpl = document.getElementById('ruleTemplate');
        const node = tpl.content.cloneNode(true);
        const row = node.querySelector('.rule-row');
        row.dataset.idx = idx;

        // Add priority number indicator
        const priorityNumber = document.createElement('div');
        priorityNumber.style.cssText = `
          position: absolute;
          top: -8px;
          left: -8px;
          background: #007aff;
          color: white;
          border-radius: 50%;
          width: 20px;
          height: 20px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 10px;
          font-weight: bold;
          z-index: 10;
        `;
        priorityNumber.textContent = idx + 1;
        row.style.position = 'relative';
        row.appendChild(priorityNumber);

        // Add move button functionality
        const moveUpBtn = row.querySelector('.move-up');
        const moveDownBtn = row.querySelector('.move-down');

        if (moveUpBtn) {
          // Disable up button for first item
          moveUpBtn.disabled = idx === 0;

          moveUpBtn.addEventListener('click', () => {
            if (idx > 0) {
              // Visual feedback
              moveUpBtn.style.transform = 'scale(0.9)';
              setTimeout(() => {
                moveUpBtn.style.transform = 'scale(1)';
              }, 150);

              // Swap with previous item
              const temp = dictionary.rules[idx];
              dictionary.rules[idx] = dictionary.rules[idx - 1];
              dictionary.rules[idx - 1] = temp;

              refreshRuleUI();
              applyRules();
              autoSavePatternHierarchy();
            }
          });
        }

        if (moveDownBtn) {
          // Disable down button for last item
          moveDownBtn.disabled = idx === dictionary.rules.length - 1;

          moveDownBtn.addEventListener('click', () => {
            if (idx < dictionary.rules.length - 1) {
              // Visual feedback
              moveDownBtn.style.transform = 'scale(0.9)';
              setTimeout(() => {
                moveDownBtn.style.transform = 'scale(1)';
              }, 150);

              // Swap with next item
              const temp = dictionary.rules[idx];
              dictionary.rules[idx] = dictionary.rules[idx + 1];
              dictionary.rules[idx + 1] = temp;

              refreshRuleUI();
              applyRules();
              autoSavePatternHierarchy();
            }
          });
        }

        // Populate category dropdown
        const categorySelect = row.querySelector('.category');
        categorySelect.innerHTML = '';

        // Add default option
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = '💜';
        categorySelect.appendChild(defaultOption);

        // Add categories from listsData
        if (listsData && listsData.keyValueLists) {
          const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
          if (categoriesList && categoriesList.items) {
            categoriesList.items.forEach(item => {
              const option = document.createElement('option');
              option.value = item.key;
              option.textContent = `${item.value} ${item.key}`;
              categorySelect.appendChild(option);
            });
          }
        }

        // Set values
        row.querySelector('.category').value = r.label || '';

        // Set toggle state
        const toggleBtn = row.querySelector('.group-toggle');
        if (toggleBtn) {
          const isEnabled = r.enabled !== false; // Default to true if not specified
          toggleBtn.textContent = isEnabled ? '✓' : '✗';
          toggleBtn.style.background = isEnabled ? '#28a745' : '#dc3545';
          toggleBtn.title = isEnabled ? 'Group enabled' : 'Group disabled';
        }

        // Set style displays
        const style1Display = row.querySelector('.style1-display');
        const style2Display = row.querySelector('.style2-display');
        const style1Btn = row.querySelector('.style1-btn');
        const style2Btn = row.querySelector('.style2-btn');

        if (r.style1 && r.style1.trim() !== '') {
          style1Display.textContent = r.style1;
          applyStyleToButton(style1Btn, '#007aff', r.style1);
        } else {
          style1Display.textContent = 'background';
          style1Btn.style.backgroundColor = '';
          style1Btn.style.color = '';
          style1Btn.style.border = '';
          style1Btn.style.textDecoration = '';
        }

        if (r.style2 && r.style2.trim() !== '') {
          style2Display.textContent = r.style2;
          applyStyleToButton(style2Btn, '#007aff', r.style2);
        } else {
          style2Display.textContent = '-';
          style2Btn.style.backgroundColor = '';
          style2Btn.style.color = '';
          style2Btn.style.border = '';
          style2Btn.style.textDecoration = '';
        }

        // Add event listeners
        row.querySelector('.removeRule').addEventListener('click', () => {
          dictionary.rules.splice(idx, 1);
          refreshRuleUI();
          applyRules();
          autoSavePatternHierarchy();
        });

        // Toggle button event listener
        const groupToggleBtn = row.querySelector('.group-toggle');
        if (groupToggleBtn) {
          groupToggleBtn.addEventListener('click', () => {
            const isEnabled = r.enabled !== false;
            r.enabled = !isEnabled;
            groupToggleBtn.textContent = !isEnabled ? '✓' : '✗';
            groupToggleBtn.style.background = !isEnabled ? '#28a745' : '#dc3545';
            groupToggleBtn.title = !isEnabled ? 'Group enabled' : 'Group disabled';
            applyRules();
            autoSavePatternHierarchy();
          });
        }

        // Live change listeners
        row.querySelector('.category').addEventListener('change', () => {
          dictionary.rules[idx].label = row.querySelector('.category').value;
          updateRawJson();
          autoSavePatternHierarchy();
        });

        // Style button click handlers
        style1Btn.addEventListener('click', (e) => {
          e.stopPropagation();
          showRuleStylePanel(idx, 1);
        });

        style2Btn.addEventListener('click', (e) => {
          e.stopPropagation();
          showRuleStylePanel(idx, 2);
        });

        container.appendChild(node);
      });
      updateRawJson();
      updatePriorityOrderDisplay();
    }

    function refreshObjectsUI() {
      const container = document.getElementById('objectsContainer');
      container.innerHTML = '';

      // Group objects by their group
      const groupedObjects = {};
      objectsData.objects.forEach(obj => {
        if (!groupedObjects[obj.group]) {
          groupedObjects[obj.group] = [];
        }
        groupedObjects[obj.group].push(obj);
      });

      // Create sections for each group
      Object.keys(groupedObjects).forEach(groupName => {
        // Create group header
        const groupHeader = document.createElement('div');
        groupHeader.style.cssText = `
          margin-top: 1rem;
          margin-bottom: 0.5rem;
          padding: 0.5rem;
          background: #f8f9fa;
          border: 1px solid #dee2e6;
          border-radius: 4px;
          font-weight: 600;
          color: #495057;
        `;
        groupHeader.textContent = groupName;
        container.appendChild(groupHeader);

        // Add objects for this group
        groupedObjects[groupName].forEach((obj, idx) => {
          const tpl = document.getElementById('objectTemplate');
          const node = tpl.content.cloneNode(true);
          const row = node.querySelector('.rule-row');
          row.dataset.idx = objectsData.objects.indexOf(obj);

          // Set values
          row.querySelector('.match').value = obj.match || '';
          row.querySelector('.label').value = obj.label || '';

          // Set toggle state
          const objectToggleBtn = row.querySelector('.object-toggle');
          if (objectToggleBtn) {
            const isEnabled = obj.enabled !== false; // Default to true if not specified
            objectToggleBtn.textContent = isEnabled ? '✓' : '✗';
            objectToggleBtn.style.background = isEnabled ? '#28a745' : '#dc3545';
            objectToggleBtn.title = isEnabled ? 'Object enabled' : 'Object disabled';
          }

          // Set color displays
          const color1Display = row.querySelector('.color1-display');
          const color2Display = row.querySelector('.color2-display');
          const color1Btn = row.querySelector('.color1-btn');
          const color2Btn = row.querySelector('.color2-btn');

          if (obj.color1) {
            color1Display.textContent = obj.color1;
            applyStyleToButton(color1Btn, obj.color1, 'background');
          } else {
            color1Display.textContent = 'magenta';
            color1Btn.style.backgroundColor = '';
            color1Btn.style.color = '';
            color1Btn.style.border = '';
            color1Btn.style.textDecoration = '';
          }

          if (obj.color2) {
            color2Display.textContent = obj.color2;
            applyStyleToButton(color2Btn, obj.color2, 'background');
          } else {
            color2Display.textContent = '-';
            color2Btn.style.backgroundColor = '';
            color2Btn.style.color = '';
            color2Btn.style.border = '';
            color2Btn.style.textDecoration = '';
          }

          // Add event listeners
          row.querySelector('.removeObject').addEventListener('click', () => {
            const objIndex = objectsData.objects.indexOf(obj);
            objectsData.objects.splice(objIndex, 1);
            refreshObjectsUI();
            applyRules();
            autoSavePatternHierarchy();
          });

          // Toggle button event listener
          const objToggleBtn = row.querySelector('.object-toggle');
          if (objToggleBtn) {
            objToggleBtn.addEventListener('click', () => {
              const isEnabled = obj.enabled !== false;
              obj.enabled = !isEnabled;
              objToggleBtn.textContent = !isEnabled ? '✓' : '✗';
              objToggleBtn.style.background = !isEnabled ? '#28a745' : '#dc3545';
              objToggleBtn.title = !isEnabled ? 'Object enabled' : 'Object disabled';
              applyRules();
              autoSavePatternHierarchy();
            });
          }

          // Live change listeners
          row.querySelector('.match').addEventListener('input', () => {
            obj.match = row.querySelector('.match').value;
            updateRawJson();
            autoSavePatternHierarchy();
          });

          row.querySelector('.label').addEventListener('input', () => {
            obj.label = row.querySelector('.label').value;
            updateRawJson();
            autoSavePatternHierarchy();
          });

          // Color button click handlers
          color1Btn.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Object color1 button clicked for:', obj.label);
            showObjectColorPanel(objectsData.objects.indexOf(obj), 1);
          });

          color2Btn.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Object color2 button clicked for:', obj.label);
            showObjectColorPanel(objectsData.objects.indexOf(obj), 2);
          });

          container.appendChild(node);
        });
      });
      updateRawJson();
    }

    function prettifyJson(json) {
      const jsonString = JSON.stringify(json, null, 2);

      // Split into lines to preserve formatting
      const lines = jsonString.split('\n');
      const formattedLines = lines.map(line => {
        // Apply syntax highlighting to each line
        return line
          .replace(/"([^"]+)":/g, '<span class="json-key">"$1"</span><span class="json-punctuation">:</span>')
          .replace(/"([^"]*)"/g, '<span class="json-string">"$1"</span>')
          .replace(/\b(true|false)\b/g, '<span class="json-boolean">$1</span>')
          .replace(/\b(null)\b/g, '<span class="json-null">$1</span>')
          .replace(/\b(\d+\.?\d*)\b/g, '<span class="json-number">$1</span>')
          .replace(/([{}[\],])/g, '<span class="json-punctuation">$1</span>');
      });

      // Join lines back together, preserving line breaks
      return formattedLines.join('\n');
    }

    function updateRawJson() {
      const data = {
        defaultPattern: defaultPattern,
        dictionary: dictionary,
        listsData: listsData
      };
      const jsonElement = document.getElementById('rawJson');
      jsonElement.innerHTML = prettifyJson(data);
    }

    let applyRulesTimeout;
    let debugMode = false;
    function applyRules() {
      // Clear any pending timeout to debounce rapid calls
      if (applyRulesTimeout) {
        clearTimeout(applyRulesTimeout);
      }

      // Set a new timeout to execute after a short delay
      applyRulesTimeout = setTimeout(() => {
        applyRulesInternal();
      }, 10);
    }

    function applyRulesInternal() {
      const text = document.getElementById('sourceText').value || '';
      const words = text.split(/(\s+)/); // keep spaces
      const preview = document.getElementById('preview');
      preview.innerHTML = '';
      const elements = [];

      // Get default pattern settings
      const defaultEnabled = document.getElementById('defaultPatternEnabled').checked;
      const defaultPattern = buildPatternFromJSON();
      const defaultLabel = defaultPattern.label;

      // Find all matches for multi-word patterns first
      const multiWordMatches = new Set();

      // Check dictionary rules for multi-word patterns
      for (const rule of dictionary.rules) {
        if (rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              // Store the start and end positions of the match
              multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Check default pattern for multi-word patterns
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            // Store the start and end positions of the match
            multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      words.forEach((token, index) => {
        let cleaned = token;
        if (token.trim() === '') {
          preview.append(document.createTextNode(token));
          return;
        }
        let matched = null;

        // Calculate the position of this token in the original text
        const tokenStart = words.slice(0, index).join('').length;
        const tokenEnd = tokenStart + token.length;
        const tokenRange = `${tokenStart}-${tokenEnd}`;

        // Check if this token is part of a multi-word match
        let isPartOfMultiWordMatch = false;
        for (const matchRange of multiWordMatches) {
          const [matchStart, matchEnd] = matchRange.split('-').map(Number);
          // Check if this token overlaps with the match
          if (tokenStart < matchEnd && tokenEnd > matchStart) {
            isPartOfMultiWordMatch = true;
            break;
          }
        }

        // Check objects for all enabled groups
        for (const rule of dictionary.rules) {
          // Skip disabled rules
          if (rule.enabled === false) {
            continue;
          }

          // Check objects for this group
          for (const obj of objectsData.objects) {
            // Skip disabled objects
            if (obj.enabled === false) {
              continue;
            }

            // Check if object belongs to this group
            if (obj.group === rule.label) {
              try {
                const flags = 'i';
                let regex = new RegExp(obj.match, flags);

                if (obj.match.includes(' ')) {
                  // For multi-word patterns, check if this token is part of a match
                  if (isPartOfMultiWordMatch) {
                    matched = {
                      color1: obj.color1,
                      color2: obj.color2,
                      style1: rule.style1,
                      style2: rule.style2,
                      label: obj.label || obj.group,
                      group: obj.group
                    };
                    break;
                  }
                } else {
                  // For single-word patterns, test against the current token
                  if (regex.test(token)) {
                    if (debugMode) console.log('Creating matched object for:', obj.label, 'Group:', obj.group);
                    matched = {
                      color1: obj.color1,
                      color2: obj.color2,
                      style1: rule.style1,
                      style2: rule.style2,
                      label: obj.label || obj.group,
                      group: obj.group
                    };
                    if (debugMode) console.log('Created matched object:', matched);
                    break;
                  }
                }
              } catch (e) {
                // invalid regex; skip
                console.warn('bad object regex', obj.match);
              }
            }
            if (matched) break;
          }
          if (matched) break;
        }

        // If no match found and default pattern is enabled, try default pattern
        if (!matched && defaultEnabled && defaultPattern) {
          try {
            const flags = 'i';
            let regex = new RegExp(defaultPattern.pattern, flags);

            // Check if pattern contains spaces (multi-word pattern)
            if (defaultPattern.pattern.includes(' ')) {
              // For multi-word patterns, check if this token is part of a match
              if (isPartOfMultiWordMatch) {
                matched = {
                  color1: defaultPattern.color1,
                  color2: defaultPattern.color2,
                  style1: defaultPattern.style1,
                  style2: defaultPattern.style2,
                  label: defaultPattern.label
                };
              }
            } else {
              // For single-word patterns, test against the current token
              if (regex.test(token)) {
                matched = {
                  color1: defaultPattern.color1,
                  color2: defaultPattern.color2,
                  style1: defaultPattern.style1,
                  style2: defaultPattern.style2,
                  label: defaultPattern.label
                };
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad default regex', defaultPattern.pattern);
          }
        }

        const span = document.createElement('span');
        span.textContent = token;
        span.className = 'word';
        if (matched) {
          // Set the title first so symbol style can access the group name
          if (debugMode) console.log('Setting span.title to:', matched.group || '');
          span.title = matched.group || '';

          // Track if symbol style has been applied to prevent duplicates
          let symbolApplied = false;

          // Apply styles based on the new style system
          if (matched.color1 && matched.color1.trim() !== '' && matched.style1 && matched.style1.trim() !== '') {
            applyStyleToElement(span, matched.color1, matched.style1);
          }
          if (matched.color2 && matched.color2.trim() !== '' && matched.style2 && matched.style2.trim() !== '') {
            // For color2, only apply if it's different from color1's style
            if (matched.style2 !== matched.style1) {
              applyStyleToElement(span, matched.color2, matched.style2);
            }
          }
          // Apply symbol style independently of color - check both style1 and style2
          if (matched.style1 === 'symbol' && !symbolApplied) {
            applyStyleToElement(span, '', 'symbol');
            symbolApplied = true;
          }
          if (matched.style2 === 'symbol' && !symbolApplied) {
            applyStyleToElement(span, '', 'symbol');
            symbolApplied = true;
          }
        } else {
          span.style.color = 'inherit';
        }
        preview.appendChild(span);
      });

      // Update current matches display
      const matchesDisplay = document.getElementById('currentMatches');
      if (matchesDisplay) {
        const matches = findCurrentMatches();
        matchesDisplay.textContent = matches.length > 0 ? matches.join(', ') : 'No matches found';
      }
    }

    function downloadMarkdown() {
      const text = document.getElementById('sourceText').value || '';
      // Build markdown with inline color hints using HTML spans
      const previewDiv = document.getElementById('preview');
      let md = '';
      // Iterate over children to preserve spaces
      previewDiv.childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          md += node.textContent;
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const span = node;
          const word = span.textContent;
          const bg = span.style.background;
          const label = span.title;
          if (bg || label) {
            // use inline HTML for color
            md += `<span style="background:${bg}">${word}</span>`;
          } else {
            md += word;
          }
        }
      });
      const blob = new Blob([md], { type: 'text/markdown' });
      const name = document.getElementById('mdName').value || 'export.md';
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.click();
    }

    async function downloadPDF() {
      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        alert('jsPDF not loaded');
        return;
      }
      const pdf = new jsPDF();
      const preview = document.getElementById('preview');
      // Simplest: convert text content with minimal styling
      const lines = [];
      preview.childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          lines.push(node.textContent);
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          let word = node.textContent;
          // add markers for colored
          if (node.style.background) {
            word = `[${word}]`;
          }
          lines.push(word);
        }
      });
      const full = lines.join('');
      // split to fit
      const pageWidth = pdf.internal.pageSize.getWidth();
      const margin = 10;
      const usableWidth = pageWidth - margin * 2;
      const split = pdf.splitTextToSize(full, usableWidth);
      pdf.text(split, margin, 20);
      const name = document.getElementById('pdfName').value || 'export.pdf';
      pdf.save(name);
    }

    function copyStyledHTML() {
      const preview = document.getElementById('preview');
      navigator.clipboard.write([
        new ClipboardItem({
          'text/html': new Blob([preview.innerHTML], { type: 'text/html' }),
          'text/plain': new Blob([preview.textContent], { type: 'text/plain' })
        })
      ]).then(() => alert('Copied styled HTML to clipboard'));
    }

    function copyPlainText() {
      const preview = document.getElementById('preview');
      navigator.clipboard.writeText(preview.textContent).then(() => alert('Copied plain text'));
    }

    async function loadSampleMd() {
      try {
        const response = await fetch('sample.md');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const content = await response.text();
        document.getElementById('sourceText').value = content;
        applyRules();
      } catch (error) {
        console.error('Error loading sample.md:', error);
        alert('Error loading sample.md. Make sure the file exists in the same directory as this HTML file.');
      }
    }

    function refreshPreview() {
      applyRules();
    }

    function buildPatternFromJSON() {
      let pattern = '';

      // Add start anchor if present
      if (defaultPattern.structure.startAnchor) {
        pattern += '^';
      }

      // Add start word boundary if present
      if (defaultPattern.structure.startWordBoundary) {
        pattern += '\\b';
      }

      // Add custom prepend toggles
      defaultPattern.structure.customPrependToggles.forEach(toggle => {
        if (toggle.active) {
          pattern += toggle.regex;
        }
      });

      // Add base pattern
      pattern += defaultPattern.structure.basePattern;

      // Add custom append toggles
      defaultPattern.structure.customAppendToggles.forEach(toggle => {
        if (toggle.active) {
          pattern += toggle.regex;
        }
      });

      // Add end word boundary if present
      if (defaultPattern.structure.endWordBoundary) {
        pattern += '\\b';
      }

      // Add end anchor if present
      if (defaultPattern.structure.endAnchor) {
        pattern += '$';
      }

      return {
        pattern: pattern,
        color1: defaultPattern.color1,
        color2: defaultPattern.color2,
        style1: defaultPattern.style1,
        style2: defaultPattern.style2,
        label: defaultPattern.label
      };
    }

    function updatePatternUI() {
      // Update input fields
      updateDefaultColorButtons();
      document.getElementById('basePatternInput').value = defaultPattern.structure.basePattern;

      // Update wrapper button states
      const startAnchorBtn = document.querySelector('[data-wrapper="start-anchor"]');
      const wordBoundaryBtn = document.querySelector('[data-wrapper="word-boundary"]');
      const endAnchorBtn = document.querySelector('[data-wrapper="end-anchor"]');

      if (startAnchorBtn) {
        startAnchorBtn.dataset.active = defaultPattern.structure.startAnchor;
        startAnchorBtn.style.background = defaultPattern.structure.startAnchor ? '#28a745' : '#555';
      }

      if (wordBoundaryBtn) {
        wordBoundaryBtn.dataset.active = defaultPattern.structure.endWordBoundary;
        wordBoundaryBtn.style.background = defaultPattern.structure.endWordBoundary ? '#28a745' : '#555';
      }

      if (endAnchorBtn) {
        endAnchorBtn.dataset.active = defaultPattern.structure.endAnchor;
        endAnchorBtn.style.background = defaultPattern.structure.endAnchor ? '#28a745' : '#555';
      }

      // Update constructed pattern display
      const pattern = buildPatternFromJSON();
      const display = document.getElementById('constructedPattern');
      if (display) {
        display.textContent = pattern.pattern || '(empty)';
      }

      // Update current matches display
      const matchesDisplay = document.getElementById('currentMatches');
      if (matchesDisplay) {
        const matches = findCurrentMatches();
        matchesDisplay.textContent = matches.length > 0 ? matches.join(', ') : 'No matches found';
      }



      // Update custom toggles display
      updateCustomTogglesDisplay();
    }

    function updateCustomTogglesDisplay() {
      // Update prepend toggles
      const prependContainer = document.getElementById('prependTogglesContainer');
      if (prependContainer) {
        prependContainer.innerHTML = '';
        defaultPattern.structure.customPrependToggles.forEach(toggle => {
          const toggleElement = createToggleElement(toggle, true);
          prependContainer.appendChild(toggleElement);
        });
      }

      // Update append toggles
      const appendContainer = document.getElementById('appendTogglesContainer');
      if (appendContainer) {
        appendContainer.innerHTML = '';
        defaultPattern.structure.customAppendToggles.forEach(toggle => {
          const toggleElement = createToggleElement(toggle, false);
          appendContainer.appendChild(toggleElement);
        });
      }
    }

    function createToggleElement(toggle, isPrepend) {
      const container = document.createElement('div');
      container.className = 'custom-toggle-container';

      // Main toggle button (label only)
      const toggleButton = document.createElement('button');
      toggleButton.className = `toggle-button ${toggle.active ? 'active' : 'inactive'}`;
      toggleButton.title = `Regex: ${toggle.regex}`;
      toggleButton.textContent = toggle.label;

      // Toggle functionality
      toggleButton.addEventListener('click', () => {
        toggleCustomToggle(toggle.id, isPrepend);
      });

      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'toggle-delete';
      deleteBtn.textContent = '✕';
      deleteBtn.title = 'Delete toggle';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent triggering the toggle button
        deleteCustomToggle(toggle.id, isPrepend);
      });

      container.appendChild(toggleButton);
      container.appendChild(deleteBtn);

      return container;
    }

    function updatePatternWithAnchors(anchorType, addAnchor) {
      if (anchorType === 'start') {
        defaultPattern.structure.startAnchor = addAnchor;
      } else if (anchorType === 'end') {
        defaultPattern.structure.endAnchor = addAnchor;
      }
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function updatePatternWithWordBoundaries(addBoundaries) {
      defaultPattern.structure.startWordBoundary = addBoundaries;
      defaultPattern.structure.endWordBoundary = addBoundaries;
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function updatePatternWithRegexToggle(regex, isPrepend, addRegex, label = 'Custom Toggle') {
      if (addRegex) {
        const toggleInfo = {
          id: Date.now().toString(),
          label: label,
          regex: regex,
          position: isPrepend ? 'prepend' : 'append',
          active: true
        };

        if (isPrepend) {
          defaultPattern.structure.customPrependToggles.push(toggleInfo);
        } else {
          defaultPattern.structure.customAppendToggles.push(toggleInfo);
        }
      } else {
        // Remove the regex from the appropriate array
        if (isPrepend) {
          defaultPattern.structure.customPrependToggles = defaultPattern.structure.customPrependToggles.filter(t => t.regex !== regex);
        } else {
          defaultPattern.structure.customAppendToggles = defaultPattern.structure.customAppendToggles.filter(t => t.regex !== regex);
        }
      }
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function toggleCustomToggle(toggleId, isPrepend) {
      const toggles = isPrepend ? defaultPattern.structure.customPrependToggles : defaultPattern.structure.customAppendToggles;
      const toggle = toggles.find(t => t.id === toggleId);
      if (toggle) {
        toggle.active = !toggle.active;
        updatePatternUI();
        applyRules();
        autoSavePatternHierarchy();
      }
    }

    function deleteCustomToggle(toggleId, isPrepend) {
      if (isPrepend) {
        defaultPattern.structure.customPrependToggles = defaultPattern.structure.customPrependToggles.filter(t => t.id !== toggleId);
      } else {
        defaultPattern.structure.customAppendToggles = defaultPattern.structure.customAppendToggles.filter(t => t.id !== toggleId);
      }
      updatePatternUI();
      applyRules();
      autoSavePatternHierarchy();
    }

    function findCurrentMatches() {
      const text = document.getElementById('sourceText').value || '';
      const matches = [];

      // Get default pattern settings
      const defaultEnabled = document.getElementById('defaultPatternEnabled').checked;
      const defaultPattern = buildPatternFromJSON();

      // Split text the same way as applyRules() does
      const tokens = text.split(/(\s+)/); // keep spaces

      // Find all matches for multi-word patterns first
      const multiWordMatches = new Set();

      // Check dictionary rules for multi-word patterns
      for (const rule of dictionary.rules) {
        if (rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              // Store the start and end positions of the match
              multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Check default pattern for multi-word patterns
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            // Store the start and end positions of the match
            multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      // For multi-word patterns, we need to extract the actual matched phrases
      const matchedPhrases = new Set();

      // Extract matched phrases from dictionary rules
      for (const rule of dictionary.rules) {
        if (rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              matchedPhrases.add(match[0]);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Extract matched phrases from default pattern
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            matchedPhrases.add(match[0]);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      // Add multi-word matched phrases
      matchedPhrases.forEach(phrase => {
        matches.push(phrase);
      });

      // Process individual tokens for single-word patterns
      tokens.forEach((token, index) => {
        if (token.trim() === '') {
          return; // Skip empty tokens
        }

        let matched = false;

        // Calculate the position of this token in the original text
        const tokenStart = tokens.slice(0, index).join('').length;
        const tokenEnd = tokenStart + token.length;

        // Check if this token is part of a multi-word match
        let isPartOfMultiWordMatch = false;
        for (const matchRange of multiWordMatches) {
          const [matchStart, matchEnd] = matchRange.split('-').map(Number);
          // Check if this token overlaps with the match
          if (tokenStart < matchEnd && tokenEnd > matchStart) {
            isPartOfMultiWordMatch = true;
            break;
          }
        }

        // Skip tokens that are part of multi-word matches (we already added the full phrases)
        if (isPartOfMultiWordMatch) {
          return;
        }

        // First check dictionary rules
        for (const rule of dictionary.rules) {
          try {
            const flags = 'i';
            let regex = new RegExp(rule.match, flags);

            // Only check single-word patterns here
            if (!rule.match.includes(' ')) {
              const match = token.match(regex);
              if (match) {
                matches.push(match[0]);
                matched = true;
                break;
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad regex', rule.match);
          }
        }

        // If no match found and default pattern is enabled, try default pattern
        if (!matched && defaultEnabled && defaultPattern) {
          try {
            const flags = 'i';
            let regex = new RegExp(defaultPattern.pattern, flags);

            // Only check single-word patterns here
            if (!defaultPattern.pattern.includes(' ')) {
              const match = token.match(regex);
              if (match) {
                matches.push(match[0]);
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad default regex', defaultPattern.pattern);
          }
        }
      });

      // Remove duplicates and return
      return [...new Set(matches)];
    }

    function getGroupEmoji(groupName) {
      if (debugMode) console.log('getGroupEmoji called with:', groupName);
      if (!groupName) {
        if (debugMode) console.log('No groupName provided');
        return null;
      }

      // Get category emojis from listsData
      if (listsData && listsData.keyValueLists) {
        const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
        if (debugMode) console.log('categoriesList found:', !!categoriesList);
        if (categoriesList && categoriesList.items) {
          if (debugMode) console.log('categoriesList.items:', categoriesList.items);
          const category = categoriesList.items.find(item => item.key === groupName);
          if (debugMode) console.log('category found for', groupName, ':', category);
          if (category) {
            if (debugMode) console.log('Returning emoji:', category.value);
            return category.value;
          }
        }
      }
      if (debugMode) console.log('No emoji found for group:', groupName);
      return null;
    }

    function getContrastColor(color) {
      // Handle hex colors
      if (color.startsWith('#')) {
        const hex = color.replace('#', '');
        if (hex.length === 6) {
          // Convert to RGB
          const r = parseInt(hex.substr(0, 2), 16);
          const g = parseInt(hex.substr(2, 2), 16);
          const b = parseInt(hex.substr(4, 2), 16);

          // Calculate luminance
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

          // Return black or white based on luminance
          return luminance > 0.5 ? '#000000' : '#ffffff';
        }
      }

      // For non-hex colors, use a simple heuristic
      const colorLower = color.toLowerCase();
      if (colorLower === 'white' || colorLower === 'yellow' || colorLower === 'cyan' || colorLower === 'lightgray' || colorLower === 'lightgrey') {
        return '#000000';
      } else {
        return '#ffffff';
      }
    }

    function getStyleAbbreviation(style) {
      switch (style) {
        case 'background': return 'bg';
        case 'color': return 'txt';
        case 'underline': return 'ul';
        case 'border': return 'bd';
        case 'symbol': return 'sym';
        default: return 'bg';
      }
    }

    function applyStyleToButton(button, color, style) {
      // Reset all styles first
      button.style.backgroundColor = '';
      button.style.color = '';
      button.style.border = '';
      button.style.textDecoration = '';

      try {
        switch (style) {
          case 'background':
            button.style.backgroundColor = color;
            button.style.color = getContrastColor(color);
            break;
          case 'color':
            button.style.color = color;
            break;
          case 'underline':
            button.style.textDecoration = `underline ${color}`;
            break;
          case 'border':
            button.style.border = `2px solid ${color}`;
            break;
        }
      } catch (e) {
        // If color is invalid, reset to default
        button.style.backgroundColor = '';
        button.style.color = '';
        button.style.border = '';
        button.style.textDecoration = '';
      }
    }

    function applyStyleToElement(element, color, style) {
      try {
        switch (style) {
          case 'background':
            element.style.backgroundColor = color;
            element.style.color = getContrastColor(color);
            element.style.padding = '2px 4px';
            element.style.borderRadius = '3px';
            break;
          case 'color':
            element.style.color = color;
            break;
          case 'underline':
            element.style.textDecoration = `underline ${color}`;
            break;
          case 'border':
            element.style.border = `2px solid ${color}`;
            element.style.padding = '1px 3px';
            element.style.borderRadius = '3px';
            break;
          case 'symbol':
            // Get the group emoji from the title (which contains the group name)
            const groupName = element.title;
            if (debugMode) console.log('Symbol style - groupName:', groupName);
            const emoji = getGroupEmoji(groupName);
            if (debugMode) console.log('Symbol style - emoji:', emoji);
            if (emoji) {
              // Check if the emoji is already at the start of the text to prevent duplicates
              if (!element.textContent.startsWith(emoji + ' ')) {
                element.textContent = emoji + ' ' + element.textContent;
                if (debugMode) console.log('Symbol style applied:', element.textContent);
              } else {
                if (debugMode) console.log('Symbol already applied, skipping');
              }
            }
            break;
        }
      } catch (e) {
        // If color is invalid, reset to default
        element.style.backgroundColor = '';
        element.style.color = '';
        element.style.border = '';
        element.style.textDecoration = '';
      }
    }

    // Lists and Arrays Management Functions
    function refreshListsUI() {
      const container = document.getElementById('listsContainer');
      container.innerHTML = '';

      // Render key-value lists
      listsData.keyValueLists.forEach((list, listIndex) => {
        const listElement = createKeyValueListElement(list, listIndex);
        container.appendChild(listElement);
      });

      // Render arrays
      listsData.arrays.forEach((array, arrayIndex) => {
        const arrayElement = createArrayElement(array, arrayIndex);
        container.appendChild(arrayElement);
      });
    }

    function createKeyValueListElement(list, listIndex) {
      const container = document.createElement('div');
      container.className = 'list-container';
      container.dataset.listIndex = listIndex;
      container.dataset.type = 'keyValue';

      const header = document.createElement('div');
      header.className = 'list-header';

      const title = document.createElement('h3');
      title.className = 'list-title';
      title.contentEditable = true;
      title.textContent = list.name || 'Key-Value List';
      title.addEventListener('blur', () => {
        list.name = title.textContent;
        autoSavePatternHierarchy();
      });

      const typeBadge = document.createElement('span');
      typeBadge.className = 'list-type';
      typeBadge.textContent = 'Key-Value';

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn btn-danger btn-xs';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', () => {
        listsData.keyValueLists.splice(listIndex, 1);
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      header.appendChild(title);
      header.appendChild(typeBadge);
      header.appendChild(deleteBtn);

      const content = document.createElement('div');
      content.className = 'list-content';

      // Render key-value pairs
      list.items.forEach((item, itemIndex) => {
        const row = document.createElement('div');
        row.className = 'key-value-row';

        const keyInput = document.createElement('input');
        keyInput.placeholder = 'Key';
        keyInput.value = item.key || '';
        keyInput.addEventListener('input', () => {
          item.key = keyInput.value;
          autoSavePatternHierarchy();
        });

        const valueInput = document.createElement('input');
        valueInput.placeholder = 'Value';
        valueInput.value = item.value || '';
        valueInput.addEventListener('input', () => {
          item.value = valueInput.value;
          autoSavePatternHierarchy();
        });

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-danger btn-xs';
        removeBtn.textContent = '✕';
        removeBtn.addEventListener('click', () => {
          list.items.splice(itemIndex, 1);
          refreshListsUI();
          autoSavePatternHierarchy();
        });

        row.appendChild(keyInput);
        row.appendChild(valueInput);
        row.appendChild(removeBtn);
        content.appendChild(row);
      });

      const actions = document.createElement('div');
      actions.className = 'list-actions';

      const addItemBtn = document.createElement('button');
      addItemBtn.className = 'btn btn-secondary btn-xs';
      addItemBtn.textContent = '+ Add Item';
      addItemBtn.addEventListener('click', () => {
        list.items.push({ key: '', value: '' });
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      actions.appendChild(addItemBtn);
      content.appendChild(actions);

      container.appendChild(header);
      container.appendChild(content);

      return container;
    }

    function createArrayElement(array, arrayIndex) {
      const container = document.createElement('div');
      container.className = 'list-container';
      container.dataset.arrayIndex = arrayIndex;
      container.dataset.type = 'array';

      const header = document.createElement('div');
      header.className = 'list-header';

      const title = document.createElement('h3');
      title.className = 'list-title';
      title.contentEditable = true;
      title.textContent = array.name || 'Array';
      title.addEventListener('blur', () => {
        array.name = title.textContent;
        autoSavePatternHierarchy();
      });

      const typeBadge = document.createElement('span');
      typeBadge.className = 'list-type';
      typeBadge.textContent = 'Array';

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn btn-danger btn-xs';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', () => {
        listsData.arrays.splice(arrayIndex, 1);
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      header.appendChild(title);
      header.appendChild(typeBadge);
      header.appendChild(deleteBtn);

      const content = document.createElement('div');
      content.className = 'list-content';

      // Render array items
      array.items.forEach((item, itemIndex) => {
        const row = document.createElement('div');
        row.className = 'array-row';

        const valueInput = document.createElement('input');
        valueInput.placeholder = 'Value';
        valueInput.value = item || '';
        valueInput.addEventListener('input', () => {
          array.items[itemIndex] = valueInput.value;
          autoSavePatternHierarchy();
        });

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-danger btn-xs';
        removeBtn.textContent = '✕';
        removeBtn.addEventListener('click', () => {
          array.items.splice(itemIndex, 1);
          refreshListsUI();
          autoSavePatternHierarchy();
        });

        row.appendChild(valueInput);
        row.appendChild(removeBtn);
        content.appendChild(row);
      });

      const actions = document.createElement('div');
      actions.className = 'list-actions';

      const addItemBtn = document.createElement('button');
      addItemBtn.className = 'btn btn-secondary btn-xs';
      addItemBtn.textContent = '+ Add Item';
      addItemBtn.addEventListener('click', () => {
        array.items.push('');
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      actions.appendChild(addItemBtn);
      content.appendChild(actions);

      container.appendChild(header);
      container.appendChild(content);

      return container;
    }

    // Color management functions
    function updateDefaultColorButtons() {
      updateDefaultColorButton(1, defaultPattern.color1, defaultPattern.style1);
      updateDefaultColorButton(2, defaultPattern.color2, defaultPattern.style2);
    }

    function updateDefaultColorButton(colorNum, color, style) {
      const button = colorNum === 1 ? document.getElementById('defaultColor1Btn') : document.getElementById('defaultColor2Btn');
      const colorDisplay = colorNum === 1 ? document.getElementById('defaultColor1Display') : document.getElementById('defaultColor2Display');
      const styleDisplay = colorNum === 1 ? document.getElementById('defaultStyle1Display') : document.getElementById('defaultStyle2Display');

      if (button) {
        if (color && color.trim() !== '' && style && style.trim() !== '') {
          colorDisplay.textContent = color;
          styleDisplay.textContent = getStyleAbbreviation(style);
          applyStyleToButton(button, color, style);
        } else {
          // No color or style set, use default styling
          button.style.backgroundColor = '';
          button.style.color = '';
          button.style.border = '';
          button.style.textDecoration = '';
          colorDisplay.textContent = '-';
          styleDisplay.textContent = '';
        }
      }
    }

    function showDefaultColorPanel(colorNum) {
      const panel = colorNum === 1 ? document.getElementById('defaultColor1Panel') : document.getElementById('defaultColor2Panel');
      const textInput = colorNum === 1 ? document.getElementById('defaultColor1Text') : document.getElementById('defaultColor2Text');
      const picker = colorNum === 1 ? document.getElementById('defaultColor1Picker') : document.getElementById('defaultColor2Picker');
      const styleSelect = colorNum === 1 ? document.getElementById('defaultStyle1Select') : document.getElementById('defaultStyle2Select');
      const display = colorNum === 1 ? document.getElementById('defaultColor1Display') : document.getElementById('defaultColor2Display');
      const button = colorNum === 1 ? document.getElementById('defaultColor1Btn') : document.getElementById('defaultColor2Btn');
      const color = colorNum === 1 ? defaultPattern.color1 : defaultPattern.color2;
      const style = colorNum === 1 ? defaultPattern.style1 : defaultPattern.style2;

      // Set current values
      textInput.value = color;
      display.textContent = color || '-';
      styleSelect.value = style || 'background';

      // Try to set color picker value if it's a hex color
      if (color && color.match(/^#[0-9A-Fa-f]{6}$/)) {
        picker.value = color;
      }

      // Position the panel relative to the button
      if (button) {
        const rect = button.getBoundingClientRect();
        panel.style.position = 'absolute';
        panel.style.top = (rect.bottom + window.scrollY) + 'px';
        panel.style.left = rect.left + 'px';
      }

      panel.classList.add('show');
      textInput.focus();
    }

    function hideDefaultColorPanel(colorNum) {
      const panel = colorNum === 1 ? document.getElementById('defaultColor1Panel') : document.getElementById('defaultColor2Panel');
      panel.classList.remove('show');
    }

    // Rule style panel functions
    function showRuleStylePanel(ruleIndex, styleNum) {
      // Create or get the style panel for this rule
      let panel = document.getElementById(`ruleStylePanel_${ruleIndex}_${styleNum}`);
      if (!panel) {
        panel = createRuleStylePanel(ruleIndex, styleNum);
        document.body.appendChild(panel);
      }

      const rule = dictionary.rules[ruleIndex];
      const style = styleNum === 1 ? rule.style1 : rule.style2;

      // Set current values
      const styleSelect = panel.querySelector('.style-select');
      styleSelect.value = style || 'background';

      // Position the panel relative to the button
      const button = document.querySelector(`[data-idx="${ruleIndex}"] .style${styleNum}-btn`);
      if (button) {
        const rect = button.getBoundingClientRect();
        panel.style.position = 'absolute';
        panel.style.top = (rect.bottom + window.scrollY) + 'px';
        panel.style.left = rect.left + 'px';
      }

      panel.classList.add('show');
      styleSelect.focus();
    }

    function createRuleStylePanel(ruleIndex, styleNum) {
      const panel = document.createElement('div');
      panel.id = `ruleStylePanel_${ruleIndex}_${styleNum}`;
      panel.className = 'inline-form';
      panel.style.cssText = `
        position: absolute;
        min-width: 200px;
        background: white;
        border: 1px solid #dee2e6;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 1000;
      `;

      panel.innerHTML = `
        <div class="inline-form-row">
          <label>Style ${styleNum}:</label>
          <select class="style-select" style="flex: 1;">
            <option value="">None</option>
            <option value="background">Background</option>
            <option value="color">Text Color</option>
            <option value="underline">Underline</option>
            <option value="border">Border</option>
            <option value="symbol">Symbol</option>
          </select>
        </div>
        <div class="inline-form-actions">
          <button class="btn btn-success btn-small apply-rule-style">Apply</button>
          <button class="btn btn-danger btn-small cancel-rule-style">Cancel</button>
        </div>
      `;

      // Add event listeners
      const applyBtn = panel.querySelector('.apply-rule-style');
      const cancelBtn = panel.querySelector('.cancel-rule-style');

      applyBtn.addEventListener('click', () => {
        const style = panel.querySelector('.style-select').value;
        const rule = dictionary.rules[ruleIndex];
        if (styleNum === 1) {
          rule.style1 = style;
        } else {
          rule.style2 = style;
        }
        refreshRuleUI();
        applyRules();
        autoSavePatternHierarchy();
        hideRuleStylePanel(ruleIndex, styleNum);
      });

      cancelBtn.addEventListener('click', () => {
        hideRuleStylePanel(ruleIndex, styleNum);
      });

      return panel;
    }

    function hideRuleStylePanel(ruleIndex, styleNum) {
      const panel = document.getElementById(`ruleStylePanel_${ruleIndex}_${styleNum}`);
      if (panel) {
        panel.classList.remove('show');
      }
    }

    // Object color panel functions
    function showObjectColorPanel(objectIndex, colorNum) {
      // Create or get the color panel for this object
      let panel = document.getElementById(`objectColorPanel_${objectIndex}_${colorNum}`);
      if (!panel) {
        panel = createObjectColorPanel(objectIndex, colorNum);
        document.body.appendChild(panel);
      }

      const obj = objectsData.objects[objectIndex];
      const color = colorNum === 1 ? obj.color1 : obj.color2;
      const style = colorNum === 1 ? obj.style1 : obj.style2;

      // Set current values
      const textInput = panel.querySelector('.color-text');
      const picker = panel.querySelector('.color-picker');

      textInput.value = color || '';

      // Try to set color picker value if it's a hex color
      if (color && color.match(/^#[0-9A-Fa-f]{6}$/)) {
        picker.value = color;
      }

      // Position the panel relative to the button
      const button = document.querySelector(`[data-idx="${objectIndex}"] .color${colorNum}-btn`);
      if (button) {
        const rect = button.getBoundingClientRect();
        panel.style.position = 'absolute';
        panel.style.top = (rect.bottom + window.scrollY) + 'px';
        panel.style.left = rect.left + 'px';
      }

      panel.classList.add('show');
      textInput.focus();
    }

    function createObjectColorPanel(objectIndex, colorNum) {
      const panel = document.createElement('div');
      panel.id = `objectColorPanel_${objectIndex}_${colorNum}`;
      panel.className = 'inline-form';
      panel.style.cssText = `
        position: absolute;
        min-width: 250px;
        background: white;
        border: 1px solid #dee2e6;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 1000;
      `;

      panel.innerHTML = `
        <div class="inline-form-row">
          <label>Color ${colorNum}:</label>
          <input type="text" class="color-text" placeholder="color (e.g. #ff0000) or leave empty for none" style="flex: 1;" />
        </div>
        <div class="inline-form-row">
          <label>Picker:</label>
          <input type="color" class="color-picker" value="#ff00ff" style="width: 50px; height: 30px;" />
        </div>
        <div class="inline-form-actions">
          <button class="btn btn-success btn-small apply-object-color">Apply</button>
          <button class="btn btn-danger btn-small cancel-object-color">Cancel</button>
        </div>
      `;

      // Add event listeners
      const applyBtn = panel.querySelector('.apply-object-color');
      const cancelBtn = panel.querySelector('.cancel-object-color');
      const textInput = panel.querySelector('.color-text');
      const picker = panel.querySelector('.color-picker');

      applyBtn.addEventListener('click', () => {
        const color = textInput.value;
        const obj = objectsData.objects[objectIndex];
        if (colorNum === 1) {
          obj.color1 = color;
        } else {
          obj.color2 = color;
        }
        refreshObjectsUI();
        applyRules();
        autoSavePatternHierarchy();
        hideObjectColorPanel(objectIndex, colorNum);
      });

      cancelBtn.addEventListener('click', () => {
        hideObjectColorPanel(objectIndex, colorNum);
      });

      // Sync picker with text input
      picker.addEventListener('input', () => {
        textInput.value = picker.value;
      });

      textInput.addEventListener('input', () => {
        if (textInput.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          picker.value = textInput.value;
        }
      });

      return panel;
    }

    function hideObjectColorPanel(objectIndex, colorNum) {
      const panel = document.getElementById(`objectColorPanel_${objectIndex}_${colorNum}`);
      if (panel) {
        panel.classList.remove('show');
      }
    }

    // Event Listeners
    document.addEventListener('DOMContentLoaded', function () {
      // Initialize tabs
      initTabs();

      // Handle URL parameters
      handleURLParameters();

      // Basic event listeners
      document.getElementById('clearBtn').addEventListener('click', () => {
        document.getElementById('sourceText').value = '';
        applyRules();
      });

      // Auto-update preview when input text changes
      document.getElementById('sourceText').addEventListener('input', () => {
        applyRules();
      });
      document.getElementById('addRule').addEventListener('click', () => {
        showCategoryDropdown();
      });

      document.getElementById('addObject').addEventListener('click', () => {
        showObjectCategoryDropdown();
      });

      // Function to show category dropdown
      function showCategoryDropdown() {
        const dropdown = document.getElementById('categoryDropdown');
        const button = document.getElementById('addRule');

        // Clear existing options
        dropdown.innerHTML = '';

        // Get existing group labels
        const existingGroups = dictionary.rules.map(rule => rule.label).filter(label => label);

        // Add categories from listsData that are not already used as groups
        if (listsData && listsData.keyValueLists) {
          const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
          if (categoriesList && categoriesList.items) {
            categoriesList.items.forEach(item => {
              // Only show categories that are not already used as groups
              if (!existingGroups.includes(item.key)) {
                const option = document.createElement('div');
                option.className = 'dropdown-option';
                option.style.cssText = 'padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0;';
                option.textContent = `${item.value} ${item.key}`;
                option.addEventListener('click', () => {
                  createNewGroup(item.key);
                  hideCategoryDropdown();
                });
                dropdown.appendChild(option);
              }
            });
          }
        }

        // Show dropdown
        dropdown.style.display = 'block';
      }

      // Function to hide category dropdown
      function hideCategoryDropdown() {
        const dropdown = document.getElementById('categoryDropdown');
        dropdown.style.display = 'none';
      }

      // Function to generate random color
      function generateRandomColor() {
        const colors = [
          '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
          '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
          '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2',
          '#FAD7A0', '#A9CCE3', '#F9E79F', '#D5A6BD', '#A3E4D7'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      // Function to show object category dropdown
      function showObjectCategoryDropdown() {
        const dropdown = document.getElementById('objectCategoryDropdown');
        const button = document.getElementById('addObject');

        // Clear existing options
        dropdown.innerHTML = '';

        // Get existing group labels
        const existingGroups = dictionary.rules.map(rule => rule.label).filter(label => label);

        // Add existing groups to the dropdown
        existingGroups.forEach(groupName => {
          // Find the category info for this group
          let categoryInfo = null;
          if (listsData && listsData.keyValueLists) {
            const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
            if (categoriesList && categoriesList.items) {
              categoryInfo = categoriesList.items.find(item => item.key === groupName);
            }
          }

          const option = document.createElement('div');
          option.className = 'dropdown-option';
          option.style.cssText = 'padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0;';

          // Use category emoji if available, otherwise just the group name
          if (categoryInfo) {
            option.textContent = `${categoryInfo.value} ${groupName}`;
          } else {
            option.textContent = groupName;
          }

          option.addEventListener('click', () => {
            createNewObject(groupName);
            hideObjectCategoryDropdown();
          });
          dropdown.appendChild(option);
        });

        // Show dropdown
        dropdown.style.display = 'block';
      }

      // Function to hide object category dropdown
      function hideObjectCategoryDropdown() {
        const dropdown = document.getElementById('objectCategoryDropdown');
        dropdown.style.display = 'none';
      }

      // Function to create new group
      function createNewGroup(category) {
        // Get the current default pattern
        const defaultPatternData = buildPatternFromJSON();

        // Create a new rule based on the default pattern with the selected category
        const newRule = {
          match: defaultPatternData.pattern,
          color1: generateRandomColor(),
          color2: '',
          style1: 'background',
          style2: '',
          label: category
        };

        dictionary.rules.push(newRule);
        refreshRuleUI();
        autoSavePatternHierarchy();
      }

      // Function to create new object
      function createNewObject(category) {
        // Find the group to inherit styles from
        const group = dictionary.rules.find(rule => rule.label === category);

        // Create a new object with the selected category, inheriting group styles
        const newObject = {
          label: '',
          color1: group ? group.color1 : generateRandomColor(),
          color2: group ? group.color2 : '',
          style1: group ? group.style1 : 'background',
          style2: group ? group.style2 : '',
          match: '',
          group: category
        };

        objectsData.objects.push(newObject);
        refreshObjectsUI();
        autoSavePatternHierarchy();
      }

      // Hide dropdown when clicking outside
      document.addEventListener('click', (e) => {
        const dropdown = document.getElementById('categoryDropdown');
        const button = document.getElementById('addRule');
        if (!button.contains(e.target) && !dropdown.contains(e.target)) {
          hideCategoryDropdown();
        }

        const objectDropdown = document.getElementById('objectCategoryDropdown');
        const objectButton = document.getElementById('addObject');
        if (!objectButton.contains(e.target) && !objectDropdown.contains(e.target)) {
          hideObjectCategoryDropdown();
        }
      });
      document.getElementById('downloadMd').addEventListener('click', downloadMarkdown);
      document.getElementById('downloadPdf').addEventListener('click', downloadPDF);
      document.getElementById('copyHtml').addEventListener('click', copyStyledHTML);
      document.getElementById('copyPlain').addEventListener('click', copyPlainText);
      document.getElementById('copyShareableUrl').addEventListener('click', copyShareableURL);
      document.getElementById('copyMarkdownUrl').addEventListener('click', () => {
        const text = document.getElementById('sourceText').value || '';
        if (!text || text.trim() === '') {
          alert('Please enter some text first before copying a shareable URL.');
          return;
        }
        const shareableURL = generateShareableURL(text, 'markdown');
        if (!shareableURL) {
          return; // User cancelled or URL generation failed
        }
        navigator.clipboard.writeText(shareableURL).then(() => {
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #007aff;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
          `;
          notification.textContent = 'Markdown export URL copied to clipboard!';
          document.body.appendChild(notification);

          setTimeout(() => {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 3000);
        });
      });
      document.getElementById('copyPdfUrl').addEventListener('click', () => {
        const text = document.getElementById('sourceText').value || '';
        if (!text || text.trim() === '') {
          alert('Please enter some text first before copying a shareable URL.');
          return;
        }
        const shareableURL = generateShareableURL(text, 'pdf');
        if (!shareableURL) {
          return; // User cancelled or URL generation failed
        }
        navigator.clipboard.writeText(shareableURL).then(() => {
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #007aff;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
          `;
          notification.textContent = 'PDF export URL copied to clipboard!';
          document.body.appendChild(notification);

          setTimeout(() => {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 3000);
        });
      });

      document.getElementById('testUrlLength').addEventListener('click', () => {
        testURLLength();
        alert('Check the browser console (F12) to see URL length test results!');
      });

      // bob.json operations
      document.getElementById('loadBobJson').addEventListener('click', loadPatternHierarchy);
      document.getElementById('saveBobJson').addEventListener('click', exportPatternHierarchy);

      // Default pattern event listeners
      document.getElementById('defaultPatternEnabled').addEventListener('change', applyRules);

      // Color button and panel functionality
      const defaultColor1Btn = document.getElementById('defaultColor1Btn');
      const defaultColor2Btn = document.getElementById('defaultColor2Btn');
      const defaultColor1Panel = document.getElementById('defaultColor1Panel');
      const defaultColor2Panel = document.getElementById('defaultColor2Panel');
      const defaultColor1Text = document.getElementById('defaultColor1Text');
      const defaultColor2Text = document.getElementById('defaultColor2Text');
      const defaultColor1Picker = document.getElementById('defaultColor1Picker');
      const defaultColor2Picker = document.getElementById('defaultColor2Picker');
      const applyDefaultColor1Btn = document.getElementById('applyDefaultColor1');
      const applyDefaultColor2Btn = document.getElementById('applyDefaultColor2');
      const cancelDefaultColor1Btn = document.getElementById('cancelDefaultColor1');
      const cancelDefaultColor2Btn = document.getElementById('cancelDefaultColor2');

      // Show/hide color panels
      defaultColor1Btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isVisible = defaultColor1Panel.classList.contains('show');
        if (isVisible) {
          hideDefaultColorPanel(1);
        } else {
          showDefaultColorPanel(1);
        }
      });

      defaultColor2Btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isVisible = defaultColor2Panel.classList.contains('show');
        if (isVisible) {
          hideDefaultColorPanel(2);
        } else {
          showDefaultColorPanel(2);
        }
      });

      // Hide panels when clicking outside
      document.addEventListener('click', (e) => {
        if (!defaultColor1Btn.contains(e.target) && !defaultColor1Panel.contains(e.target)) {
          hideDefaultColorPanel(1);
        }
        if (!defaultColor2Btn.contains(e.target) && !defaultColor2Panel.contains(e.target)) {
          hideDefaultColorPanel(2);
        }

        // Hide rule color panels when clicking outside
        const ruleColorPanels = document.querySelectorAll('[id^="ruleColorPanel_"]');
        ruleColorPanels.forEach(panel => {
          if (!panel.contains(e.target)) {
            panel.classList.remove('show');
          }
        });

        // Hide object color panels when clicking outside
        const objectColorPanels = document.querySelectorAll('[id^="objectColorPanel_"]');
        objectColorPanels.forEach(panel => {
          if (!panel.contains(e.target)) {
            panel.classList.remove('show');
          }
        });
      });

      // Apply color changes
      applyDefaultColor1Btn.addEventListener('click', () => {
        const color = defaultColor1Text.value;
        const style = document.getElementById('defaultStyle1Select').value;
        defaultPattern.color1 = color;
        defaultPattern.style1 = style;
        updateDefaultColorButtons();
        updatePatternUI();
        applyRules();
        autoSavePatternHierarchy();
        hideDefaultColorPanel(1);
      });

      applyDefaultColor2Btn.addEventListener('click', () => {
        const color = defaultColor2Text.value;
        const style = document.getElementById('defaultStyle2Select').value;
        defaultPattern.color2 = color;
        defaultPattern.style2 = style;
        updateDefaultColorButtons();
        updatePatternUI();
        applyRules();
        autoSavePatternHierarchy();
        hideDefaultColorPanel(2);
      });

      // Cancel color changes
      cancelDefaultColor1Btn.addEventListener('click', () => {
        hideDefaultColorPanel(1);
        defaultColor1Text.value = defaultPattern.color1;
        document.getElementById('defaultColor1Display').textContent = defaultPattern.color1;
      });

      cancelDefaultColor2Btn.addEventListener('click', () => {
        hideDefaultColorPanel(2);
        defaultColor2Text.value = defaultPattern.color2;
        document.getElementById('defaultColor2Display').textContent = defaultPattern.color2 || '-';
      });

      // Sync color pickers with text inputs
      defaultColor1Picker.addEventListener('input', () => {
        defaultColor1Text.value = defaultColor1Picker.value;
      });

      defaultColor2Picker.addEventListener('input', () => {
        defaultColor2Text.value = defaultColor2Picker.value;
      });

      // Sync text inputs with color pickers
      defaultColor1Text.addEventListener('input', () => {
        if (defaultColor1Text.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          defaultColor1Picker.value = defaultColor1Text.value;
        }
      });

      defaultColor2Text.addEventListener('input', () => {
        if (defaultColor2Text.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          defaultColor2Picker.value = defaultColor2Text.value;
        }
      });

      // Pattern building event listeners
      const basePatternInput = document.getElementById('basePatternInput');
      if (basePatternInput) {
        basePatternInput.addEventListener('input', () => {
          defaultPattern.structure.basePattern = basePatternInput.value;
          updatePatternUI();
          applyRules();
          autoSavePatternHierarchy();
        });
      }



      // Wrapper toggle event listeners
      const wrapperToggles = document.querySelectorAll('.wrapper-toggle');
      wrapperToggles.forEach(btn => {
        btn.addEventListener('click', () => {
          const wrapper = btn.dataset.wrapper;
          const isActive = btn.dataset.active === 'true';

          switch (wrapper) {
            case 'word-boundary':
              updatePatternWithWordBoundaries(!isActive);
              break;
            case 'start-anchor':
              updatePatternWithAnchors('start', !isActive);
              break;
            case 'end-anchor':
              updatePatternWithAnchors('end', !isActive);
              break;
          }
          applyRules();
        });
      });

      // Add regex toggle buttons event listeners
      document.getElementById('addPrependRegexToggle').addEventListener('click', () => {
        const form = document.getElementById('inlineRegexForm');
        const toggleModeBtn = document.getElementById('togglePrependMode');
        const newRegexValue = document.getElementById('newRegexValue');
        const newRegexLabel = document.getElementById('newRegexLabel');

        // Set to prepend mode
        toggleModeBtn.textContent = '^';
        toggleModeBtn.title = 'Toggle between append (+) and prepend (^) mode';

        // Clear form
        newRegexValue.value = '';
        newRegexLabel.value = '';

        // Show form
        form.classList.add('show');
        newRegexValue.focus();
      });

      document.getElementById('addRegexToggle').addEventListener('click', () => {
        const form = document.getElementById('inlineRegexForm');
        const toggleModeBtn = document.getElementById('togglePrependMode');
        const newRegexValue = document.getElementById('newRegexValue');
        const newRegexLabel = document.getElementById('newRegexLabel');

        // Set to append mode
        toggleModeBtn.textContent = '+';
        toggleModeBtn.title = 'Toggle between append (+) and prepend (^) mode';

        // Clear form
        newRegexValue.value = '';
        newRegexLabel.value = '';

        // Show form
        form.classList.add('show');
        newRegexValue.focus();
      });

      // Inline regex form event listeners
      document.getElementById('togglePrependMode').addEventListener('click', () => {
        const btn = document.getElementById('togglePrependMode');
        const isPrepend = btn.textContent === '^';
        btn.textContent = isPrepend ? '+' : '^';
        btn.title = isPrepend ? 'Toggle between append (+) and prepend (^) mode' : 'Toggle between append (+) and prepend (^) mode';
      });

      document.getElementById('saveRegexToggle').addEventListener('click', () => {
        const newRegexValue = document.getElementById('newRegexValue').value;
        const newRegexLabel = document.getElementById('newRegexLabel').value;
        const toggleModeBtn = document.getElementById('togglePrependMode');
        const isPrepend = toggleModeBtn.textContent === '^';

        if (newRegexValue.trim()) {
          updatePatternWithRegexToggle(newRegexValue, isPrepend, true, newRegexLabel || 'Custom Toggle');

          // Hide form
          document.getElementById('inlineRegexForm').classList.remove('show');

          // Clear form
          document.getElementById('newRegexValue').value = '';
          document.getElementById('newRegexLabel').value = '';
        }
      });

      document.getElementById('cancelRegexToggle').addEventListener('click', () => {
        document.getElementById('inlineRegexForm').classList.remove('show');
        document.getElementById('newRegexValue').value = '';
        document.getElementById('newRegexLabel').value = '';
      });

      // Lists and arrays event listeners
      document.getElementById('addKeyValueList').addEventListener('click', () => {
        listsData.keyValueLists.push({
          name: 'New Key-Value List',
          items: [{ key: '', value: '' }]
        });
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      document.getElementById('addArray').addEventListener('click', () => {
        listsData.arrays.push({
          name: 'New Array',
          items: ['']
        });
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      // Bulk load objects event listeners
      document.getElementById('bulkLoadObjects').addEventListener('click', bulkLoadObjects);
      document.getElementById('clearBulkObjects').addEventListener('click', clearBulkObjects);
      document.getElementById('downloadObjectsTemplate').addEventListener('click', downloadObjectsTemplate);

      // Preview buttons event listeners
      document.getElementById('loadSampleMd').addEventListener('click', loadSampleMd);
      document.getElementById('convertBob').addEventListener('click', () => {
        convertBobToMarkdown().catch(error => {
          console.error('Error converting Bob:', error);
          alert('Error converting Bob. Check console for details.');
        });
      });

      // Debug toggle functionality
      document.getElementById('debugToggle').addEventListener('click', () => {
        debugMode = !debugMode;
        const debugBtn = document.getElementById('debugToggle');
        debugBtn.textContent = `Debug: ${debugMode ? 'ON' : 'OFF'}`;
        debugBtn.style.background = debugMode ? '#28a745' : '#6c757d';
        console.log(`Debug mode ${debugMode ? 'enabled' : 'disabled'}`);
      });

      // Refresh button event listener
      document.getElementById('refreshBtn').addEventListener('click', refreshFromBobJson);

      // Priority order management event listeners
      document.getElementById('showPriorityOrder').addEventListener('click', showPriorityOrder);
      document.getElementById('resetPriorityOrder').addEventListener('click', resetPriorityOrder);

      // Initialize UI
      updatePatternUI();
      refreshRuleUI();
      refreshObjectsUI();
      refreshListsUI();
      updateRawJson();

      // Load pattern hierarchy from bob.json on page load
      loadPatternHierarchy();
    });

    // Bulk load objects functions
    function bulkLoadObjects() {
      const input = document.getElementById('bulkObjectsInput').value.trim();
      if (!input) {
        alert('Please enter CSV data to load objects.');
        return;
      }

      const lines = input.split('\n');
      let loadedCount = 0;
      let errorCount = 0;
      const errors = [];

      // Skip header line if it matches the expected format
      const startIndex = lines[0].toLowerCase().includes('label,color1,color2,style1,style2,match,group,enabled') ? 1 : 0;

      for (let i = startIndex; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        const parts = line.split(',').map(part => part.trim());

        if (parts.length < 7) {
          errors.push(`Line ${i + 1}: Insufficient columns (expected 8, got ${parts.length})`);
          errorCount++;
          continue;
        }

        const [label, color1, color2, style1, style2, match, group, enabled] = parts;

        // Validate required fields
        if (!match || !group) {
          errors.push(`Line ${i + 1}: Missing required fields (match and group are required)`);
          errorCount++;
          continue;
        }

        // Create new object
        const newObject = {
          label: label || '',
          color1: color1 || '',
          color2: color2 || '',
          style1: style1 || 'background',
          style2: style2 || '',
          match: match,
          group: group,
          enabled: enabled === 'true' || enabled === '1' || enabled === ''
        };

        objectsData.objects.push(newObject);
        loadedCount++;
      }

      // Show results
      let message = `Loaded ${loadedCount} objects successfully.`;
      if (errorCount > 0) {
        message += `\n\n${errorCount} errors:\n${errors.join('\n')}`;
      }

      if (errorCount > 0) {
        alert(message);
      } else {
        alert(message);
      }

      // Refresh UI and save
      refreshObjectsUI();
      applyRules();
      autoSavePatternHierarchy();
    }

    function clearBulkObjects() {
      document.getElementById('bulkObjectsInput').value = '';
    }

    function downloadObjectsTemplate() {
      const template = `label,color1,color2,style1,style2,match,group,enabled
red,#ff0000,#ffffff,background,color,red,color,true
blue,#0000ff,#ffffff,background,color,blue,color,true
green,#00ff00,#000000,background,color,green,color,true
monday,#ff8fff,#cfcfcf,background,color,monday,day of the week,true
tuesday,#4ECDC4,#ffffff,background,color,tuesday,day of the week,true
a,#ff293e,,color,,^a,letter,true
b,#684ccd,,color,,^b,letter,true`;

      const blob = new Blob([template], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'objects_template.csv';
      a.click();
    }

    // Priority order management functions
    function showPriorityOrder() {
      const orderList = dictionary.rules.map((rule, index) => {
        const emoji = getGroupEmoji(rule.label) || '❓';
        return `${index + 1}. ${emoji} ${rule.label || 'Unnamed Group'}`;
      }).join('\n');

      alert(`Current Group Priority Order:\n\n${orderList}\n\nGroups are applied in this order. The first matching group's style will be applied.`);
    }

    function resetPriorityOrder() {
      // Sort rules alphabetically by label
      dictionary.rules.sort((a, b) => {
        const labelA = (a.label || '').toLowerCase();
        const labelB = (b.label || '').toLowerCase();
        return labelA.localeCompare(labelB);
      });

      refreshRuleUI();
      applyRules();
      autoSavePatternHierarchy();

      alert('Groups have been reset to alphabetical order.');
    }

    function updatePriorityOrderDisplay() {
      const display = document.getElementById('currentPriorityOrder');
      if (display && dictionary.rules.length > 0) {
        const orderText = dictionary.rules.map((rule, index) => {
          const emoji = getGroupEmoji(rule.label) || '❓';
          return `${index + 1}. ${emoji} ${rule.label || 'Unnamed Group'}`;
        }).join(' → ');
        display.textContent = `Current order: ${orderText}`;
      } else if (display) {
        display.textContent = 'No groups defined';
      }
    }

    async function convertBobToMarkdown() {
      let markdown = '';

      // Generate dynamic bob.md content with current date/time
      const now = new Date();
      const dateOptions = {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      };
      const timeOptions = {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      };

      const currentDate = now.toLocaleDateString('en-US', dateOptions);
      const currentTime = now.toLocaleTimeString('en-US', timeOptions);

      // Get category emojis from listsData
      const categoryEmojis = {};
      if (listsData && listsData.keyValueLists) {
        const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
        if (categoriesList && categoriesList.items) {
          categoriesList.items.forEach(item => {
            categoryEmojis[item.key] = item.value;
          });
        }
      }

      // Get group enabled status from dictionary.rules
      const groupEnabledStatus = {};
      dictionary.rules.forEach(rule => {
        if (rule.label) {
          groupEnabledStatus[rule.label] = rule.enabled !== false; // Default to true if not specified
        }
      });

      // Group objects by their group and separate enabled/disabled
      const enabledGroups = {};
      const disabledGroups = {};

      objectsData.objects.forEach(obj => {
        const groupName = obj.group;
        const groupIsEnabled = groupEnabledStatus[groupName] !== false; // Default to true if not specified
        const objectIsEnabled = obj.enabled !== false; // Default to true if not specified
        const isEnabled = groupIsEnabled && objectIsEnabled; // Both group and object must be enabled

        if (isEnabled) {
          if (!enabledGroups[groupName]) {
            enabledGroups[groupName] = [];
          }
          enabledGroups[groupName].push(obj);
        } else {
          if (!disabledGroups[groupName]) {
            disabledGroups[groupName] = [];
          }
          disabledGroups[groupName].push(obj);
        }
      });

      // Get enabled groups for the summary (only groups that have enabled objects)
      const enabledGroupNames = Object.keys(enabledGroups).filter(groupName => enabledGroups[groupName].length > 0);
      const groupList = enabledGroupNames.sort().join(', ');

      const bobContent = `Today is ${currentDate} at ${currentTime}. Recognizable objects are ${groupList}.`;
      markdown += bobContent + '\n\n';

      // Sort groups by priority order (as they appear in dictionary.rules)
      const priorityOrder = dictionary.rules.map(rule => rule.label).filter(label => label);

      const sortedEnabledGroups = priorityOrder.filter(groupName =>
        enabledGroups[groupName] && enabledGroups[groupName].length > 0 && groupEnabledStatus[groupName] !== false
      );
      const sortedDisabledGroups = priorityOrder.filter(groupName =>
        (disabledGroups[groupName] && disabledGroups[groupName].length > 0) || groupEnabledStatus[groupName] === false
      );

      // Generate markdown for enabled groups first
      if (sortedEnabledGroups.length > 0) {
        markdown += '# Enabled Groups\n\n';

        sortedEnabledGroups.forEach(groupName => {
          const emoji = categoryEmojis[groupName] || '❓';
          markdown += `## ${emoji} ${groupName}\n\n`;

          // Sort objects within the group by label
          const sortedObjects = enabledGroups[groupName].sort((a, b) => {
            const labelA = (a.label || '').toLowerCase();
            const labelB = (b.label || '').toLowerCase();
            return labelA.localeCompare(labelB);
          });

          // Add objects to the group
          sortedObjects.forEach(obj => {
            const label = obj.label || obj.match;
            const matchString = obj.match;
            markdown += `- ${label} | ${matchString}\n`;
          });

          markdown += '\n';
        });
      }

      // Generate markdown for disabled groups
      if (sortedDisabledGroups.length > 0) {
        markdown += '# Disabled Groups\n\n';

        sortedDisabledGroups.forEach(groupName => {
          const emoji = categoryEmojis[groupName] || '❓';
          markdown += `## ${emoji} ${groupName}\n\n`;

          // Get all objects for this group (both enabled and disabled objects from disabled groups)
          let allGroupObjects = [];
          if (enabledGroups[groupName]) {
            allGroupObjects = allGroupObjects.concat(enabledGroups[groupName]);
          }
          if (disabledGroups[groupName]) {
            allGroupObjects = allGroupObjects.concat(disabledGroups[groupName]);
          }

          // Sort objects within the group by label
          const sortedObjects = allGroupObjects.sort((a, b) => {
            const labelA = (a.label || '').toLowerCase();
            const labelB = (b.label || '').toLowerCase();
            return labelA.localeCompare(labelB);
          });

          // Add objects to the group
          sortedObjects.forEach(obj => {
            const label = obj.label || obj.match;
            const matchString = obj.match;
            markdown += `- ${label} | ${matchString}\n`;
          });

          markdown += '\n';
        });
      }

      // Append sample.md content
      try {
        const sampleResponse = await fetch('sample.md');
        if (sampleResponse.ok) {
          const sampleContent = await sampleResponse.text();
          markdown += '\n' + sampleContent;
        }
      } catch (error) {
        console.warn('Could not load sample.md:', error);
      }

      // Set the markdown in the textarea
      document.getElementById('sourceText').value = markdown;
      applyRules();
    }
  </script>
</body>

</html>