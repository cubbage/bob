<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Text Parser & Colorizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif;
      padding: 0;
      max-width: none;
      margin: 0;
    }

    /* Tab Styles */
    .tab-container {
      margin-top: 0;
      padding: 1rem;
      padding-top: 0;
    }

    .tab-buttons {
      position: fixed;
      top: 0;
      left: 0;
      right: 300px;
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #e0e0e0;
      background: white;
      padding: 1rem;
      padding-bottom: 0.5rem;
    }

    .main-content-with-sidebar.sidebar-closed .tab-buttons {
      right: 0;
    }

    .tab-buttons-left {
      display: flex;
    }

    .tab-buttons-right {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .tab-button {
      padding: 0.5rem 1rem;
      border: none;
      background: none;
      cursor: pointer;
      font-weight: 500;
      color: #666;
      border-bottom: 3px solid transparent;
      transition: all 0.2s ease;
      font-size: 0.9rem;
    }

    .tab-button.active {
      color: #007aff;
      border-bottom-color: #007aff;
      background: #f8f9fa;
    }

    .tab-button:hover {
      color: #007aff;
      background: #f8f9fa;
    }

    .tab-content {
      display: none;
      padding: 1rem 0;
      margin-top: 4rem;
    }

    .tab-content.active {
      display: block;
    }

    /* Groups Editor Sidebar */
    .groups-editor-sidebar {
      position: fixed;
      top: 0;
      right: 0;
      width: 300px;
      height: 100vh;
      background: #f8f9fa;
      border-left: 1px solid #dee2e6;
      overflow-y: auto;
      z-index: 100;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }

    .groups-editor-sidebar.show {
      transform: translateX(0);
    }

    .groups-editor-header {
      padding: 1rem;
      border-bottom: 1px solid #dee2e6;
      background: white;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .groups-editor-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin: 0 0 0.5rem 0;
      color: #333;
    }

    .refresh-btn,
    .config-btn,
    .groups-editor-toggle {
      background: #f8f9fa;
      color: #666;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      width: 36px;
      height: 36px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    .refresh-btn:hover,
    .config-btn:hover,
    .groups-editor-toggle:hover {
      background: #007aff;
      color: white;
      border-color: #007aff;
    }

    .refresh-btn svg,
    .config-btn svg,
    .groups-editor-toggle svg {
      width: 16px;
      height: 16px;
    }

    .groups-editor-toggle {
      background: #f8f9fa;
      color: #666;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      width: 36px;
      height: 36px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .groups-editor-toggle:hover {
      background: #218838;
      transform: scale(1.1);
    }

    .groups-editor-toggle:active {
      transform: scale(0.95);
    }

    .groups-editor-content {
      padding: 1rem;
    }

    .group-rule-compact {
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      margin-bottom: 0.5rem;
      padding: 0.75rem;
      position: relative;
    }

    .group-rule-compact .move-buttons {
      position: absolute;
      top: 0.5rem;
      left: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .group-rule-compact .rule-content {
      margin-left: 2rem;
    }

    .group-rule-compact .rule-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .group-rule-compact .group-toggle {
      width: 24px;
      height: 24px;
      padding: 0;
      border: 1px solid #dee2e6;
      background: #f8f9fa;
      color: #6c757d;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      transition: all 0.2s ease;
    }

    .group-rule-compact .group-toggle.active {
      background: #28a745;
      color: white;
    }

    .group-rule-compact .group-name {
      font-weight: 600;
      font-size: 0.9rem;
      color: #333;
      flex: 1;
    }

    .group-rule-compact .remove-rule {
      width: 24px;
      height: 24px;
      padding: 0;
      border: 1px solid #dee2e6;
      background: #f8f9fa;
      color: #dc3545;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      transition: all 0.2s ease;
    }

    .group-rule-compact .remove-rule:hover {
      background: #dc3545;
      color: white;
    }

    .group-rule-compact .rule-details {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #666;
    }

    .group-rule-compact .color-preview {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 2px;
      border: 1px solid #dee2e6;
      margin-right: 0.25rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .group-rule-compact .color-preview:hover {
      transform: scale(1.2);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .group-rule-compact .style-edit {
      cursor: pointer;
      transition: all 0.2s ease;
      padding: 2px 4px;
      border-radius: 3px;
    }

    .group-rule-compact .style-edit:hover {
      background: #e9ecef;
    }

    .sidebar-objects-section {
      margin-top: 0.5rem;
      border-top: 1px solid #dee2e6;
      padding-top: 0.5rem;
    }

    .sidebar-objects-toggle {
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
      font-size: 0.8rem;
      padding: 0.25rem 0;
      width: 100%;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .sidebar-objects-toggle:hover {
      color: #333;
    }

    .sidebar-objects-list {
      margin-top: 0.25rem;
      padding-left: 1rem;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .sidebar-objects-list.expanded {
      max-height: 1000px;
    }

    .sidebar-object-item {
      padding: 0.25rem 0;
      font-size: 0.75rem;
      color: #666;
      border-bottom: 1px solid #f0f0f0;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      flex-wrap: wrap;
    }

    .sidebar-object-item:last-child {
      border-bottom: none;
    }

    .sidebar-object-toggle {
      width: 16px;
      height: 16px;
      padding: 0;
      border: 1px solid #dee2e6;
      background: #f8f9fa;
      color: #6c757d;
      cursor: pointer;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 2px;
      transition: all 0.2s ease;
    }

    .sidebar-object-toggle.active {
      background: #28a745;
      color: white;
    }

    /* .sidebar-object-name styles now applied inline to show preview styling */

    .sidebar-add-buttons {
      margin-top: 0.5rem;
      display: flex;
      gap: 0.25rem;
    }

    .sidebar-add-btn {
      padding: 0.25rem 0.5rem;
      border: 1px solid #dee2e6;
      background: #f8f9fa;
      color: #333;
      cursor: pointer;
      font-size: 0.75rem;
      border-radius: 3px;
      transition: all 0.2s ease;
      flex: 1;
    }

    .sidebar-add-btn:hover {
      background: #007aff;
      color: white;
    }

    /* Adjust main content when sidebar is open */
    .main-content-with-sidebar {
      margin-right: 300px;
      transition: margin-right 0.3s ease;
    }

    .main-content-with-sidebar.sidebar-closed {
      margin-right: 0;
    }

    /* Existing Styles */
    textarea {
      width: 100%;
      height: 120px;
      font-family: monospace;
    }

    .preview {
      border: 1px solid #ccc;
      padding: 0.5rem;
      min-height: 100px;
      white-space: pre-wrap;
    }

    .word {
      padding: 2px 3px;
      border-radius: 3px;
      display: inline-block;
      margin: 1px;
    }

    .rule-row {
      display: flex;
      gap: 0;
      margin-bottom: 0;
      flex-wrap: nowrap;
      align-items: center;
      min-width: 0;
    }

    .small {
      font-size: 0.75rem;
      color: #555;
    }

    .flex {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      cursor: pointer;
      border-radius: 5px;
      background: #007aff;
      color: white;
      font-weight: 600;
    }

    .btn-secondary {
      background: #555;
    }

    input,
    select {
      padding: 6px;
    }

    .code {
      background: #f5f5f5;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: monospace;
    }

    .inline-form {
      display: none;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      margin: 0.5rem 0;
      animation: slideDown 0.2s ease-out;
    }

    .inline-form.show {
      display: block;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .inline-form-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .inline-form-row label {
      font-weight: 500;
      min-width: 80px;
    }

    .inline-form-row input {
      flex: 1;
      min-width: 80px;
    }

    .inline-form-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      margin-top: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.5rem;
      font-size: 0.875rem;
    }

    .btn-xs {
      padding: 0.125rem 0.25rem;
      font-size: 0.75rem;
    }

    .btn-success {
      background: #28a745;
    }

    .btn-danger {
      background: #dc3545;
    }

    .custom-toggle-container {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin: 0.25rem 0;
    }

    .toggle-button {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.5rem 0.75rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.875rem;
      transition: background-color 0.2s;
    }

    .toggle-button.active {
      background: #28a745;
      color: white;
    }

    .toggle-button.inactive {
      background: #555;
      color: white;
    }

    .toggle-delete {
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      margin-left: 0.25rem;
    }

    .list-container {
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 1rem;
      background: #f8f9fa;
    }

    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #dee2e6;
    }

    .list-title {
      font-weight: 600;
      font-size: 1.1rem;
      margin: 0;
    }

    .list-type {
      font-size: 0.75rem;
      color: #6c757d;
      background: #e9ecef;
      padding: 0.25rem 0.5rem;
      border-radius: 3px;
    }

    .list-content {
      margin-top: 0.5rem;
    }

    .key-value-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
      align-items: center;
    }

    .key-value-row input {
      flex: 1;
      min-width: 100px;
    }

    .array-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
      align-items: center;
    }

    .array-row input {
      flex: 1;
      min-width: 100px;
    }

    .list-actions {
      display: flex;
      gap: 0.25rem;
      margin-top: 0.5rem;
    }

    .btn-xs {
      padding: 0.125rem 0.25rem;
      font-size: 0.75rem;
    }

    .color-btn {
      position: relative;
      border: 2px solid #dee2e6;
      transition: all 0.2s ease;
    }

    .color-btn:hover {
      border-color: #007aff;
    }

    #defaultColor1Panel,
    #defaultColor2Panel {
      position: absolute;
      min-width: 250px;
      background: white;
      border: 1px solid #dee2e6;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    #defaultColor1Display,
    #defaultColor2Display {
      display: inline-block;
      max-width: 40px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: 600;
    }

    /* JSON Display */
    .json-display {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      max-height: 400px;
      overflow: auto;
      font-family: monospace;
      font-size: 0.875rem;
      line-height: 1.4;
      white-space: pre;
    }

    /* JSON Syntax Highlighting */
    .json-key {
      color: #0066cc;
      font-weight: 600;
    }

    .json-string {
      color: #28a745;
    }

    .json-number {
      color: #fd7e14;
    }

    .json-boolean {
      color: #6f42c1;
    }

    .json-null {
      color: #6c757d;
    }

    .json-punctuation {
      color: #495057;
    }

    /* Refresh Button */
    .refresh-btn {
      background: #007aff;
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      font-size: 16px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .refresh-btn:hover {
      background: #0056b3;
      transform: scale(1.1);
    }

    .refresh-btn:active {
      transform: scale(0.95);
    }

    /* Section headers */
    .section-header {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #e0e0e0;
    }

    .section-header h3 {
      margin: 0;
      color: #333;
    }

    /* Dropdown styling */
    .dropdown-option:hover {
      background-color: #f8f9fa;
    }

    .dropdown-option:last-child {
      border-bottom: none !important;
    }

    /* Style abbreviation styling */
    .style1-display,
    .style2-display {
      font-size: 0.7em;
      opacity: 0.8;
      margin-left: 2px;
    }

    /* Group regex field width */
    .rule-row .match {
      width: 80px;
      min-width: 80px;
      flex-shrink: 0;
    }

    /* Prevent wrapping in rule rows */
    .rule-row>* {
      flex-shrink: 0;
    }

    .rule-row .category {
      flex-shrink: 0;
    }

    .rule-row .label {
      flex-shrink: 0;
    }

    .rule-row .color-btn {
      flex-shrink: 0;
    }

    /* Move buttons for group reordering */
    .move-buttons {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-right: 8px;
    }

    .move-btn {
      width: 24px;
      height: 20px;
      padding: 0;
      border: 1px solid #dee2e6;
      background: #f8f9fa;
      color: #6c757d;
      cursor: pointer;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 2px;
      transition: all 0.2s ease;
    }

    .move-btn:hover {
      background: #e9ecef;
      color: #495057;
    }

    .move-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .move-btn:disabled:hover {
      background: #f8f9fa;
      color: #6c757d;
    }

    .group-priority-info {
      font-size: 0.75rem;
      color: #6c757d;
      margin-top: 0.5rem;
      padding: 0.5rem;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
    }

    /* Object Editor Modal Styles */
    .object-editor-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      animation: fadeIn 0.2s ease-out;
    }

    .object-editor-modal.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .object-editor-content {
      background: white;
      border-radius: 8px;
      padding: 2rem;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      animation: slideIn 0.2s ease-out;
    }

    .object-editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #dee2e6;
    }

    .object-editor-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #333;
      margin: 0;
    }

    .object-editor-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #666;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
    }

    .object-editor-close:hover {
      background: #f8f9fa;
      color: #333;
    }

    .object-editor-form {
      display: grid;
      gap: 1rem;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .form-group label {
      font-weight: 500;
      color: #495057;
      font-size: 0.9rem;
    }

    .form-group input,
    .form-group select {
      padding: 0.75rem;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      font-size: 0.9rem;
      transition: border-color 0.2s ease;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: #007aff;
      box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
    }

    .color-group {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 0.5rem;
      align-items: end;
    }

    .color-picker {
      width: 50px;
      height: 40px;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      cursor: pointer;
      background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.3) 50%, transparent 70%);
    }

    .color-input-group {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 0.5rem;
      align-items: end;
    }

    .color-input-group input[type="text"] {
      padding: 0.75rem;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      font-size: 0.9rem;
      transition: border-color 0.2s ease;
    }

    .color-input-group input[type="text"]:focus {
      outline: none;
      border-color: #007aff;
      box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
    }

    .object-editor-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid #dee2e6;
    }

    .object-editor-actions button {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 4px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-save {
      background: #28a745;
      color: white;
    }

    .btn-save:hover {
      background: #218838;
    }

    .btn-cancel {
      background: #6c757d;
      color: white;
    }

    .btn-cancel:hover {
      background: #5a6268;
    }

    .btn-delete {
      background: #dc3545;
      color: white;
    }

    .btn-delete:hover {
      background: #c82333;
    }

    .object-info {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .object-info h4 {
      margin: 0 0 0.5rem 0;
      color: #495057;
      font-size: 1rem;
    }

    .object-info p {
      margin: 0;
      color: #6c757d;
      font-size: 0.875rem;
    }

    .json-preview {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 1rem;
      font-family: monospace;
      font-size: 0.875rem;
      max-height: 200px;
      overflow-y: auto;
      margin-top: 1rem;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Make matched tokens clickable */
    .word[title] {
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .word[title]:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* Make words within semantic structures clickable */
    .semantic-container .word {
      cursor: pointer;
      transition: all 0.2s ease;
      border-radius: 2px;
      padding: 1px 2px;
    }

    .semantic-container .word:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      background-color: rgba(0, 122, 255, 0.1);
    }
  </style>
</head>

<body>
  <!-- Refresh Button -->
  <!-- Buttons moved to tab area -->

  <!-- Groups Editor Sidebar -->
  <div class="groups-editor-sidebar show" id="groupsEditorSidebar">
    <div class="groups-editor-header">
      <h3 class="groups-editor-title">Groups Editor</h3>
      <div class="sidebar-add-buttons">
        <button class="sidebar-add-btn" id="sidebarAddGroup">+ Group</button>
        <button class="sidebar-add-btn" id="sidebarAddObject">+ Object</button>
      </div>
    </div>
    <div class="groups-editor-content" id="groupsEditorContent">
      <!-- Groups will be populated here -->
    </div>
  </div>

  <div class="tab-container main-content-with-sidebar" id="mainContent">
    <div class="tab-buttons">
      <div class="tab-buttons-left">
        <button class="tab-button active" data-tab="input-preview">WhatBoard</button>
      </div>
      <div class="tab-buttons-right">
        <button class="refresh-btn" id="refreshBtn" title="Refresh from bob.json">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
            <path d="M3 3v5h5" />
          </svg>
        </button>
        <button class="config-btn" id="configBtn" title="Configuration">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path
              d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z" />
            <circle cx="12" cy="12" r="4" />
          </svg>
        </button>
        <button class="groups-editor-toggle" id="groupsEditorToggle" title="Toggle Groups Editor">
          <svg class="sidebar-open-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect width="18" height="18" x="3" y="3" rx="2" />
            <path d="M15 3v18" />
            <path d="m10 15-3-3 3-3" />
          </svg>
          <svg class="sidebar-close-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" width="16"
            height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
            stroke-linejoin="round">
            <rect width="18" height="18" x="3" y="3" rx="2" />
            <path d="M15 3v18" />
            <path d="m8 9 3 3-3 3" />
          </svg>
        </button>
      </div>
    </div>

    <!-- Tab 1: Input Text + Preview + Export -->
    <div id="input-preview" class="tab-content active">
      <div class="section-header">
        <div style="display: flex; justify-content: space-between; align-items: center; gap: 0.5rem;">
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button class="btn btn-secondary" id="loadSampleMd">Load Sample.md</button>
            <button class="btn btn-secondary" id="convertBob">Convert Bob</button>
            <button class="btn btn-secondary" id="clearBtn">Clear</button>
            <button class="btn btn-secondary" id="saveBobJson">Export to File</button>
          </div>
        </div>
      </div>
      <textarea id="sourceText" placeholder="Input text."></textarea>

      <div class="preview" id="preview"></div>

      <div class="section-header">
        <h3>Export</h3>
        <p class="small">💡 <strong>URL Sharing:</strong> Use the "Copy Shareable URL" button to create a link that
          automatically loads your text when opened. You can also manually add parameters like
          <code>?text=your_text_here&export=markdown</code> to the URL. Available export options: markdown, pdf, html,
          plain. Use <code>?clear=true</code> to clear the textarea. For very long text, use
          <code>?clipboard=message</code> or <code>?file=message</code> to show instructions.
        </p>
      </div>
      <div class="flex">
        <div>
          <label>Markdown filename: <input id="mdName" value="export.md"></label>
          <div style="margin-top:0.25rem;">
            <button class="btn" id="downloadMd">Download Markdown</button>
          </div>
        </div>
        <div>
          <label>PDF filename: <input id="pdfName" value="export.pdf"></label>
          <div style="margin-top:0.25rem;">
            <button class="btn" id="downloadPdf">Download PDF</button>
          </div>
        </div>
        <div>
          <div style="margin-bottom:4px;">Clipboard:</div>
          <button class="btn" id="copyHtml">Copy Styled HTML</button>
          <button class="btn" id="copyPlain">Copy Plain Text</button>
          <button class="btn btn-secondary" id="copyShareableUrl">Copy Shareable URL</button>
        </div>
        <div>
          <div style="margin-bottom:4px;">Quick Export URLs:</div>
          <button class="btn btn-secondary btn-small" id="copyMarkdownUrl">Markdown URL</button>
          <button class="btn btn-secondary btn-small" id="copyPdfUrl">PDF URL</button>
          <button class="btn btn-secondary btn-small" id="testUrlLength">Test URL Length</button>
        </div>
      </div>
    </div>

    <!-- Tab 2: Config (Default Search Pattern + Lists and Arrays) -->
    <div id="config" class="tab-content">
      <div class="section-header">
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <h3>Default Search Pattern</h3>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button class="btn btn-secondary" id="loadBobJson">+ custom json</button>
            <button id="debugToggle" class="btn btn-secondary" style="font-size: 12px; padding: 4px 8px;">Debug:
              OFF</button>
          </div>
        </div>
      </div>
      <div style="margin-bottom:0.5rem;">
        <label>
          <input type="checkbox" id="defaultPatternEnabled" checked>
          Enable default search pattern
        </label>
      </div>
      <div id="defaultPatternContainer">
        <div class="rule-row" data-step="0">
          <button id="defaultColor1Btn" class="btn btn-secondary color-btn"
            style="width: 80px; text-align: left; position: relative;">
            <span id="defaultColor1Display">magenta</span>
            <span id="defaultStyle1Display">bg</span>
          </button>
          <button id="defaultColor2Btn" class="btn btn-secondary color-btn"
            style="width: 80px; text-align: left; position: relative;">
            <span id="defaultColor2Display">-</span>
            <span id="defaultStyle2Display"></span>
          </button>
          <div id="defaultColor1Panel" class="inline-form">
            <div class="inline-form-row">
              <label for="defaultColor1Text">Color 1:</label>
              <input id="defaultColor1Text" type="text" placeholder="color (e.g. #ff0000)" value="" style="flex: 1;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultColor1Picker">Picker:</label>
              <input id="defaultColor1Picker" type="color" value="#ff00ff" style="width: 50px; height: 30px;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultStyle1Select">Style:</label>
              <select id="defaultStyle1Select" style="flex: 1;">
                <option value="">None</option>
                <option value="background">Background</option>
                <option value="color">Text Color</option>
                <option value="underline">Underline</option>
                <option value="border">Border</option>
                <option value="symbol">Symbol</option>
              </select>
            </div>
            <div class="inline-form-actions">
              <button class="btn btn-success btn-small" id="applyDefaultColor1">Apply</button>
              <button class="btn btn-danger btn-small" id="cancelDefaultColor1">Cancel</button>
            </div>
          </div>
          <div id="defaultColor2Panel" class="inline-form">
            <div class="inline-form-row">
              <label for="defaultColor2Text">Color 2:</label>
              <input id="defaultColor2Text" type="text" placeholder="color (e.g. #ff0000)" value="" style="flex: 1;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultColor2Picker">Picker:</label>
              <input id="defaultColor2Picker" type="color" value="#0000ff" style="width: 50px; height: 30px;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultStyle2Select">Style:</label>
              <select id="defaultStyle2Select" style="flex: 1;">
                <option value="">None</option>
                <option value="background">Background</option>
                <option value="color">Text Color</option>
                <option value="underline">Underline</option>
                <option value="border">Border</option>
                <option value="symbol">Symbol</option>
              </select>
            </div>
            <div class="inline-form-actions">
              <button class="btn btn-success btn-small" id="applyDefaultColor2">Apply</button>
              <button class="btn btn-danger btn-small" id="cancelDefaultColor2">Cancel</button>
            </div>
          </div>
          <button class="btn btn-secondary wrapper-toggle" data-wrapper="start-anchor" data-active="false">^</button>
          <button class="btn btn-secondary" id="addPrependRegexToggle">+</button>
          <div id="prependTogglesContainer" style="display: flex; gap: 0; align-items: center;"></div>
          <input id="basePatternInput" placeholder="Base pattern (e.g. [A-Z])" value="[A-Z]{1,4}"
            style="width: 70px;" />
          <div id="appendTogglesContainer" style="display: flex; gap: 0; align-items: center;"></div>
          <button class="btn btn-secondary" id="addRegexToggle">+</button>
          <button class="btn btn-secondary wrapper-toggle" data-wrapper="word-boundary" data-active="false">\b</button>
          <button class="btn btn-secondary wrapper-toggle" data-wrapper="end-anchor" data-active="false">$</button>
        </div>

        <!-- Inline form for adding regex toggles -->
        <div id="inlineRegexForm" class="inline-form">
          <div class="inline-form-row">
            <label for="newRegexValue">Regex:</label>
            <input type="text" id="newRegexValue" placeholder="Enter regex string (e.g. [0-9]+)" />
            <button class="btn btn-secondary btn-small" id="togglePrependMode"
              title="Toggle between append (+) and prepend (^) mode">+</button>
          </div>
          <div class="inline-form-row">
            <label for="newRegexLabel">Label:</label>
            <input type="text" id="newRegexLabel" placeholder="Enter button label (e.g. Numbers)" />
          </div>
          <div class="inline-form-actions">
            <button class="btn btn-success btn-small" id="saveRegexToggle">Add Toggle</button>
            <button class="btn btn-danger btn-small" id="cancelRegexToggle">Cancel</button>
          </div>
        </div>
      </div>

      <div style="margin-top: 0.5rem;">
        <strong>Constructed Pattern:</strong> <code id="constructedPattern">[A-Z]{1,4}</code>
      </div>
      <div style="margin-top: 0.5rem;">
        <strong>Current Matches:</strong>
        <pre id="currentMatches" class="code" style="max-height:100px; overflow:auto; font-size: 0.875rem;"></pre>
      </div>
      <p class="small">This pattern will be applied to any text that doesn't match other rules. Build your pattern
        progressively by adding wrappers to each step.</p>

      <div class="section-header">
        <h3>Lists and Arrays Manager</h3>
      </div>
      <div style="margin-bottom:0.5rem;">
        <button class="btn" id="addKeyValueList">+ Add Key-Value List</button>
        <button class="btn btn-secondary" id="addArray">+ Add Array</button>
      </div>
      <div id="listsContainer"></div>
      <p class="small">Manage lists of key:value pairs and arrays that sync with bob.json. Use these for storing
        configuration data, mappings, or any structured data.</p>
    </div>
  </div>

  <template id="ruleTemplate">
    <div class="rule-row">
      <div class="move-buttons">
        <button class="move-btn move-up" title="Move group up">▲</button>
        <button class="move-btn move-down" title="Move group down">▼</button>
      </div>
      <button class="btn btn-secondary group-toggle" style="width: 40px; font-weight: bold;"
        title="Toggle group on/off">✓</button>
      <select class="category" style="width: 150px;">
        <option value="">💜</option>
      </select>
      <button class="style1-btn btn btn-secondary color-btn" style="width: 80px; text-align: left; position: relative;">
        <span class="style1-display">background</span>
      </button>
      <button class="style2-btn btn btn-secondary color-btn" style="width: 80px; text-align: left; position: relative;">
        <span class="style2-display">-</span>
      </button>
      <button class="btn btn-secondary removeRule">✕</button>
    </div>
  </template>

  <template id="objectTemplate">
    <div class="rule-row">
      <button class="btn btn-secondary object-toggle" style="width: 40px; font-weight: bold;"
        title="Toggle object on/off">✓</button>
      <input aria-label="label" placeholder="label (optional)" class="label" style="width: 120px;" />
      <button class="color1-btn btn btn-secondary color-btn" style="width: 80px; text-align: left; position: relative;">
        <span class="color1-display"></span>
      </button>
      <button class="color2-btn btn btn-secondary color-btn" style="width: 80px; text-align: left; position: relative;">
        <span class="color2-display">-</span>
      </button>
      <input aria-label="match" placeholder="regex (e.g. ^[A-M])" class="match" />
      <button class="btn btn-secondary removeObject">✕</button>
    </div>
  </template>

  <!-- Object Editor Modal -->
  <div id="objectEditorModal" class="object-editor-modal">
    <div class="object-editor-content">
      <div class="object-editor-header">
        <h3 class="object-editor-title">Edit Object</h3>
        <button class="object-editor-close" id="closeObjectEditor">&times;</button>
      </div>

      <div class="object-info">
        <h4>Object Information</h4>
        <p><strong>Token:</strong> <span id="objectEditorToken"></span></p>
        <p><strong>Group:</strong> <span id="objectEditorGroup"></span></p>
        <p><strong>Current Match:</strong> <span id="objectEditorMatch"></span></p>
      </div>

      <form class="object-editor-form" id="objectEditorForm">
        <div class="form-group">
          <label for="objectEditorLabel">Label</label>
          <input type="text" id="objectEditorLabel" placeholder="Enter object label">
        </div>

        <div class="form-group">
          <label for="objectEditorMatchRegex">Match Pattern (Regex)</label>
          <input type="text" id="objectEditorMatchRegex" placeholder="Enter regex pattern">
        </div>

        <div class="form-group">
          <label for="objectEditorGroupSelect">Group</label>
          <select id="objectEditorGroupSelect">
            <!-- Options will be populated dynamically -->
          </select>
        </div>

        <div class="form-group">
          <label for="objectEditorColor1">Color 1</label>
          <div class="color-input-group">
            <input type="text" id="objectEditorColor1" placeholder="Color (e.g. #ff0000 or red)">
            <input type="color" id="objectEditorColor1Picker" class="color-picker">
          </div>
        </div>

        <div class="form-group">
          <label for="objectEditorColor2">Color 2</label>
          <div class="color-input-group">
            <input type="text" id="objectEditorColor2" placeholder="Color (e.g. #ffffff or white)">
            <input type="color" id="objectEditorColor2Picker" class="color-picker">
          </div>
        </div>



        <div class="form-group">
          <label>
            <input type="checkbox" id="objectEditorEnabled" checked>
            Enabled
          </label>
        </div>

        <div class="form-group" id="style1Group" style="display: none;">
          <label for="objectEditorStyle1">Style 1</label>
          <select id="objectEditorStyle1">
            <option value="">None</option>
            <option value="background">Background</option>
            <option value="color">Text Color</option>
            <option value="underline">Underline</option>
            <option value="border">Border</option>
            <option value="symbol">Symbol</option>
          </select>
        </div>

        <div class="form-group" id="style2Group" style="display: none;">
          <label for="objectEditorStyle2">Style 2</label>
          <select id="objectEditorStyle2">
            <option value="">None</option>
            <option value="background">Background</option>
            <option value="color">Text Color</option>
            <option value="underline">Underline</option>
            <option value="border">Border</option>
            <option value="symbol">Symbol</option>
          </select>
        </div>

        <div class="json-preview">
          <strong>JSON Preview:</strong>
          <pre id="objectEditorJsonPreview"></pre>
        </div>

        <div class="object-editor-actions">
          <button type="button" class="btn-delete" id="deleteObject">Delete Object</button>
          <button type="button" class="btn-cancel" id="cancelObjectEdit">Cancel</button>
          <button type="submit" class="btn-save" id="saveObject">Save Changes</button>
        </div>
      </form>
    </div>
  </div>
  </div>

  <!-- jsPDF from CDN -->
  <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
    // Tab functionality
    function initTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const targetTab = button.getAttribute('data-tab');

          // Remove active class from all buttons and contents
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));

          // Add active class to clicked button and corresponding content
          button.classList.add('active');
          document.getElementById(targetTab).classList.add('active');
        });
      });
    }

    // URL Parameter Handling
    function handleURLParameters() {
      try {
        const params = new URLSearchParams(window.location.search);
        const incomingText = params.get("text");
        const textId = params.get("textId");
        const clipboardHint = params.get("clipboard");
        const fileHint = params.get("file");
        const autoParse = params.get("parse") === "true";
        const autoExport = params.get("export");
        const clearText = params.get("clear") === "true";

        if (incomingText) {
          // Decode the incoming text
          const decodedText = decodeURIComponent(incomingText);
          console.log("Received text from URL parameter:", decodedText);

          loadTextFromParameter(decodedText);
        } else if (textId) {
          // Load text from localStorage using textId
          const storedText = localStorage.getItem(textId);
          if (storedText) {
            console.log("Received text from localStorage ID:", textId);
            loadTextFromParameter(storedText);

            // Clean up the stored text after loading
            localStorage.removeItem(textId);
          } else {
            console.error("Text not found in localStorage for ID:", textId);
            alert("Shared text not found or has expired.");
          }
        } else if (clipboardHint) {
          // Show clipboard instruction
          showClipboardInstruction(clipboardHint);
        } else if (fileHint) {
          // Show file upload instruction
          showFileUploadInstruction(fileHint);
        }

        function loadTextFromParameter(text) {

          // Set the text in the source textarea
          const sourceTextArea = document.getElementById('sourceText');
          if (sourceTextArea) {
            sourceTextArea.value = decodedText;

            // Apply rules to show the preview
            if (typeof applyRules === 'function') {
              applyRules();
            }

            // Switch to the input-preview tab
            const inputPreviewTab = document.querySelector('[data-tab="input-preview"]');
            if (inputPreviewTab) {
              // Remove active class from all buttons and contents
              document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
              document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

              // Add active class to input-preview tab
              inputPreviewTab.classList.add('active');
              document.getElementById('input-preview').classList.add('active');
            }

            // Handle auto-export if specified
            if (autoExport && typeof applyRules === 'function') {
              // Wait a bit for the preview to update, then export
              setTimeout(() => {
                switch (autoExport.toLowerCase()) {
                  case 'markdown':
                    downloadMarkdown();
                    break;
                  case 'pdf':
                    downloadPDF();
                    break;
                  case 'html':
                    copyStyledHTML();
                    break;
                  case 'plain':
                    copyPlainText();
                    break;
                }
              }, 1000);
            }

            // Show a brief notification
            showURLParameterNotification(text);
          } else {
            console.error('Source textarea not found');
          }
        }

        // Handle clear parameter
        if (clearText) {
          const sourceTextArea = document.getElementById('sourceText');
          if (sourceTextArea) {
            sourceTextArea.value = '';
            if (typeof applyRules === 'function') {
              applyRules();
            }
            showURLParameterNotification('Text cleared');
          }
        }
      } catch (error) {
        console.error('Error handling URL parameters:', error);
      }
    }

    function showURLParameterNotification(text) {
      // Create notification element
      const notification = document.createElement('div');
      notification.id = 'urlParameterNotification';
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #28a745;
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        font-size: 14px;
        z-index: 1001;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        max-width: 80%;
        word-wrap: break-word;
      `;

      // Truncate text if too long
      const displayText = text.length > 100 ? text.substring(0, 100) + '...' : text;
      notification.textContent = `Loaded text from URL: "${displayText}"`;

      document.body.appendChild(notification);

      // Remove notification after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }

    function generateShareableURL(text, exportType = null) {
      if (!text || text.trim() === '') {
        return window.location.href.split('?')[0]; // Return base URL without parameters
      }

      const encodedText = encodeURIComponent(text);
      const urlLength = encodedText.length;

      // Check if URL would be too long (conservative limit of 2000 chars)
      if (urlLength > 2000) {
        const truncatedText = text.substring(0, Math.floor(text.length * 0.8)) + '...';
        const truncatedEncoded = encodeURIComponent(truncatedText);

        // Show warning to user with options
        const choice = confirm(
          `Warning: Your text is very long (${text.length} characters). ` +
          `The URL would be ${urlLength} characters long, which may not work in all browsers.\n\n` +
          `Click OK to create a URL with truncated text (${truncatedText.length} characters).\n` +
          `Click Cancel to use localStorage sharing instead (works for any length).`
        );

        if (choice) {
          // User chose truncated URL
          const baseURL = window.location.href.split('?')[0];
          let url = `${baseURL}?text=${truncatedEncoded}`;

          if (exportType && ['markdown', 'pdf', 'html', 'plain'].includes(exportType.toLowerCase())) {
            url += `&export=${exportType.toLowerCase()}`;
          }

          return url;
        } else {
          // User chose localStorage approach
          return generateLocalStorageURL(text, exportType);
        }
      }

      const baseURL = window.location.href.split('?')[0];
      let url = `${baseURL}?text=${encodedText}`;

      if (exportType && ['markdown', 'pdf', 'html', 'plain'].includes(exportType.toLowerCase())) {
        url += `&export=${exportType.toLowerCase()}`;
      }

      return url;
    }

    function generateLocalStorageURL(text, exportType = null) {
      // Generate a unique ID for this text
      const textId = 'shared_text_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

      // Store the text in localStorage
      localStorage.setItem(textId, text);

      // Create URL with the text ID
      const baseURL = window.location.href.split('?')[0];
      let url = `${baseURL}?textId=${textId}`;

      if (exportType && ['markdown', 'pdf', 'html', 'plain'].includes(exportType.toLowerCase())) {
        url += `&export=${exportType.toLowerCase()}`;
      }

      return url;
    }

    function showClipboardInstruction(message = "Text is on your clipboard") {
      // Switch to input-preview tab
      const inputPreviewTab = document.querySelector('[data-tab="input-preview"]');
      if (inputPreviewTab) {
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

        inputPreviewTab.classList.add('active');
        document.getElementById('input-preview').classList.add('active');
      }

      // Create instruction overlay
      const overlay = document.createElement('div');
      overlay.id = 'clipboardInstruction';
      overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;

      const instructionBox = document.createElement('div');
      instructionBox.style.cssText = `
          background: white;
          padding: 2rem;
          border-radius: 8px;
          max-width: 500px;
          text-align: center;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        `;

      instructionBox.innerHTML = `
          <h3 style="margin: 0 0 1rem 0; color: #007aff;">📋 Clipboard Instructions</h3>
          <p style="margin: 0 0 1.5rem 0; font-size: 1.1rem;">${message}</p>
          <p style="margin: 0 0 1.5rem 0; color: #666;">Please paste the text into the textarea below, then click "Got it!"</p>
          <button id="dismissClipboardInstruction" style="
            background: #007aff;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
          ">Got it!</button>
        `;

      overlay.appendChild(instructionBox);
      document.body.appendChild(overlay);

      // Focus on textarea
      const textarea = document.getElementById('sourceText');
      if (textarea) {
        textarea.focus();
      }

      // Dismiss instruction
      document.getElementById('dismissClipboardInstruction').addEventListener('click', () => {
        document.body.removeChild(overlay);
      });
    }

    function showFileUploadInstruction(message = "Please upload your text file") {
      // Switch to input-preview tab
      const inputPreviewTab = document.querySelector('[data-tab="input-preview"]');
      if (inputPreviewTab) {
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

        inputPreviewTab.classList.add('active');
        document.getElementById('input-preview').classList.add('active');
      }

      // Create instruction overlay
      const overlay = document.createElement('div');
      overlay.id = 'fileUploadInstruction';
      overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;

      const instructionBox = document.createElement('div');
      instructionBox.style.cssText = `
          background: white;
          padding: 2rem;
          border-radius: 8px;
          max-width: 500px;
          text-align: center;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        `;

      instructionBox.innerHTML = `
          <h3 style="margin: 0 0 1rem 0; color: #007aff;">📁 File Upload Instructions</h3>
          <p style="margin: 0 0 1.5rem 0; font-size: 1.1rem;">${message}</p>
          <p style="margin: 0 0 1.5rem 0; color: #666;">Please upload your text file below, then click "Got it!"</p>
          <input type="file" id="fileUploadInput" accept=".txt,.md,.csv" style="
            margin: 0 0 1rem 0;
            padding: 0.5rem;
            border: 2px dashed #007aff;
            border-radius: 5px;
            width: 100%;
          ">
          <button id="dismissFileInstruction" style="
            background: #007aff;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
          ">Got it!</button>
        `;

      overlay.appendChild(instructionBox);
      document.body.appendChild(overlay);

      // Handle file upload
      const fileInput = document.getElementById('fileUploadInput');
      fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            const text = e.target.result;
            document.getElementById('sourceText').value = text;
            applyRules();
          };
          reader.readAsText(file);
        }
      });

      // Dismiss instruction
      document.getElementById('dismissFileInstruction').addEventListener('click', () => {
        document.body.removeChild(overlay);
      });
    }

    // Test function to demonstrate URL length limits
    function testURLLength() {
      const testTexts = [
        "Short text", // ~20 chars encoded
        "This is a medium length text that should work fine in most browsers", // ~80 chars encoded
        "A".repeat(500), // ~1500 chars encoded
        "A".repeat(1000), // ~3000 chars encoded
        "A".repeat(2000) // ~6000 chars encoded
      ];

      console.log("URL Length Test Results:");
      testTexts.forEach((text, index) => {
        const encoded = encodeURIComponent(text);
        const url = `bob.html?text=${encoded}`;
        console.log(`Test ${index + 1}: Original=${text.length} chars, Encoded=${encoded.length} chars, URL=${url.length} chars`);

        if (encoded.length > 2000) {
          console.log(`  ⚠️  Would trigger warning dialog`);
        } else if (encoded.length > 1000) {
          console.log(`  ⚠️  Getting close to limit`);
        } else {
          console.log(`  ✅  Safe to use`);
        }
      });
    }

    // Helper functions for external URL building
    function buildExternalURL(text, exportType = null) {
      const encodedText = encodeURIComponent(text);
      const urlLength = encodedText.length;

      // Conservative limit for external URLs
      if (urlLength > 4000) {
        throw new Error(`Text too long for external URL: ${text.length} chars (${urlLength} encoded)`);
      }

      let url = `https://yourdomain.com/bob.html?text=${encodedText}`;

      if (exportType) {
        url += `&export=${exportType}`;
      }

      return url;
    }

    function buildClipboardURL(message = "Text is on your clipboard", exportType = null) {
      let url = `https://yourdomain.com/bob.html?clipboard=${encodeURIComponent(message)}`;

      if (exportType) {
        url += `&export=${exportType}`;
      }

      return url;
    }

    function buildFileUploadURL(message = "Please upload your text file", exportType = null) {
      let url = `https://yourdomain.com/bob.html?file=${encodeURIComponent(message)}`;

      if (exportType) {
        url += `&export=${exportType}`;
      }

      return url;
    }

    function copyShareableURL() {
      const text = document.getElementById('sourceText').value || '';

      if (!text || text.trim() === '') {
        alert('Please enter some text first before copying a shareable URL.');
        return;
      }

      const shareableURL = generateShareableURL(text);
      if (!shareableURL) {
        return; // User cancelled or URL generation failed
      }

      navigator.clipboard.writeText(shareableURL).then(() => {
        // Show success notification
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: #007aff;
          color: white;
          padding: 12px 20px;
          border-radius: 6px;
          font-size: 14px;
          z-index: 1001;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        `;
        notification.textContent = 'Shareable URL copied to clipboard!';
        document.body.appendChild(notification);

        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      }).catch(err => {
        console.error('Failed to copy URL:', err);
        alert('Failed to copy URL to clipboard');
      });
    }

    // minimal dictionary structure
    let dictionary = { rules: [] };

    // Objects data structure
    let objectsData = { objects: [] };

    // Default pattern JSON structure
    let defaultPattern = {
      label: "Default",
      color1: "",
      color2: "",
      style1: "",
      style2: "",
      structure: {
        startAnchor: false,
        startWordBoundary: false,
        customPrependToggles: [],
        basePattern: "[A-Z]{1,4}",
        customAppendToggles: [],
        endWordBoundary: false,
        endAnchor: false
      }
    };

    // Lists and Arrays Management
    let listsData = {
      keyValueLists: [],
      arrays: []
    };

    // Function to load pattern hierarchy from localStorage or bob.json
    async function loadPatternHierarchy() {
      // First try to load from localStorage
      const localStorageData = localStorage.getItem('bobPatternHierarchy');
      if (localStorageData) {
        try {
          const data = JSON.parse(localStorageData);

          // Load default pattern
          if (data.defaultPattern) {
            defaultPattern = data.defaultPattern;
          }

          // Load dictionary
          if (data.dictionary) {
            dictionary = data.dictionary;
          }

          // Load lists and arrays data
          if (data.listsData) {
            listsData = data.listsData;
          }

          // Load objects data
          if (data.objectsData) {
            objectsData = data.objectsData;
          }

          // Load debug mode
          if (data.debugMode !== undefined) {
            debugMode = data.debugMode;
          }

          // Update UI
          updatePatternUI();
          refreshRuleUI();
          refreshObjectsUI();
          refreshListsUI();
          refreshGroupsSidebar(); // Add sidebar refresh
          applyRules();

          console.log('Pattern hierarchy loaded from localStorage');
          return;
        } catch (error) {
          console.error('Error parsing localStorage data:', error);
        }
      }

      // Fallback to loading from bob.json file
      try {
        const response = await fetch('bob.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        // Load default pattern
        if (data.defaultPattern) {
          defaultPattern = data.defaultPattern;
        }

        // Load dictionary
        if (data.dictionary) {
          dictionary = data.dictionary;
        }

        // Load lists and arrays data
        if (data.listsData) {
          listsData = data.listsData;
        }

        // Update UI
        updatePatternUI();
        refreshRuleUI();
        refreshListsUI();
        refreshGroupsSidebar(); // Add sidebar refresh
        applyRules();

        console.log('Pattern hierarchy loaded from bob.json');
      } catch (error) {
        console.error('Error loading bob.json:', error);
        // If neither localStorage nor file exists, start with empty data
        console.log('No existing data found, starting with empty configuration');
      }

      // Add function to clear localStorage and reload from JSON
      window.clearAndReload = function () {
        localStorage.removeItem('bobPatternHierarchy');
        location.reload();
      };
    }

    // Function to refresh from bob.json and switch to JSON tab
    async function refreshFromBobJson() {
      try {
        const response = await fetch('bob.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        // Load default pattern
        if (data.defaultPattern) {
          defaultPattern = data.defaultPattern;
        }

        // Load dictionary
        if (data.dictionary) {
          dictionary = data.dictionary;
        }

        // Load lists and arrays data
        if (data.listsData) {
          listsData = data.listsData;
        }

        // Load objects data (kept for sidebar functionality)
        if (data.objectsData) {
          objectsData = data.objectsData;
        }

        // Update UI
        updatePatternUI();
        refreshRuleUI();
        refreshObjectsUI();
        refreshListsUI();
        refreshGroupsSidebar(); // Add sidebar refresh
        applyRules();

        // Note: Removed auto-switching to JSON tab as requested

        console.log('Refreshed from bob.json');

        // Show success indicator
        showRefreshIndicator();
      } catch (error) {
        console.error('Error refreshing from bob.json:', error);
        alert('Error loading bob.json. Make sure the file exists and is valid JSON.');
      }
    }

    // Function to show refresh indicator
    function showRefreshIndicator() {
      // Create or update refresh indicator
      let indicator = document.getElementById('refreshIndicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'refreshIndicator';
        indicator.style.cssText = `
          position: fixed;
          top: 80px;
          right: 20px;
          background: #28a745;
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-size: 12px;
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.3s ease;
        `;
        document.body.appendChild(indicator);
      }

      indicator.textContent = '✓ Refreshed from bob.json';
      indicator.style.opacity = '1';

      // Hide after 2 seconds
      setTimeout(() => {
        indicator.style.opacity = '0';
      }, 2000);
    }

    // Function to save pattern hierarchy to localStorage (silent)
    function savePatternHierarchy() {
      try {
        const data = {
          defaultPattern: defaultPattern,
          dictionary: dictionary,
          listsData: listsData,
          objectsData: objectsData, // Kept for sidebar functionality
          debugMode: debugMode
        };

        // Save to localStorage for immediate syncing
        localStorage.setItem('bobPatternHierarchy', JSON.stringify(data));
        console.log('Pattern hierarchy saved to localStorage');
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }
    }

    // Function to export pattern hierarchy to file (with user interaction)
    async function exportPatternHierarchy() {
      try {
        const data = {
          defaultPattern: defaultPattern,
          dictionary: dictionary,
          listsData: listsData,
          objectsData: objectsData
        };

        // Try to use File System Access API for silent saving
        if ('showSaveFilePicker' in window) {
          try {
            const handle = await window.showSaveFilePicker({
              suggestedName: 'bob.json',
              types: [{
                description: 'JSON files',
                accept: { 'application/json': ['.json'] }
              }]
            });
            const writable = await handle.createWritable();
            await writable.write(JSON.stringify(data, null, 2));
            await writable.close();
            console.log('Pattern hierarchy exported to bob.json via File System Access API');
            return;
          } catch (e) {
            console.log('File System Access API failed, falling back to download');
          }
        }

        // Fallback to download method
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'bob.json';
        a.click();

        console.log('Pattern hierarchy exported to bob.json via download');
      } catch (error) {
        console.error('Error exporting bob.json:', error);
      }
    }

    // Function to auto-save pattern hierarchy
    function autoSavePatternHierarchy() {
      // Debounce the save operation
      clearTimeout(window.autoSaveTimeout);
      window.autoSaveTimeout = setTimeout(() => {
        savePatternHierarchy();
        // Show a brief visual indicator
        showSaveIndicator();
      }, 1000); // Save after 1 second of inactivity
    }

    // Object Editor functionality
    let currentEditingObject = null;
    let currentEditingObjectIndex = -1;
    let currentEditingType = 'object'; // 'object' or 'group'

    // Function to open object editor
    function openObjectEditor(token, matchedObject) {
      currentEditingType = 'object'; // Reset to object editing

      // Find the object in objectsData
      const objectIndex = findObjectByToken(token, matchedObject);

      if (objectIndex === -1) {
        // Create a new object if none exists
        currentEditingObject = {
          label: token,
          color1: '',
          color2: '',
          style1: '',
          style2: '',
          match: token.toLowerCase(),
          group: matchedObject.group || '',
          enabled: true
        };
        currentEditingObjectIndex = -1; // New object
      } else {
        // Edit existing object - use the object's actual data, not the token
        currentEditingObject = { ...objectsData.objects[objectIndex] };
        currentEditingObjectIndex = objectIndex;
      }

      // Populate the form
      populateObjectEditorForm(token, matchedObject);

      // Update modal title and show all fields for objects
      document.querySelector('.object-editor-title').textContent = 'Edit Object';

      // Show the object info section for objects
      const objectInfoSection = document.querySelector('.object-info');
      if (objectInfoSection) {
        objectInfoSection.style.display = 'block';
      }

      // Show all fields for object editing
      const matchRegexGroup = document.getElementById('objectEditorMatchRegex').parentElement;
      matchRegexGroup.style.display = 'block';

      const groupSelectGroup = document.getElementById('objectEditorGroupSelect').parentElement;
      groupSelectGroup.style.display = 'block';

      const color1Group = document.getElementById('objectEditorColor1').parentElement.parentElement;
      color1Group.style.display = 'block';

      const color2Group = document.getElementById('objectEditorColor2').parentElement.parentElement;
      color2Group.style.display = 'block';



      // Show the modal
      const modal = document.getElementById('objectEditorModal');
      modal.style.display = 'flex';
      modal.classList.add('show');

      // Update JSON preview
      updateObjectEditorJsonPreview();
    }

    // Function to find object by token and matched object
    function findObjectByToken(token, matchedObject) {
      return objectsData.objects.findIndex(obj => {
        // Check if the object matches this token
        try {
          const regex = new RegExp(obj.match, 'i');
          return regex.test(token) && obj.group === matchedObject.group;
        } catch (e) {
          return false;
        }
      });
    }

    // Function to populate object editor form
    function populateObjectEditorForm(token, matchedObject) {
      // For existing objects, show the actual label in the token field, for new objects show the clicked token
      const displayToken = currentEditingObjectIndex !== -1 ? currentEditingObject.label || token : token;
      document.getElementById('objectEditorToken').textContent = displayToken;
      document.getElementById('objectEditorGroup').textContent = matchedObject.group || 'Unknown';
      document.getElementById('objectEditorMatch').textContent = currentEditingObject.match || token.toLowerCase();

      // Populate form fields - ensure label and match are different
      const objectLabel = currentEditingObject.label || '';
      const objectMatch = currentEditingObject.match || token.toLowerCase();

      document.getElementById('objectEditorLabel').value = objectLabel;
      document.getElementById('objectEditorMatchRegex').value = objectMatch;
      document.getElementById('objectEditorColor1').value = currentEditingObject.color1 || '';
      document.getElementById('objectEditorColor2').value = currentEditingObject.color2 || '';
      document.getElementById('objectEditorEnabled').checked = currentEditingObject.enabled !== false;

      // Populate group dropdown
      populateGroupDropdown();
      document.getElementById('objectEditorGroupSelect').value = currentEditingObject.group || '';

      // Set color picker values
      const color1Picker = document.getElementById('objectEditorColor1Picker');
      const color2Picker = document.getElementById('objectEditorColor2Picker');

      if (currentEditingObject.color1) {
        const normalizedColor1 = normalizeColor(currentEditingObject.color1);
        color1Picker.value = normalizedColor1;
        updateColorPickerBackground('objectEditorColor1Picker', normalizedColor1);
      }
      if (currentEditingObject.color2) {
        const normalizedColor2 = normalizeColor(currentEditingObject.color2);
        color2Picker.value = normalizedColor2;
        updateColorPickerBackground('objectEditorColor2Picker', normalizedColor2);
      }

      // Hide style fields for objects (objects inherit styles from groups)
      const style1Group = document.getElementById('style1Group');
      style1Group.style.display = 'none';

      const style2Group = document.getElementById('style2Group');
      style2Group.style.display = 'none';
    }

    // Function to populate group dropdown
    function populateGroupDropdown() {
      const groupSelect = document.getElementById('objectEditorGroupSelect');
      groupSelect.innerHTML = '';

      // Add groups from dictionary rules
      dictionary.rules.forEach(rule => {
        if (rule.label) {
          const option = document.createElement('option');
          option.value = rule.label;
          option.textContent = rule.label;
          groupSelect.appendChild(option);
        }
      });
    }

    // Function to normalize color for color picker
    function normalizeColor(color) {
      if (!color) return '#000000';

      // Handle named colors
      const namedColors = {
        'red': '#ff0000',
        'green': '#00ff00',
        'blue': '#0000ff',
        'yellow': '#ffff00',
        'cyan': '#00ffff',
        'magenta': '#ff00ff',
        'black': '#000000',
        'white': '#ffffff',
        'gray': '#808080',
        'grey': '#808080',
        'orange': '#ffa500',
        'purple': '#800080',
        'pink': '#ffc0cb',
        'brown': '#a52a2a'
      };

      if (namedColors[color.toLowerCase()]) {
        return namedColors[color.toLowerCase()];
      }

      // Handle hex colors
      if (color.startsWith('#')) {
        return color;
      }

      return '#000000';
    }

    // Function to update color picker background
    function updateColorPickerBackground(pickerId, color) {
      const picker = document.getElementById(pickerId);
      if (picker) {
        const normalizedColor = normalizeColor(color);
        picker.style.backgroundColor = normalizedColor;
        picker.style.backgroundImage = `linear-gradient(45deg, ${normalizedColor} 30%, rgba(255,255,255,0.3) 50%, ${normalizedColor} 70%)`;
      }
    }

    // Function to update JSON preview
    function updateObjectEditorJsonPreview() {
      const formData = getObjectEditorFormData();
      const jsonPreview = document.getElementById('objectEditorJsonPreview');
      jsonPreview.textContent = JSON.stringify(formData, null, 2);
    }

    // Function to get form data
    function getObjectEditorFormData() {
      if (currentEditingType === 'group') {
        return {
          label: document.getElementById('objectEditorLabel').value,
          style1: document.getElementById('objectEditorStyle1').value,
          style2: document.getElementById('objectEditorStyle2').value,
          enabled: document.getElementById('objectEditorEnabled').checked
        };
      } else {
        return {
          label: document.getElementById('objectEditorLabel').value,
          color1: document.getElementById('objectEditorColor1').value,
          color2: document.getElementById('objectEditorColor2').value,
          match: document.getElementById('objectEditorMatchRegex').value,
          group: document.getElementById('objectEditorGroupSelect').value,
          enabled: document.getElementById('objectEditorEnabled').checked
        };
      }
    }

    // Function to save object changes
    function saveObjectChanges() {
      const formData = getObjectEditorFormData();

      if (currentEditingType === 'group') {
        // Validate group fields
        if (!formData.label.trim()) {
          alert('Group name is required');
          return;
        }

        // Update the group (rule)
        Object.assign(currentEditingObject, formData);
        dictionary.rules[currentEditingObjectIndex] = currentEditingObject;

        // Refresh UI and apply rules
        refreshRuleUI();
        refreshGroupsSidebar();
        applyRules();
        autoSavePatternHierarchy();

        // Close modal
        closeObjectEditor();

        // Show success message
        showNotification('Group saved successfully!', 'success');
      } else {
        // Validate object fields
        if (!formData.match.trim()) {
          alert('Match pattern is required');
          return;
        }

        if (!formData.group.trim()) {
          alert('Group is required');
          return;
        }

        // Update the object
        Object.assign(currentEditingObject, formData);

        if (currentEditingObjectIndex === -1) {
          // Add new object
          objectsData.objects.push(currentEditingObject);
        } else {
          // Update existing object
          objectsData.objects[currentEditingObjectIndex] = currentEditingObject;
        }

        // Refresh UI and apply rules
        refreshObjectsUI();
        refreshGroupsSidebar();
        applyRules();
        autoSavePatternHierarchy();

        // Close modal
        closeObjectEditor();

        // Show success message
        showNotification('Object saved successfully!', 'success');
      }
    }

    // Function to delete object
    function deleteObject() {
      if (currentEditingObjectIndex === -1) {
        // New object, just close
        closeObjectEditor();
        return;
      }

      if (confirm('Are you sure you want to delete this object?')) {
        objectsData.objects.splice(currentEditingObjectIndex, 1);
        refreshObjectsUI();
        applyRules();
        autoSavePatternHierarchy();
        closeObjectEditor();
        showNotification('Object deleted successfully!', 'success');
      }
    }

    // Function to close object editor
    function closeObjectEditor() {
      const modal = document.getElementById('objectEditorModal');
      modal.classList.remove('show');
      modal.style.display = 'none';
      currentEditingObject = null;
      currentEditingObjectIndex = -1;
      currentEditingType = 'object';
    }

    // Function to show notification
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: ${type === 'success' ? '#28a745' : '#007aff'};
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        font-size: 14px;
        z-index: 10001;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      `;
      notification.textContent = message;
      document.body.appendChild(notification);

      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }

    // Function to get group emoji
    function getGroupEmoji(groupName) {
      if (listsData && listsData.keyValueLists) {
        const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
        if (categoriesList && categoriesList.items) {
          const category = categoriesList.items.find(item => item.key === groupName);
          return category ? category.value : null;
        }
      }
      return null;
    }

    // Function to create new group from sidebar
    function createNewGroupFromSidebar() {
      const newRule = {
        color1: generateRandomColor(),
        color2: '',
        style1: '',
        style2: '',
        label: 'New Group',
        enabled: true
      };
      dictionary.rules.push(newRule);
      const newIndex = dictionary.rules.length - 1;
      openGroupEditor(newRule, newIndex);
    }

    // Function to open group editor (repurposing object editor modal)
    function openGroupEditor(rule, ruleIndex) {
      currentEditingObject = rule;
      currentEditingObjectIndex = ruleIndex;
      currentEditingType = 'group';

      // Populate the form with group data
      populateGroupEditorForm(rule);

      // Update modal title
      document.querySelector('.object-editor-title').textContent = 'Edit Group';

      // Show the modal
      document.getElementById('objectEditorModal').style.display = 'flex';
      document.getElementById('objectEditorModal').classList.add('show');
    }

    // Function to populate group editor form
    function populateGroupEditorForm(rule) {
      // Update modal title and info section for groups
      document.querySelector('.object-editor-title').textContent = 'Edit Group';

      // Hide the object info section entirely for groups
      const objectInfoSection = document.querySelector('.object-info');
      if (objectInfoSection) {
        objectInfoSection.style.display = 'none';
      }

      // Populate group fields
      document.getElementById('objectEditorLabel').value = rule.label || '';

      // Hide fields not relevant to groups by hiding their parent form-group
      const matchRegexGroup = document.getElementById('objectEditorMatchRegex').parentElement;
      matchRegexGroup.style.display = 'none';

      const groupSelectGroup = document.getElementById('objectEditorGroupSelect').parentElement;
      groupSelectGroup.style.display = 'none';

      // Hide color fields for groups (groups don't have colors, only styles)
      const color1Group = document.getElementById('objectEditorColor1').parentElement.parentElement;
      color1Group.style.display = 'none';

      const color2Group = document.getElementById('objectEditorColor2').parentElement.parentElement;
      color2Group.style.display = 'none';

      // Show style fields for groups (groups have default styles)
      const style1Group = document.getElementById('style1Group');
      style1Group.style.display = 'block';

      const style2Group = document.getElementById('style2Group');
      style2Group.style.display = 'block';

      // Set style values (groups have styles, objects don't)
      document.getElementById('objectEditorStyle1').value = rule.style1 || '';
      document.getElementById('objectEditorStyle2').value = rule.style2 || '';
      document.getElementById('objectEditorEnabled').checked = rule.enabled !== false;

      updateObjectEditorJsonPreview();
    }

    // Function to create new object for specific group
    function createNewObjectForGroup(groupName) {
      const newObject = {
        label: 'Object',
        color1: '',
        color2: '',
        style1: '',
        style2: '',
        match: 'object',
        group: groupName,
        enabled: true
      };
      objectsData.objects.push(newObject);

      // Open object editor for the new object
      openObjectEditor('', newObject);
    }

    // Function to create new object from sidebar (with group selection)
    function createNewObjectFromSidebar() {
      // Get available groups
      const availableGroups = dictionary.rules.map(rule => rule.label).filter(label => label);

      if (availableGroups.length === 0) {
        alert('Please create a group first before adding objects.');
        return;
      }

      const newObject = {
        label: 'New Object',
        color1: '',
        color2: '',
        style1: '',
        style2: '',
        match: '',
        group: availableGroups[0], // Default to first group
        enabled: true
      };

      objectsData.objects.push(newObject);
      const newIndex = objectsData.objects.length - 1;

      // Open object editor for the new object
      openObjectEditor('', newObject);
    }

    // Function to generate random color
    function generateRandomColor() {
      const colors = [
        '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
        '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
        '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2',
        '#FAD7A0', '#A9CCE3', '#F9E79F', '#D5A6BD', '#A3E4D7'
      ];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    // Function to get object preview style
    function getObjectPreviewStyle(obj) {
      let style = '';
      let hasBackground = false;
      let backgroundColors = [];

      // Apply style1 if color1 exists
      if (obj.color1 && obj.style1) {
        if (obj.style1 === 'background') {
          backgroundColors.push(obj.color1);
          hasBackground = true;
        } else if (obj.style1 === 'color' || obj.style1 === 'text') {
          style += `color: ${obj.color1} !important; `;
        } else if (obj.style1 === 'border') {
          style += `border: 2px solid ${obj.color1} !important; `;
        } else if (obj.style1 === 'underline') {
          style += `text-decoration: underline !important; text-decoration-color: ${obj.color1} !important; `;
        } else if (obj.style1 === 'symbol') {
          // For symbol style, we'll add the symbol as content
          style += `color: ${obj.color1} !important; `;
        }
      }

      // Apply style2 if color2 exists
      if (obj.color2 && obj.style2) {
        if (obj.style2 === 'background') {
          backgroundColors.push(obj.color2);
          hasBackground = true;
        } else if (obj.style2 === 'color' || obj.style2 === 'text') {
          style += `color: ${obj.color2} !important; `;
        } else if (obj.style2 === 'border') {
          style += `border: 2px solid ${obj.color2} !important; `;
        } else if (obj.style2 === 'underline') {
          style += `text-decoration: underline !important; text-decoration-color: ${obj.color2} !important; `;
        } else if (obj.style2 === 'symbol') {
          style += `color: ${obj.color2} !important; `;
        }
      }

      // Handle background colors (single or gradient)
      if (hasBackground) {
        if (backgroundColors.length === 1) {
          style += `background-color: ${backgroundColors[0]} !important; `;
        } else if (backgroundColors.length === 2) {
          style += `background: linear-gradient(45deg, ${backgroundColors[0]}, ${backgroundColors[1]}) !important; `;
        }

        // Add padding and border radius for background styles
        style += `padding: 2px 4px !important; border-radius: 2px !important; `;

        // Set text color based on background brightness
        const avgBrightness = backgroundColors.reduce((sum, color) => sum + getBrightness(color), 0) / backgroundColors.length;
        style += `color: ${avgBrightness > 128 ? 'black' : 'white'} !important; `;
      }

      return style;
    }

    // Helper function to calculate color brightness
    function getBrightness(color) {
      if (!color) return 255;

      // Convert hex to RGB
      const hex = color.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);

      // Calculate brightness using YIQ formula
      return (r * 299 + g * 587 + b * 114) / 1000;
    }

    // Function to show object color panel (small modal)
    function showObjectColorPanel(obj, objIndex, colorNumber, colorBox) {
      // Remove any existing color panel
      const existingPanel = document.getElementById('objectColorPanel');
      if (existingPanel) {
        existingPanel.remove();
      }

      const isColor1 = colorNumber === 1;
      const currentColor = isColor1 ? obj.color1 : obj.color2;
      const currentStyle = isColor1 ? obj.style1 : obj.style2;

      const panel = document.createElement('div');
      panel.id = 'objectColorPanel';
      panel.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 1rem;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 2000;
        min-width: 250px;
      `;

      panel.className = 'inline-form';
      panel.innerHTML = `
        <div class="inline-form-row">
          <label>Color ${colorNumber}:</label>
          <input type="text" id="objColorText" value="${currentColor || ''}" placeholder="color (e.g. #ff0000) or leave empty" style="flex: 1;" />
        </div>
        <div class="inline-form-row">
          <label>Picker:</label>
          <input type="color" id="objColorPicker" value="${normalizeColor(currentColor || '#ff00ff')}" style="width: 50px; height: 30px;" />
        </div>
        <div class="inline-form-row">
          <label>Style:</label>
          <select id="objStyleSelect" style="flex: 1;">
            <option value="" ${!currentStyle ? 'selected' : ''}>None</option>
            <option value="background" ${currentStyle === 'background' ? 'selected' : ''}>Background</option>
            <option value="color" ${currentStyle === 'color' ? 'selected' : ''}>Text Color</option>
            <option value="border" ${currentStyle === 'border' ? 'selected' : ''}>Border</option>
            <option value="underline" ${currentStyle === 'underline' ? 'selected' : ''}>Underline</option>
          </select>
        </div>
        <div class="inline-form-actions">
          <button id="saveObjColor" class="btn btn-success btn-small">Apply</button>
          <button id="cancelObjColor" class="btn btn-danger btn-small">Cancel</button>
        </div>
      `;

      document.body.appendChild(panel);

      // Sync color text and picker
      const colorText = document.getElementById('objColorText');
      const colorPicker = document.getElementById('objColorPicker');

      colorText.addEventListener('input', () => {
        if (colorText.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          colorPicker.value = colorText.value;
        }
      });

      colorPicker.addEventListener('input', () => {
        colorText.value = colorPicker.value;
      });

      // Save button
      document.getElementById('saveObjColor').addEventListener('click', () => {
        const color = colorText.value || colorPicker.value;
        const style = document.getElementById('objStyleSelect').value;

        if (isColor1) {
          obj.color1 = color;
          obj.style1 = style;
        } else {
          obj.color2 = color;
          obj.style2 = style;
        }

        // Update color box
        colorBox.style.backgroundColor = color;

        // Refresh sidebar and apply rules
        refreshGroupsSidebar();
        applyRules();
        autoSavePatternHierarchy();

        panel.remove();
        showNotification(`Object color ${colorNumber} updated!`, 'success');
      });

      // Cancel button
      document.getElementById('cancelObjColor').addEventListener('click', () => {
        panel.remove();
      });
    }

    // Function to edit object regex inline
    function editObjectRegexInline(obj, regexSpan) {
      const currentRegex = obj.match || '';
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentRegex;
      input.style.cssText = `
        font-size: 0.7rem;
        font-style: italic;
        background: #fff;
        border: 1px solid #007aff;
        border-radius: 2px;
        padding: 1px 3px;
        width: 80px;
      `;

      function saveRegex() {
        // Prevent double execution
        if (!input || !input.parentNode || input.dataset.removing) {
          return;
        }

        const newRegex = input.value.trim();
        if (newRegex !== currentRegex) {
          obj.match = newRegex;
          regexSpan.textContent = `/${newRegex || 'none'}/`;
          applyRules();
          autoSavePatternHierarchy();
          showNotification('Regex updated!', 'success');
        }
        regexSpan.style.display = 'inline';

        // Mark as removing to prevent double execution
        input.dataset.removing = 'true';
        input.remove();
      }

      function cancelEdit() {
        // Prevent double execution
        if (!input || !input.parentNode || input.dataset.removing) {
          return;
        }

        regexSpan.style.display = 'inline';
        input.dataset.removing = 'true';
        input.remove();
      }

      regexSpan.style.display = 'none';
      regexSpan.parentNode.insertBefore(input, regexSpan.nextSibling);
      input.focus();
      input.select();

      const handleKeydown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          saveRegex();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancelEdit();
        }
      };

      input.addEventListener('blur', saveRegex);
      input.addEventListener('keydown', handleKeydown);
    }

    // Function to show bulk add form
    function showBulkAddForm(groupName, container) {
      // Remove any existing bulk form
      const existingForm = document.getElementById('sidebarBulkForm');
      if (existingForm) {
        existingForm.remove();
      }

      // Hide existing bulk load form if it exists
      const existingBulkForm = document.getElementById('bulkLoadSection');
      if (existingBulkForm) {
        existingBulkForm.style.display = 'none';
      }

      const bulkForm = document.createElement('div');
      bulkForm.id = 'sidebarBulkForm';
      bulkForm.style.cssText = `
        border: 1px solid #007aff;
        border-radius: 4px;
        padding: 1rem;
        margin: 0.5rem 0;
        background: #f8f9fa;
      `;

      bulkForm.innerHTML = `
        <h4 style="margin: 0 0 0.5rem 0; color: #007aff;">Bulk Add Objects to "${groupName}"</h4>
        <div style="margin-bottom: 0.5rem;">
          <label style="display: block; margin-bottom: 0.25rem; font-weight: bold;">Paste Text (one object per line):</label>
          <textarea id="bulkTextArea" placeholder="object1&#10;object2&#10;object3" style="width: 100%; height: 100px; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 0.8rem;"></textarea>
        </div>
        <div style="display: flex; gap: 0.5rem;">
          <button id="processBulkAdd" style="background: #007aff; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">Add Objects</button>
          <button id="cancelBulkAdd" style="background: #666; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">Cancel</button>
        </div>
      `;

      // Insert the form after the container
      container.parentNode.insertBefore(bulkForm, container.nextSibling);

      // Event listeners
      document.getElementById('processBulkAdd').addEventListener('click', () => {
        const textArea = document.getElementById('bulkTextArea');
        const lines = textArea.value.split('\n').filter(line => line.trim());

        if (lines.length === 0) {
          alert('Please enter some text to create objects from.');
          return;
        }

        // Create objects from lines
        let addedCount = 0;
        lines.forEach(line => {
          const trimmedLine = line.trim();
          if (trimmedLine) {
            const newObject = {
              label: trimmedLine,
              color1: '',
              color2: '',
              style1: '',
              style2: '',
              match: trimmedLine.toLowerCase(),
              group: groupName,
              enabled: true
            };
            objectsData.objects.push(newObject);
            addedCount++;
          }
        });

        // Refresh and apply
        refreshGroupsSidebar();
        applyRules();
        autoSavePatternHierarchy();

        // Remove form and show success
        bulkForm.remove();
        showNotification(`Added ${addedCount} objects to "${groupName}"!`, 'success');
      });

      document.getElementById('cancelBulkAdd').addEventListener('click', () => {
        bulkForm.remove();
      });

      // Focus the textarea
      document.getElementById('bulkTextArea').focus();
    }

    // Function to show save indicator
    function showSaveIndicator() {
      // Create or update save indicator
      let indicator = document.getElementById('saveIndicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'saveIndicator';
        indicator.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #28a745;
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-size: 12px;
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.3s ease;
        `;
        document.body.appendChild(indicator);
      }

      indicator.textContent = '✓ Saved';
      indicator.style.opacity = '1';

      // Hide after 2 seconds
      setTimeout(() => {
        indicator.style.opacity = '0';
      }, 2000);
    }

    function refreshRuleUI() {
      const container = document.getElementById('rulesContainer');
      if (!container) {
        // Container was removed from main UI, but function is still called for sidebar
        return;
      }
      container.innerHTML = '';
      dictionary.rules.forEach((r, idx) => {
        const tpl = document.getElementById('ruleTemplate');
        const node = tpl.content.cloneNode(true);
        const row = node.querySelector('.rule-row');
        row.dataset.idx = idx;

        // Add priority number indicator
        const priorityNumber = document.createElement('div');
        priorityNumber.style.cssText = `
          position: absolute;
          top: -8px;
          left: -8px;
          background: #007aff;
          color: white;
          border-radius: 50%;
          width: 20px;
          height: 20px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 10px;
          font-weight: bold;
          z-index: 10;
        `;
        priorityNumber.textContent = idx + 1;
        row.style.position = 'relative';
        row.appendChild(priorityNumber);

        // Add move button functionality
        const moveUpBtn = row.querySelector('.move-up');
        const moveDownBtn = row.querySelector('.move-down');

        if (moveUpBtn) {
          // Disable up button for first item
          moveUpBtn.disabled = idx === 0;

          moveUpBtn.addEventListener('click', () => {
            if (idx > 0) {
              // Visual feedback
              moveUpBtn.style.transform = 'scale(0.9)';
              setTimeout(() => {
                moveUpBtn.style.transform = 'scale(1)';
              }, 150);

              // Swap with previous item
              const temp = dictionary.rules[idx];
              dictionary.rules[idx] = dictionary.rules[idx - 1];
              dictionary.rules[idx - 1] = temp;

              refreshRuleUI();
              applyRules();
              autoSavePatternHierarchy();
            }
          });
        }

        if (moveDownBtn) {
          // Disable down button for last item
          moveDownBtn.disabled = idx === dictionary.rules.length - 1;

          moveDownBtn.addEventListener('click', () => {
            if (idx < dictionary.rules.length - 1) {
              // Visual feedback
              moveDownBtn.style.transform = 'scale(0.9)';
              setTimeout(() => {
                moveDownBtn.style.transform = 'scale(1)';
              }, 150);

              // Swap with next item
              const temp = dictionary.rules[idx];
              dictionary.rules[idx] = dictionary.rules[idx + 1];
              dictionary.rules[idx + 1] = temp;

              refreshRuleUI();
              applyRules();
              autoSavePatternHierarchy();
            }
          });
        }

        // Populate category dropdown
        const categorySelect = row.querySelector('.category');
        categorySelect.innerHTML = '';

        // Add default option
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = '💜';
        categorySelect.appendChild(defaultOption);

        // Add categories from listsData
        if (listsData && listsData.keyValueLists) {
          const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
          if (categoriesList && categoriesList.items) {
            categoriesList.items.forEach(item => {
              const option = document.createElement('option');
              option.value = item.key;
              option.textContent = `${item.value} ${item.key}`;
              categorySelect.appendChild(option);
            });
          }
        }

        // Set values
        row.querySelector('.category').value = r.label || '';

        // Set toggle state
        const toggleBtn = row.querySelector('.group-toggle');
        if (toggleBtn) {
          const isEnabled = r.enabled !== false; // Default to true if not specified
          toggleBtn.textContent = isEnabled ? '✓' : '✗';
          toggleBtn.style.background = isEnabled ? '#28a745' : '#dc3545';
          toggleBtn.title = isEnabled ? 'Group enabled' : 'Group disabled';
        }

        // Set style displays
        const style1Display = row.querySelector('.style1-display');
        const style2Display = row.querySelector('.style2-display');
        const style1Btn = row.querySelector('.style1-btn');
        const style2Btn = row.querySelector('.style2-btn');

        if (r.style1 && r.style1.trim() !== '') {
          style1Display.textContent = r.style1;
          applyStyleToButton(style1Btn, '#007aff', r.style1);
        } else {
          style1Display.textContent = 'background';
          style1Btn.style.backgroundColor = '';
          style1Btn.style.color = '';
          style1Btn.style.border = '';
          style1Btn.style.textDecoration = '';
        }

        if (r.style2 && r.style2.trim() !== '') {
          style2Display.textContent = r.style2;
          applyStyleToButton(style2Btn, '#007aff', r.style2);
        } else {
          style2Display.textContent = '-';
          style2Btn.style.backgroundColor = '';
          style2Btn.style.color = '';
          style2Btn.style.border = '';
          style2Btn.style.textDecoration = '';
        }

        // Add event listeners
        row.querySelector('.removeRule').addEventListener('click', () => {
          dictionary.rules.splice(idx, 1);
          refreshRuleUI();
          applyRules();
          autoSavePatternHierarchy();
        });

        // Toggle button event listener
        const groupToggleBtn = row.querySelector('.group-toggle');
        if (groupToggleBtn) {
          groupToggleBtn.addEventListener('click', () => {
            const isEnabled = r.enabled !== false;
            r.enabled = !isEnabled;
            groupToggleBtn.textContent = !isEnabled ? '✓' : '✗';
            groupToggleBtn.style.background = !isEnabled ? '#28a745' : '#dc3545';
            groupToggleBtn.title = !isEnabled ? 'Group enabled' : 'Group disabled';
            applyRules();
            autoSavePatternHierarchy();
          });
        }

        // Live change listeners
        row.querySelector('.category').addEventListener('change', () => {
          dictionary.rules[idx].label = row.querySelector('.category').value;
          autoSavePatternHierarchy();
        });

        // Style button click handlers
        style1Btn.addEventListener('click', (e) => {
          e.stopPropagation();
          showRuleStylePanel(idx, 1);
        });

        style2Btn.addEventListener('click', (e) => {
          e.stopPropagation();
          showRuleStylePanel(idx, 2);
        });

        container.appendChild(node);
      });
      // Removed updatePriorityOrderDisplay() call - element no longer exists

      // Also refresh the sidebar if it's open
      if (document.getElementById('groupsEditorSidebar').classList.contains('show')) {
        refreshGroupsSidebar();
      }
    }

    // Global variable to track expanded object lists
    let expandedObjectLists = new Set();

    // Function to refresh groups in sidebar
    function refreshGroupsSidebar() {
      const container = document.getElementById('groupsEditorContent');
      if (!container) return;

      container.innerHTML = '';
      dictionary.rules.forEach((rule, idx) => {
        const ruleElement = createCompactGroupRule(rule, idx);
        container.appendChild(ruleElement);
      });
    }

    // Function to create compact group rule element
    function createCompactGroupRule(rule, idx) {
      const ruleElement = document.createElement('div');
      ruleElement.className = 'group-rule-compact';
      ruleElement.dataset.idx = idx;

      // Move buttons
      const moveButtons = document.createElement('div');
      moveButtons.className = 'move-buttons';

      const moveUpBtn = document.createElement('button');
      moveUpBtn.className = 'move-btn move-up';
      moveUpBtn.textContent = '▲';
      moveUpBtn.title = 'Move group up';
      moveUpBtn.disabled = idx === 0;
      moveUpBtn.addEventListener('click', () => {
        if (idx > 0) {
          const temp = dictionary.rules[idx];
          dictionary.rules[idx] = dictionary.rules[idx - 1];
          dictionary.rules[idx - 1] = temp;
          refreshGroupsSidebar();
          applyRules();
          autoSavePatternHierarchy();
        }
      });

      const moveDownBtn = document.createElement('button');
      moveDownBtn.className = 'move-btn move-down';
      moveDownBtn.textContent = '▼';
      moveDownBtn.title = 'Move group down';
      moveDownBtn.disabled = idx === dictionary.rules.length - 1;
      moveDownBtn.addEventListener('click', () => {
        if (idx < dictionary.rules.length - 1) {
          const temp = dictionary.rules[idx];
          dictionary.rules[idx] = dictionary.rules[idx + 1];
          dictionary.rules[idx + 1] = temp;
          refreshGroupsSidebar();
          applyRules();
          autoSavePatternHierarchy();
        }
      });

      moveButtons.appendChild(moveUpBtn);
      moveButtons.appendChild(moveDownBtn);

      // Rule content
      const ruleContent = document.createElement('div');
      ruleContent.className = 'rule-content';

      // Rule header
      const ruleHeader = document.createElement('div');
      ruleHeader.className = 'rule-header';

      // Toggle button
      const toggleBtn = document.createElement('button');
      toggleBtn.className = `group-toggle ${rule.enabled !== false ? 'active' : ''}`;
      toggleBtn.textContent = rule.enabled !== false ? '✓' : '✗';
      toggleBtn.addEventListener('click', () => {
        rule.enabled = !(rule.enabled !== false);
        toggleBtn.textContent = rule.enabled ? '✓' : '✗';
        toggleBtn.classList.toggle('active', rule.enabled);
        applyRules();
        autoSavePatternHierarchy();
      });

      // Group name with emoji
      const groupName = document.createElement('div');
      groupName.className = 'group-name';
      const emoji = getGroupEmoji(rule.label);
      const nameText = rule.label || 'Unnamed Group';
      groupName.textContent = emoji ? `${emoji} ${nameText}` : nameText;

      // Remove button
      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-rule';
      removeBtn.textContent = '✕';
      removeBtn.addEventListener('click', () => {
        dictionary.rules.splice(idx, 1);
        refreshGroupsSidebar();
        applyRules();
        autoSavePatternHierarchy();
      });

      ruleHeader.appendChild(toggleBtn);
      ruleHeader.appendChild(groupName);
      ruleHeader.appendChild(removeBtn);

      // Rule details - clickable for editing
      const ruleDetails = document.createElement('div');
      ruleDetails.className = 'rule-details';
      ruleDetails.style.cursor = 'pointer';
      ruleDetails.title = 'Click to edit group';

      const styleInfo = document.createElement('div');
      styleInfo.innerHTML = `Style1: ${rule.style1 || 'none'} | Style2: ${rule.style2 || 'none'}`;

      // Make entire details section clickable
      ruleDetails.addEventListener('click', () => {
        openGroupEditor(rule, idx);
      });

      ruleDetails.appendChild(styleInfo);

      ruleContent.appendChild(ruleHeader);
      ruleContent.appendChild(ruleDetails);

      // Objects section
      const objectsSection = createGroupObjectsSection(rule, idx);
      ruleContent.appendChild(objectsSection);

      ruleElement.appendChild(moveButtons);
      ruleElement.appendChild(ruleContent);

      return ruleElement;
    }

    // Function to create group objects section
    function createGroupObjectsSection(rule, groupIdx) {
      const objectsSection = document.createElement('div');
      objectsSection.className = 'sidebar-objects-section';

      // Get objects for this group
      const groupObjects = objectsData.objects.filter(obj => obj.group === rule.label);

      // Objects toggle
      const objectsToggle = document.createElement('button');
      objectsToggle.className = 'sidebar-objects-toggle';
      objectsToggle.innerHTML = `<span class="toggle-icon">▶</span> Objects (${groupObjects.length})`;

      // Objects list
      const objectsList = document.createElement('div');
      objectsList.className = 'sidebar-objects-list';

      // Populate objects
      groupObjects.forEach((obj, objIdx) => {
        const objItem = document.createElement('div');
        objItem.className = 'sidebar-object-item';

        const objToggle = document.createElement('button');
        objToggle.className = `sidebar-object-toggle ${obj.enabled !== false ? 'active' : ''}`;
        objToggle.textContent = obj.enabled !== false ? '✓' : '✗';
        objToggle.addEventListener('click', (e) => {
          e.stopPropagation();
          obj.enabled = !(obj.enabled !== false);
          objToggle.textContent = obj.enabled ? '✓' : '✗';
          objToggle.classList.toggle('active', obj.enabled);
          applyRules();
          autoSavePatternHierarchy();
        });

        // Color preview boxes (clickable for color editing)
        const colorContainer = document.createElement('div');
        colorContainer.style.cssText = `
          display: flex;
          gap: 2px;
          margin-right: 4px;
        `;

        const colorBox1 = document.createElement('div');
        colorBox1.className = 'sidebar-object-color';
        colorBox1.style.cssText = `
          width: 10px;
          height: 12px;
          border: 1px solid #ccc;
          border-radius: 2px 0 0 2px;
          background-color: ${obj.color1 || '#f0f0f0'};
          cursor: pointer;
        `;
        colorBox1.addEventListener('click', (e) => {
          e.stopPropagation();
          // Find the global index of this object
          const globalObjIndex = objectsData.objects.findIndex(o =>
            o.match === obj.match && o.group === obj.group && o.label === obj.label
          );
          if (globalObjIndex !== -1) {
            showObjectColorPanel(globalObjIndex, 1);
          } else {
            console.error('Object not found in global array');
          }
        });

        const colorBox2 = document.createElement('div');
        colorBox2.className = 'sidebar-object-color';
        colorBox2.style.cssText = `
          width: 10px;
          height: 12px;
          border: 1px solid #ccc;
          border-radius: 0 2px 2px 0;
          background-color: ${obj.color2 || '#f0f0f0'};
          cursor: pointer;
        `;
        colorBox2.addEventListener('click', (e) => {
          e.stopPropagation();
          // Find the global index of this object
          const globalObjIndex = objectsData.objects.findIndex(o =>
            o.match === obj.match && o.group === obj.group && o.label === obj.label
          );
          if (globalObjIndex !== -1) {
            showObjectColorPanel(globalObjIndex, 2);
          } else {
            console.error('Object not found in global array');
          }
        });

        colorContainer.appendChild(colorBox1);
        colorContainer.appendChild(colorBox2);

        // Object name (clickable, styled like preview)
        const objName = document.createElement('div');
        objName.className = 'sidebar-object-name';
        const baseStyle = `
          flex: 1;
          font-size: 0.75rem;
          cursor: pointer;
          padding: 2px 4px;
          border-radius: 2px;
          display: inline-block;
        `;
        const previewStyle = getObjectStyleWithGroupStyles(obj);
        objName.style.cssText = baseStyle + previewStyle;
        objName.textContent = obj.label || obj.match || 'Unnamed Object';
        objName.addEventListener('click', (e) => {
          e.stopPropagation();
          // Always use fresh object reference from global array
          const globalObjIndex = objectsData.objects.findIndex(o =>
            o.match === obj.match && o.group === obj.group && o.label === obj.label
          );
          if (globalObjIndex !== -1) {
            const globalObj = objectsData.objects[globalObjIndex];
            openObjectEditor(globalObj.label || globalObj.match || '', globalObj);
          } else {
            console.error('Object not found in global array');
          }
        });

        // Regex match (inline editable)
        const regexSpan = document.createElement('span');
        regexSpan.className = 'sidebar-object-regex';
        regexSpan.style.cssText = `
          font-size: 0.7rem;
          color: #666;
          font-style: italic;
          cursor: pointer;
          margin-left: 4px;
        `;
        regexSpan.textContent = `/${obj.match || 'none'}/`;
        regexSpan.title = 'Click to edit regex';
        regexSpan.addEventListener('click', (e) => {
          e.stopPropagation();
          editObjectRegexInline(obj, regexSpan);
        });

        objItem.appendChild(objToggle);
        objItem.appendChild(colorContainer);
        objItem.appendChild(objName);
        objItem.appendChild(regexSpan);

        // Add symbol display if group has symbol style enabled
        const groupRule = dictionary.rules.find(r => r.label === rule.label);
        if (groupRule && (groupRule.style1 === 'symbol' || groupRule.style2 === 'symbol')) {
          // Use the same symbol logic as the WhatBoard
          const emoji = getGroupEmoji(rule.label);
          if (emoji) {
            const symbolSpan = document.createElement('span');
            symbolSpan.className = 'sidebar-object-symbol';
            symbolSpan.style.cssText = `
              font-size: 0.7rem;
              color: #007aff;
              margin-left: 4px;
              font-weight: bold;
            `;
            symbolSpan.textContent = emoji;
            objItem.appendChild(symbolSpan);
          }
        }

        objectsList.appendChild(objItem);
      });

      // Add object button with expandable options
      const addObjectContainer = document.createElement('div');
      addObjectContainer.className = 'sidebar-add-object-container';
      addObjectContainer.style.cssText = `
        position: relative;
        cursor: pointer;
      `;

      // Simplified single-mode add object button
      const addObjectBtn = document.createElement('div');
      addObjectBtn.className = 'sidebar-object-item sidebar-add-object-btn';
      addObjectBtn.style.cssText = `
        padding: 0.25rem 0.5rem;
        cursor: pointer;
        border-radius: 2px;
        font-size: 0.75rem;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        transition: all 0.2s ease;
        color: #333;
        display: flex;
        align-items: center;
        gap: 0.25rem;
      `;
      addObjectBtn.innerHTML = '<span style="width: 16px; text-align: center;">+</span><span>Add Object</span>';

      // Direct click to add object to this group
      addObjectBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        createNewObjectForGroup(rule.label);
      });

      // Simple hover effect
      addObjectBtn.addEventListener('mouseenter', () => {
        addObjectBtn.style.background = '#007aff';
        addObjectBtn.style.color = 'white';
      });

      addObjectBtn.addEventListener('mouseleave', () => {
        addObjectBtn.style.background = '#f8f9fa';
        addObjectBtn.style.color = '#333';
      });

      objectsList.appendChild(addObjectBtn);



      // Default click for normal add
      addObjectBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        createNewObjectForGroup(rule.label);
      });



      addObjectContainer.appendChild(addObjectBtn);

      objectsList.appendChild(addObjectContainer);

      // Toggle functionality
      const groupKey = rule.label;
      let isObjectsExpanded = expandedObjectLists.has(groupKey);

      // Set initial state
      objectsList.classList.toggle('expanded', isObjectsExpanded);
      objectsToggle.querySelector('.toggle-icon').textContent = isObjectsExpanded ? '▼' : '▶';

      objectsToggle.addEventListener('click', () => {
        isObjectsExpanded = !isObjectsExpanded;
        objectsList.classList.toggle('expanded', isObjectsExpanded);
        objectsToggle.querySelector('.toggle-icon').textContent = isObjectsExpanded ? '▼' : '▶';

        // Track expanded state
        if (isObjectsExpanded) {
          expandedObjectLists.add(groupKey);
        } else {
          expandedObjectLists.delete(groupKey);
        }
      });

      objectsSection.appendChild(objectsToggle);
      objectsSection.appendChild(objectsList);

      return objectsSection;
    }

    function refreshObjectsUI() {
      const container = document.getElementById('objectsContainer');
      if (!container) {
        // Container was removed from main UI, but function is still called for sidebar
        return;
      }
      container.innerHTML = '';

      // Group objects by their group
      const groupedObjects = {};
      objectsData.objects.forEach(obj => {
        if (!groupedObjects[obj.group]) {
          groupedObjects[obj.group] = [];
        }
        groupedObjects[obj.group].push(obj);
      });

      // Create sections for each group
      Object.keys(groupedObjects).forEach(groupName => {
        // Create group header
        const groupHeader = document.createElement('div');
        groupHeader.style.cssText = `
          margin-top: 1rem;
          margin-bottom: 0.5rem;
          padding: 0.5rem;
          background: #f8f9fa;
          border: 1px solid #dee2e6;
          border-radius: 4px;
          font-weight: 600;
          color: #495057;
        `;
        groupHeader.textContent = groupName;
        container.appendChild(groupHeader);

        // Add objects for this group
        groupedObjects[groupName].forEach((obj, idx) => {
          const tpl = document.getElementById('objectTemplate');
          const node = tpl.content.cloneNode(true);
          const row = node.querySelector('.rule-row');
          row.dataset.idx = objectsData.objects.indexOf(obj);

          // Set values
          row.querySelector('.match').value = obj.match || '';
          row.querySelector('.label').value = obj.label || '';

          // Set toggle state
          const objectToggleBtn = row.querySelector('.object-toggle');
          if (objectToggleBtn) {
            const isEnabled = obj.enabled !== false; // Default to true if not specified
            objectToggleBtn.textContent = isEnabled ? '✓' : '✗';
            objectToggleBtn.style.background = isEnabled ? '#28a745' : '#dc3545';
            objectToggleBtn.title = isEnabled ? 'Object enabled' : 'Object disabled';
          }

          // Set color displays
          const color1Display = row.querySelector('.color1-display');
          const color2Display = row.querySelector('.color2-display');
          const color1Btn = row.querySelector('.color1-btn');
          const color2Btn = row.querySelector('.color2-btn');

          if (obj.color1) {
            color1Display.textContent = obj.color1;
            applyStyleToButton(color1Btn, obj.color1, 'background');
          } else {
            color1Display.textContent = 'magenta';
            color1Btn.style.backgroundColor = '';
            color1Btn.style.color = '';
            color1Btn.style.border = '';
            color1Btn.style.textDecoration = '';
          }

          if (obj.color2) {
            color2Display.textContent = obj.color2;
            applyStyleToButton(color2Btn, obj.color2, 'background');
          } else {
            color2Display.textContent = '-';
            color2Btn.style.backgroundColor = '';
            color2Btn.style.color = '';
            color2Btn.style.border = '';
            color2Btn.style.textDecoration = '';
          }

          // Add event listeners
          row.querySelector('.removeObject').addEventListener('click', () => {
            const objIndex = objectsData.objects.indexOf(obj);
            objectsData.objects.splice(objIndex, 1);
            refreshObjectsUI();
            applyRules();
            autoSavePatternHierarchy();
          });

          // Toggle button event listener
          const objToggleBtn = row.querySelector('.object-toggle');
          if (objToggleBtn) {
            objToggleBtn.addEventListener('click', () => {
              const isEnabled = obj.enabled !== false;
              obj.enabled = !isEnabled;
              objToggleBtn.textContent = !isEnabled ? '✓' : '✗';
              objToggleBtn.style.background = !isEnabled ? '#28a745' : '#dc3545';
              objToggleBtn.title = !isEnabled ? 'Object enabled' : 'Object disabled';
              applyRules();
              autoSavePatternHierarchy();
            });
          }

          // Live change listeners
          row.querySelector('.match').addEventListener('input', () => {
            obj.match = row.querySelector('.match').value;
            autoSavePatternHierarchy();
          });

          row.querySelector('.label').addEventListener('input', () => {
            obj.label = row.querySelector('.label').value;
            autoSavePatternHierarchy();
          });

          // Color button click handlers
          color1Btn.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Object color1 button clicked for:', obj.label);
            showObjectColorPanel(obj, objectsData.objects.indexOf(obj), 1, color1Btn);
          });

          color2Btn.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Object color2 button clicked for:', obj.label);
            showObjectColorPanel(obj, objectsData.objects.indexOf(obj), 2, color2Btn);
          });

          container.appendChild(node);
        });
      });
    }

    function prettifyJson(json) {
      const jsonString = JSON.stringify(json, null, 2);

      // Split into lines to preserve formatting
      const lines = jsonString.split('\n');
      const formattedLines = lines.map(line => {
        // Apply syntax highlighting to each line
        return line
          .replace(/"([^"]+)":/g, '<span class="json-key">"$1"</span><span class="json-punctuation">:</span>')
          .replace(/"([^"]*)"/g, '<span class="json-string">"$1"</span>')
          .replace(/\b(true|false)\b/g, '<span class="json-boolean">$1</span>')
          .replace(/\b(null)\b/g, '<span class="json-null">$1</span>')
          .replace(/\b(\d+\.?\d*)\b/g, '<span class="json-number">$1</span>')
          .replace(/([{}[\],])/g, '<span class="json-punctuation">$1</span>');
      });

      // Join lines back together, preserving line breaks
      return formattedLines.join('\n');
    }



    let applyRulesTimeout;
    let debugMode = false; // Default to false

    // Semantic structure parsing functions
    function parseSemanticStructures(text) {
      const structures = [];

      // Get semantic structure patterns from the JSON
      if (debugMode) console.log('Searching for semantic structures in:', listsData.keyValueLists);
      if (debugMode) {
        listsData.keyValueLists.forEach((list, index) => {
          console.log(`List ${index}:`, list.name, list);
        });
      }
      const semanticPatterns = listsData.keyValueLists.find(list =>
        list.name === "semantic structures" ||
        list.name === "semantic structures " ||
        list.name === " semantic structures" ||
        list.name.toLowerCase() === "semantic structures"
      );
      if (!semanticPatterns) {
        if (debugMode) console.log('No semantic structures found in listsData.keyValueLists:', listsData.keyValueLists);
        return structures;
      }
      if (debugMode) console.log('Found semantic patterns:', semanticPatterns);

      // Convert JSON patterns to the format we need
      const patterns = semanticPatterns.items.map(item => {
        const syntax = item.syntax;
        const relationship = item.relationship;

        // Parse the syntax to extract delimiters
        // Example: "⟢fragment⦓very brief supplementary summary⦔⟣"
        // Extract outer delimiters based on relationship
        let startDelimiter, endDelimiter;
        switch (relationship) {
          case 'supplementary':
            startDelimiter = '⟢';
            endDelimiter = '⟣';
            break;
          case 'linear progression':
            startDelimiter = '⨴';
            endDelimiter = '⨵';
            break;
          case 'parallel set':
            startDelimiter = '⨭';
            endDelimiter = '⨮';
            break;
          case 'mapping':
            startDelimiter = '⊏';
            endDelimiter = '⊐';
            break;
          case 'combination':
            startDelimiter = '⦕';
            endDelimiter = '⦖';
            break;
          default:
            startDelimiter = '⟢';
            endDelimiter = '⟣';
        }

        // Inner delimiters are consistent across all types
        const innerStartDelimiter = '⦓';
        const innerEndDelimiter = '⦔';

        return {
          relationship,
          startDelimiter,
          endDelimiter,
          innerStartDelimiter,
          innerEndDelimiter
        };
      });

      if (debugMode) console.log('Converted patterns:', patterns);

      for (const pattern of patterns) {
        const { startDelimiter, endDelimiter, innerStartDelimiter, innerEndDelimiter, relationship } = pattern;

        // Create regex pattern to match the semantic structure
        // Escape special regex characters in delimiters
        const escapedStartDelimiter = startDelimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const escapedEndDelimiter = endDelimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const escapedInnerStartDelimiter = innerStartDelimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const escapedInnerEndDelimiter = innerEndDelimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

        // Use a pattern that handles optional content between inner and outer delimiters
        const regexPattern = `${escapedStartDelimiter}(.*?)${escapedInnerStartDelimiter}(.*?)${escapedInnerEndDelimiter}(.*?)${escapedEndDelimiter}`;

        if (debugMode) console.log(`Testing regex pattern for ${relationship}:`, regexPattern);

        try {
          const regex = new RegExp(regexPattern, 'g');
          let match;

          if (debugMode) console.log(`Testing pattern for ${relationship}:`, regexPattern);

          while ((match = regex.exec(text)) !== null) {
            const fullMatch = match[0];
            const fragment = match[1];
            const summary = match[2];
            const trailingContent = match[3] || ''; // Content between inner end and outer end delimiters

            if (debugMode) console.log(`Found ${relationship} structure:`, { fullMatch, fragment, summary, trailingContent });

            structures.push({
              fullMatch,
              fragment,
              summary,
              relationship,
              startIndex: match.index,
              endIndex: match.index + fullMatch.length,
              syntax: `${startDelimiter}fragment${innerStartDelimiter}summary${innerEndDelimiter}${endDelimiter}`
            });
          }
        } catch (e) {
          console.warn('Invalid semantic structure regex:', regexPattern, e);
        }
      }

      return structures;
    }

    function findSemanticStructureMatch(token, tokenStart, tokenEnd, semanticStructures) {
      for (const structure of semanticStructures) {
        // Check if this token is part of the semantic structure
        if (tokenStart >= structure.startIndex && tokenEnd <= structure.endIndex) {
          // Parse the structure to extract components
          const components = parseSemanticStructureComponents(structure);

          return {
            color1: '',
            color2: '',
            style1: 'semantic',
            style2: '',
            label: components.label,
            summary: components.summary,
            sourceText: components.sourceText,
            relationship: structure.relationship,
            group: 'semantic-structure',
            isSemantic: true
          };
        }
      }
      return null;
    }

    function parseSemanticStructureComponents(structure) {
      const { fullMatch, fragment, summary, relationship } = structure;

      // Extract label if present (before the first colon)
      let label = '';
      let sourceText = fragment;

      const colonIndex = fragment.indexOf(':');
      if (colonIndex !== -1) {
        label = fragment.substring(0, colonIndex).trim();
        sourceText = fragment.substring(colonIndex + 1).trim();
      }

      return {
        label,
        summary,
        sourceText,
        relationship
      };
    }

    function applyRules() {
      // Clear any pending timeout to debounce rapid calls
      if (applyRulesTimeout) {
        clearTimeout(applyRulesTimeout);
      }

      // Set a new timeout to execute after a short delay
      applyRulesTimeout = setTimeout(() => {
        applyRulesInternal();
      }, 10);
    }

    function applyRulesInternal() {
      const text = document.getElementById('sourceText').value || '';
      const words = text.split(/(\s+)/); // keep spaces
      const preview = document.getElementById('preview');
      preview.innerHTML = '';
      const elements = [];

      // Get default pattern settings
      const defaultEnabled = document.getElementById('defaultPatternEnabled').checked;
      const defaultPattern = buildPatternFromJSON();
      const defaultLabel = defaultPattern.label;

      // Parse semantic structures first
      if (debugMode) console.log('listsData available:', listsData);
      if (debugMode) console.log('listsData.keyValueLists:', listsData.keyValueLists);
      if (debugMode) console.log('listsData.keyValueLists.length:', listsData.keyValueLists.length);
      const semanticStructures = parseSemanticStructures(text);
      if (debugMode) console.log('Found semantic structures:', semanticStructures);

      // Find all matches for multi-word patterns first
      const multiWordMatches = new Set();

      // Check dictionary rules for multi-word patterns
      for (const rule of dictionary.rules) {
        if (rule.match && rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              // Store the start and end positions of the match
              multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Check default pattern for multi-word patterns
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            // Store the start and end positions of the match
            multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      // Process semantic structures first
      let processedText = text;
      if (debugMode) {
        console.log('Processing semantic structures:', semanticStructures.length);
        console.log('Original text:', text);
      }

      // Sort structures by start index in descending order to avoid index conflicts
      const sortedStructures = [...semanticStructures].sort((a, b) => b.startIndex - a.startIndex);

      // Build processed text by replacing structures with placeholders
      let lastIndex = text.length;
      const replacements = [];

      for (const structure of sortedStructures) {
        const components = parseSemanticStructureComponents(structure);

        if (debugMode) console.log('Parsed components:', components);

        // Create a semantic object representation
        const semanticObject = {
          color1: '',
          color2: '',
          style1: 'semantic',
          style2: '',
          label: components.label, // Keep label data but don't display by default
          summary: components.summary,
          sourceText: components.sourceText,
          relationship: structure.relationship,
          group: 'semantic-structure',
          isSemantic: true,
          isPromoted: false, // Only show labels when promoted to JSON Object
          fullMatch: structure.fullMatch
        };

        // Create placeholder
        const placeholder = `__SEMANTIC_${structure.startIndex}__`;

        if (debugMode) {
          console.log('Replacing structure at index', structure.startIndex, ':', structure.fullMatch);
          console.log('With placeholder:', placeholder);
        }

        // Store replacement info
        replacements.push({
          start: structure.startIndex,
          end: structure.endIndex,
          fullMatch: structure.fullMatch,
          placeholder: placeholder
        });

        if (debugMode) console.log('Created semantic object:', semanticObject);

        // Store the semantic object for later use
        if (!window.semanticObjects) window.semanticObjects = {};
        window.semanticObjects[placeholder] = semanticObject;
      }

      // Apply replacements in reverse order to maintain indices
      replacements.sort((a, b) => b.start - a.start);

      for (const replacement of replacements) {
        const before = processedText.substring(0, replacement.start);
        const after = processedText.substring(replacement.end);
        processedText = before + replacement.placeholder + after;

        if (debugMode) {
          console.log('Applied replacement:', replacement.fullMatch, '->', replacement.placeholder);
        }
      }

      // Now process the modified text
      if (debugMode) console.log('Processed text after semantic replacement:', processedText);
      const processedWords = processedText.split(/(\s+)/);

      processedWords.forEach((token, index) => {
        let cleaned = token;
        if (token.trim() === '') {
          preview.append(document.createTextNode(token));
          return;
        }
        let matched = null;

        // Check if this is a semantic placeholder
        if (token.startsWith('__SEMANTIC_') && token.endsWith('__')) {
          if (debugMode) console.log('Found semantic placeholder:', token);
          matched = window.semanticObjects[token];
          if (debugMode) console.log('Retrieved semantic object:', matched);

          // If no semantic object found, this might be an orphaned placeholder
          if (!matched) {
            if (debugMode) console.warn('Orphaned semantic placeholder found:', token);
            // Create a fallback span with the placeholder text
            const fallbackSpan = document.createElement('span');
            fallbackSpan.textContent = token;
            fallbackSpan.style.color = 'red';
            fallbackSpan.style.fontStyle = 'italic';
            preview.appendChild(fallbackSpan);
            return;
          }
        } else {
          if (debugMode && token.trim() !== '') {
            console.log('Processing regular token:', token);
          }
          // Calculate the position of this token in the original text
          const tokenStart = processedWords.slice(0, index).join('').length;
          const tokenEnd = tokenStart + token.length;
          const tokenRange = `${tokenStart}-${tokenEnd}`;

          // Check if this token is part of a multi-word match
          let isPartOfMultiWordMatch = false;
          for (const matchRange of multiWordMatches) {
            const [matchStart, matchEnd] = matchRange.split('-').map(Number);
            // Check if this token overlaps with the match
            if (tokenStart < matchEnd && tokenEnd > matchStart) {
              isPartOfMultiWordMatch = true;
              break;
            }
          }

          // Check objects for all enabled groups
          for (const rule of dictionary.rules) {
            // Skip disabled rules
            if (rule.enabled === false) {
              continue;
            }

            // Check objects for this group
            for (const obj of objectsData.objects) {
              // Skip disabled objects
              if (obj.enabled === false) {
                continue;
              }

              // Check if object belongs to this group
              if (obj.group === rule.label) {
                try {
                  const flags = 'i';
                  let regex = new RegExp(obj.match, flags);

                  if (obj.match.includes(' ')) {
                    // For multi-word patterns, check if this token is part of a match
                    if (isPartOfMultiWordMatch) {
                      matched = {
                        color1: obj.color1,
                        color2: obj.color2,
                        style1: rule.style1,
                        style2: rule.style2,
                        label: obj.label || obj.group,
                        group: obj.group
                      };
                      break;
                    }
                  } else {
                    // For single-word patterns, test against the current token
                    if (regex.test(token)) {
                      if (debugMode) console.log('Creating matched object for:', obj.label, 'Group:', obj.group);
                      matched = {
                        color1: obj.color1,
                        color2: obj.color2,
                        style1: rule.style1,
                        style2: rule.style2,
                        label: obj.label || obj.group,
                        group: obj.group
                      };
                      if (debugMode) console.log('Created matched object:', matched);
                      break;
                    }
                  }
                } catch (e) {
                  // invalid regex; skip
                  console.warn('bad object regex', obj.match);
                }
              }
              if (matched) break;
            }
            if (matched) break;
          }

          // If no match found and default pattern is enabled, try default pattern
          if (!matched && defaultEnabled && defaultPattern) {
            try {
              const flags = 'i';
              let regex = new RegExp(defaultPattern.pattern, flags);

              // Check if pattern contains spaces (multi-word pattern)
              if (defaultPattern.pattern.includes(' ')) {
                // For multi-word patterns, check if this token is part of a match
                if (isPartOfMultiWordMatch) {
                  matched = {
                    color1: defaultPattern.color1,
                    color2: defaultPattern.color2,
                    style1: defaultPattern.style1,
                    style2: defaultPattern.style2,
                    label: defaultPattern.label
                  };
                }
              } else {
                // For single-word patterns, test against the current token
                if (regex.test(token)) {
                  matched = {
                    color1: defaultPattern.color1,
                    color2: defaultPattern.color2,
                    style1: defaultPattern.style1,
                    style2: defaultPattern.style2,
                    label: defaultPattern.label
                  };
                }
              }
            } catch (e) {
              // invalid regex; skip
              console.warn('bad default regex', defaultPattern.pattern);
            }
          }
        }

        const span = document.createElement('span');
        span.textContent = token;
        span.className = 'word';

        if (matched && matched.isSemantic) {
          // For semantic structures, create a container and break down into components
          const container = document.createElement('span');
          container.className = 'semantic-container';
          container.style.display = 'inline';
          container.style.cursor = 'pointer';
          container.title = `Semantic structure: ${matched.relationship}`;

          // Add subtle visual indicator
          container.style.borderBottom = '1px dotted #ccc';

          // Create components
          const components = [];

          // Add label if it exists and is promoted
          if (matched.label && matched.isPromoted) {
            const labelSpan = document.createElement('span');
            labelSpan.textContent = matched.label + ': ';
            labelSpan.style.fontWeight = 'bold';
            components.push(labelSpan);
          }

          // Process source text word by word to apply object styles
          const sourceWords = matched.sourceText.split(/(\s+)/);
          sourceWords.forEach(word => {
            if (word.trim() === '') {
              // Add whitespace as text node
              components.push(document.createTextNode(word));
              return;
            }

            const wordSpan = document.createElement('span');
            wordSpan.textContent = word;
            wordSpan.className = 'word';

            // Check if this word matches any object rules
            let wordMatched = null;

            // Check objects for all enabled groups
            for (const rule of dictionary.rules) {
              if (rule.enabled === false) continue;

              for (const obj of objectsData.objects) {
                if (obj.enabled === false) continue;
                if (obj.group === rule.label) {
                  try {
                    const flags = 'i';
                    let regex = new RegExp(obj.match, flags);

                    if (regex.test(word)) {
                      wordMatched = {
                        color1: obj.color1,
                        color2: obj.color2,
                        style1: rule.style1,
                        style2: rule.style2,
                        label: obj.label || obj.group,
                        group: obj.group
                      };
                      break;
                    }
                  } catch (e) {
                    console.warn('bad object regex', obj.match);
                  }
                }
                if (wordMatched) break;
              }
              if (wordMatched) break;
            }

            // Apply object styles to the word
            if (wordMatched) {
              // Store the matched object on the element
              wordSpan.matchedObject = wordMatched;
              wordSpan.title = wordMatched.group || '';

              // Add click event listener for object editing
              wordSpan.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation(); // Prevent triggering the semantic container click
                openObjectEditor(word, wordMatched);
              });

              // Apply styles using the same logic as the sidebar
              const combinedObj = {
                color1: wordMatched.color1 || '',
                color2: wordMatched.color2 || '',
                style1: wordMatched.style1 || '',
                style2: wordMatched.style2 || ''
              };
              const previewStyle = getObjectPreviewStyle(combinedObj);
              wordSpan.style.cssText += previewStyle;
            } else {
              // Even if no object matches, make the word clickable for creating new objects
              wordSpan.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation(); // Prevent triggering the semantic container click
                // Create a basic matched object for the semantic context
                const semanticMatched = {
                  color1: '',
                  color2: '',
                  style1: '',
                  style2: '',
                  label: word,
                  group: matched.group || 'semantic-structure',
                  isSemantic: true
                };
                openObjectEditor(word, semanticMatched);
              });
            }

            components.push(wordSpan);
          });

          // Add summary (italic styling)
          if (matched.summary) {
            const summarySpan = document.createElement('span');
            summarySpan.textContent = ' ' + matched.summary;
            summarySpan.style.fontStyle = 'italic';
            summarySpan.style.color = '#666';
            components.push(summarySpan);
          }

          // Add all components to container
          components.forEach(comp => container.appendChild(comp));

          // Add click event listener to the semantic container for future semantic-to-object conversion
          container.addEventListener('click', function (e) {
            // Only trigger if the click wasn't on a word (which has its own handler)
            if (e.target === container) {
              e.preventDefault();
              // TODO: Future feature - convert semantic structure to object
              console.log('Semantic container clicked:', matched);
            }
          });

          // Replace the original span with the container
          preview.appendChild(container);
          return; // Skip the rest of the processing
        }

        if (matched) {
          // Store the matched object on the element for semantic styling
          span.matchedObject = matched;

          // Set the title first so symbol style can access the group name
          if (debugMode) console.log('Setting span.title to:', matched.group || '');
          span.title = matched.group || '';

          // Add click event listener for object editing
          span.addEventListener('click', function (e) {
            e.preventDefault();
            openObjectEditor(token, matched);
          });

          // Apply styles using the same logic as the sidebar
          const combinedObj = {
            color1: matched.color1 || '',
            color2: matched.color2 || '',
            style1: matched.style1 || '',
            style2: matched.style2 || ''
          };
          const previewStyle = getObjectPreviewStyle(combinedObj);
          span.style.cssText += previewStyle;
        } else {
          span.style.color = 'inherit';
        }
        preview.appendChild(span);
      });

      // Update current matches display
      const matchesDisplay = document.getElementById('currentMatches');
      if (matchesDisplay) {
        const matches = findCurrentMatches();
        matchesDisplay.textContent = matches.length > 0 ? matches.join(', ') : 'No matches found';
      }
    }

    function downloadMarkdown() {
      const text = document.getElementById('sourceText').value || '';
      // Build markdown with inline color hints using HTML spans
      const previewDiv = document.getElementById('preview');
      let md = '';
      // Iterate over children to preserve spaces
      previewDiv.childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          md += node.textContent;
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const span = node;
          const word = span.textContent;
          const bg = span.style.background;
          const label = span.title;
          if (bg || label) {
            // use inline HTML for color
            md += `<span style="background:${bg}">${word}</span>`;
          } else {
            md += word;
          }
        }
      });
      const blob = new Blob([md], { type: 'text/markdown' });
      const name = document.getElementById('mdName').value || 'export.md';
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.click();
    }

    async function downloadPDF() {
      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        alert('jsPDF not loaded');
        return;
      }
      const pdf = new jsPDF();
      const preview = document.getElementById('preview');
      // Simplest: convert text content with minimal styling
      const lines = [];
      preview.childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          lines.push(node.textContent);
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          let word = node.textContent;
          // add markers for colored
          if (node.style.background) {
            word = `[${word}]`;
          }
          lines.push(word);
        }
      });
      const full = lines.join('');
      // split to fit
      const pageWidth = pdf.internal.pageSize.getWidth();
      const margin = 10;
      const usableWidth = pageWidth - margin * 2;
      const split = pdf.splitTextToSize(full, usableWidth);
      pdf.text(split, margin, 20);
      const name = document.getElementById('pdfName').value || 'export.pdf';
      pdf.save(name);
    }

    function copyStyledHTML() {
      const preview = document.getElementById('preview');
      navigator.clipboard.write([
        new ClipboardItem({
          'text/html': new Blob([preview.innerHTML], { type: 'text/html' }),
          'text/plain': new Blob([preview.textContent], { type: 'text/plain' })
        })
      ]).then(() => alert('Copied styled HTML to clipboard'));
    }

    function copyPlainText() {
      const preview = document.getElementById('preview');
      navigator.clipboard.writeText(preview.textContent).then(() => alert('Copied plain text'));
    }

    async function loadSampleMd() {
      try {
        const response = await fetch('sample.md');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const content = await response.text();
        document.getElementById('sourceText').value = content;
        applyRules();
      } catch (error) {
        console.error('Error loading sample.md:', error);
        alert('Error loading sample.md. Make sure the file exists in the same directory as this HTML file.');
      }
    }

    function refreshPreview() {
      applyRules();
    }

    function buildPatternFromJSON() {
      let pattern = '';

      // Add start anchor if present
      if (defaultPattern.structure.startAnchor) {
        pattern += '^';
      }

      // Add start word boundary if present
      if (defaultPattern.structure.startWordBoundary) {
        pattern += '\\b';
      }

      // Add custom prepend toggles
      defaultPattern.structure.customPrependToggles.forEach(toggle => {
        if (toggle.active) {
          pattern += toggle.regex;
        }
      });

      // Add base pattern
      pattern += defaultPattern.structure.basePattern;

      // Add custom append toggles
      defaultPattern.structure.customAppendToggles.forEach(toggle => {
        if (toggle.active) {
          pattern += toggle.regex;
        }
      });

      // Add end word boundary if present
      if (defaultPattern.structure.endWordBoundary) {
        pattern += '\\b';
      }

      // Add end anchor if present
      if (defaultPattern.structure.endAnchor) {
        pattern += '$';
      }

      return {
        pattern: pattern,
        color1: defaultPattern.color1,
        color2: defaultPattern.color2,
        style1: defaultPattern.style1,
        style2: defaultPattern.style2,
        label: defaultPattern.label
      };
    }

    function updatePatternUI() {
      // Update input fields
      updateDefaultColorButtons();
      document.getElementById('basePatternInput').value = defaultPattern.structure.basePattern;

      // Update wrapper button states
      const startAnchorBtn = document.querySelector('[data-wrapper="start-anchor"]');
      const wordBoundaryBtn = document.querySelector('[data-wrapper="word-boundary"]');
      const endAnchorBtn = document.querySelector('[data-wrapper="end-anchor"]');

      if (startAnchorBtn) {
        startAnchorBtn.dataset.active = defaultPattern.structure.startAnchor;
        startAnchorBtn.style.background = defaultPattern.structure.startAnchor ? '#28a745' : '#555';
      }

      if (wordBoundaryBtn) {
        wordBoundaryBtn.dataset.active = defaultPattern.structure.endWordBoundary;
        wordBoundaryBtn.style.background = defaultPattern.structure.endWordBoundary ? '#28a745' : '#555';
      }

      if (endAnchorBtn) {
        endAnchorBtn.dataset.active = defaultPattern.structure.endAnchor;
        endAnchorBtn.style.background = defaultPattern.structure.endAnchor ? '#28a745' : '#555';
      }

      // Update constructed pattern display
      const pattern = buildPatternFromJSON();
      const display = document.getElementById('constructedPattern');
      if (display) {
        display.textContent = pattern.pattern || '(empty)';
      }

      // Update current matches display
      const matchesDisplay = document.getElementById('currentMatches');
      if (matchesDisplay) {
        const matches = findCurrentMatches();
        matchesDisplay.textContent = matches.length > 0 ? matches.join(', ') : 'No matches found';
      }



      // Update custom toggles display
      updateCustomTogglesDisplay();
    }

    function updateCustomTogglesDisplay() {
      // Update prepend toggles
      const prependContainer = document.getElementById('prependTogglesContainer');
      if (prependContainer) {
        prependContainer.innerHTML = '';
        defaultPattern.structure.customPrependToggles.forEach(toggle => {
          const toggleElement = createToggleElement(toggle, true);
          prependContainer.appendChild(toggleElement);
        });
      }

      // Update append toggles
      const appendContainer = document.getElementById('appendTogglesContainer');
      if (appendContainer) {
        appendContainer.innerHTML = '';
        defaultPattern.structure.customAppendToggles.forEach(toggle => {
          const toggleElement = createToggleElement(toggle, false);
          appendContainer.appendChild(toggleElement);
        });
      }
    }

    function createToggleElement(toggle, isPrepend) {
      const container = document.createElement('div');
      container.className = 'custom-toggle-container';

      // Main toggle button (label only)
      const toggleButton = document.createElement('button');
      toggleButton.className = `toggle-button ${toggle.active ? 'active' : 'inactive'}`;
      toggleButton.title = `Regex: ${toggle.regex}`;
      toggleButton.textContent = toggle.label;

      // Toggle functionality
      toggleButton.addEventListener('click', () => {
        toggleCustomToggle(toggle.id, isPrepend);
      });

      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'toggle-delete';
      deleteBtn.textContent = '✕';
      deleteBtn.title = 'Delete toggle';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent triggering the toggle button
        deleteCustomToggle(toggle.id, isPrepend);
      });

      container.appendChild(toggleButton);
      container.appendChild(deleteBtn);

      return container;
    }

    function updatePatternWithAnchors(anchorType, addAnchor) {
      if (anchorType === 'start') {
        defaultPattern.structure.startAnchor = addAnchor;
      } else if (anchorType === 'end') {
        defaultPattern.structure.endAnchor = addAnchor;
      }
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function updatePatternWithWordBoundaries(addBoundaries) {
      defaultPattern.structure.startWordBoundary = addBoundaries;
      defaultPattern.structure.endWordBoundary = addBoundaries;
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function updatePatternWithRegexToggle(regex, isPrepend, addRegex, label = 'Custom Toggle') {
      if (addRegex) {
        const toggleInfo = {
          id: Date.now().toString(),
          label: label,
          regex: regex,
          position: isPrepend ? 'prepend' : 'append',
          active: true
        };

        if (isPrepend) {
          defaultPattern.structure.customPrependToggles.push(toggleInfo);
        } else {
          defaultPattern.structure.customAppendToggles.push(toggleInfo);
        }
      } else {
        // Remove the regex from the appropriate array
        if (isPrepend) {
          defaultPattern.structure.customPrependToggles = defaultPattern.structure.customPrependToggles.filter(t => t.regex !== regex);
        } else {
          defaultPattern.structure.customAppendToggles = defaultPattern.structure.customAppendToggles.filter(t => t.regex !== regex);
        }
      }
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function toggleCustomToggle(toggleId, isPrepend) {
      const toggles = isPrepend ? defaultPattern.structure.customPrependToggles : defaultPattern.structure.customAppendToggles;
      const toggle = toggles.find(t => t.id === toggleId);
      if (toggle) {
        toggle.active = !toggle.active;
        updatePatternUI();
        applyRules();
        autoSavePatternHierarchy();
      }
    }

    function deleteCustomToggle(toggleId, isPrepend) {
      if (isPrepend) {
        defaultPattern.structure.customPrependToggles = defaultPattern.structure.customPrependToggles.filter(t => t.id !== toggleId);
      } else {
        defaultPattern.structure.customAppendToggles = defaultPattern.structure.customAppendToggles.filter(t => t.id !== toggleId);
      }
      updatePatternUI();
      applyRules();
      autoSavePatternHierarchy();
    }

    function findCurrentMatches() {
      const text = document.getElementById('sourceText').value || '';
      const matches = [];

      // Get default pattern settings
      const defaultEnabled = document.getElementById('defaultPatternEnabled').checked;
      const defaultPattern = buildPatternFromJSON();

      // Split text the same way as applyRules() does
      const tokens = text.split(/(\s+)/); // keep spaces

      // Find all matches for multi-word patterns first
      const multiWordMatches = new Set();

      // Check dictionary rules for multi-word patterns
      for (const rule of dictionary.rules) {
        if (rule.match && rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              // Store the start and end positions of the match
              multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Check default pattern for multi-word patterns
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            // Store the start and end positions of the match
            multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      // For multi-word patterns, we need to extract the actual matched phrases
      const matchedPhrases = new Set();

      // Extract matched phrases from dictionary rules
      for (const rule of dictionary.rules) {
        if (rule.match && rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              matchedPhrases.add(match[0]);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Extract matched phrases from default pattern
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            matchedPhrases.add(match[0]);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      // Add multi-word matched phrases
      matchedPhrases.forEach(phrase => {
        matches.push(phrase);
      });

      // Process individual tokens for single-word patterns
      tokens.forEach((token, index) => {
        if (token.trim() === '') {
          return; // Skip empty tokens
        }

        let matched = false;

        // Calculate the position of this token in the original text
        const tokenStart = tokens.slice(0, index).join('').length;
        const tokenEnd = tokenStart + token.length;

        // Check if this token is part of a multi-word match
        let isPartOfMultiWordMatch = false;
        for (const matchRange of multiWordMatches) {
          const [matchStart, matchEnd] = matchRange.split('-').map(Number);
          // Check if this token overlaps with the match
          if (tokenStart < matchEnd && tokenEnd > matchStart) {
            isPartOfMultiWordMatch = true;
            break;
          }
        }

        // Skip tokens that are part of multi-word matches (we already added the full phrases)
        if (isPartOfMultiWordMatch) {
          return;
        }

        // First check dictionary rules
        for (const rule of dictionary.rules) {
          try {
            const flags = 'i';
            let regex = new RegExp(rule.match, flags);

            // Only check single-word patterns here
            if (rule.match && !rule.match.includes(' ')) {
              const match = token.match(regex);
              if (match) {
                matches.push(match[0]);
                matched = true;
                break;
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad regex', rule.match);
          }
        }

        // If no match found and default pattern is enabled, try default pattern
        if (!matched && defaultEnabled && defaultPattern) {
          try {
            const flags = 'i';
            let regex = new RegExp(defaultPattern.pattern, flags);

            // Only check single-word patterns here
            if (!defaultPattern.pattern.includes(' ')) {
              const match = token.match(regex);
              if (match) {
                matches.push(match[0]);
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad default regex', defaultPattern.pattern);
          }
        }
      });

      // Remove duplicates and return
      return [...new Set(matches)];
    }

    function getGroupEmoji(groupName) {
      if (debugMode) console.log('getGroupEmoji called with:', groupName);
      if (!groupName) {
        if (debugMode) console.log('No groupName provided');
        return null;
      }

      // Get category emojis from listsData
      if (listsData && listsData.keyValueLists) {
        const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
        if (debugMode) console.log('categoriesList found:', !!categoriesList);
        if (categoriesList && categoriesList.items) {
          if (debugMode) console.log('categoriesList.items:', categoriesList.items);
          const category = categoriesList.items.find(item => item.key === groupName);
          if (debugMode) console.log('category found for', groupName, ':', category);
          if (category) {
            if (debugMode) console.log('Returning emoji:', category.value);
            return category.value;
          }
        }
      }
      if (debugMode) console.log('No emoji found for group:', groupName);
      return null;
    }

    function getContrastColor(color) {
      // Handle hex colors
      if (color.startsWith('#')) {
        const hex = color.replace('#', '');
        if (hex.length === 6) {
          // Convert to RGB
          const r = parseInt(hex.substr(0, 2), 16);
          const g = parseInt(hex.substr(2, 2), 16);
          const b = parseInt(hex.substr(4, 2), 16);

          // Calculate luminance
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

          // Return black or white based on luminance
          return luminance > 0.5 ? '#000000' : '#ffffff';
        }
      }

      // For non-hex colors, use a simple heuristic
      const colorLower = color.toLowerCase();
      if (colorLower === 'white' || colorLower === 'yellow' || colorLower === 'cyan' || colorLower === 'lightgray' || colorLower === 'lightgrey') {
        return '#000000';
      } else {
        return '#ffffff';
      }
    }

    function getStyleAbbreviation(style) {
      switch (style) {
        case 'background': return 'bg';
        case 'color': return 'txt';
        case 'underline': return 'ul';
        case 'border': return 'bd';
        case 'symbol': return 'sym';
        default: return 'bg';
      }
    }

    function applyStyleToButton(button, color, style) {
      // Reset all styles first
      button.style.backgroundColor = '';
      button.style.color = '';
      button.style.border = '';
      button.style.textDecoration = '';

      try {
        switch (style) {
          case 'background':
            button.style.backgroundColor = color;
            button.style.color = getContrastColor(color);
            break;
          case 'color':
            button.style.color = color;
            break;
          case 'underline':
            button.style.textDecoration = `underline ${color}`;
            break;
          case 'border':
            button.style.border = `2px solid ${color}`;
            break;
        }
      } catch (e) {
        // If color is invalid, reset to default
        button.style.backgroundColor = '';
        button.style.color = '';
        button.style.border = '';
        button.style.textDecoration = '';
      }
    }

    function applyStyleToElement(element, color, style) {
      try {
        switch (style) {
          case 'background':
            element.style.backgroundColor = color;
            element.style.color = getContrastColor(color);
            element.style.padding = '2px 4px';
            element.style.borderRadius = '3px';
            break;
          case 'color':
            element.style.color = color;
            break;
          case 'underline':
            element.style.textDecoration = `underline ${color}`;
            break;
          case 'border':
            element.style.border = `2px solid ${color}`;
            element.style.padding = '1px 3px';
            element.style.borderRadius = '3px';
            break;
          case 'symbol':
            // Get the group emoji from the title (which contains the group name)
            const groupName = element.title;
            if (debugMode) console.log('Symbol style - groupName:', groupName);
            const emoji = getGroupEmoji(groupName);
            if (debugMode) console.log('Symbol style - emoji:', emoji);
            if (emoji) {
              // Check if the emoji is already at the start of the text to prevent duplicates
              if (!element.textContent.startsWith(emoji + ' ')) {
                element.textContent = emoji + ' ' + element.textContent;
                if (debugMode) console.log('Symbol style applied:', element.textContent);
              } else {
                if (debugMode) console.log('Symbol already applied, skipping');
              }
            }
            break;
          case 'semantic':
            // Apply semantic styling based on the element's data
            applySemanticStyling(element);
            break;
        }
      } catch (e) {
        // If color is invalid, reset to default
        element.style.backgroundColor = '';
        element.style.color = '';
        element.style.border = '';
        element.style.textDecoration = '';
      }
    }

    function applySemanticStyling(element) {
      // Get the semantic data from the element's matched object
      const matched = element.matchedObject;
      if (debugMode) console.log('Applying semantic styling to element:', element, 'matched:', matched);
      if (!matched || !matched.isSemantic) {
        if (debugMode) console.log('Not a semantic object or missing matched object');
        return;
      }

      // Apply semantic styles that can intersect with existing object styles

      // Only show labels if the user has promoted this to a JSON Object
      if (matched.label && matched.isPromoted) {
        // Add label styling (bold) - this can intersect with existing styles
        element.style.fontWeight = 'bold';
      }

      // Apply summary styling (italic) - this should intersect with other styles
      if (matched.summary) {
        element.style.fontStyle = 'italic';
      }

      // Add subtle visual indicator for semantic structures (preserve existing styles)
      const existingBorder = element.style.borderBottom;
      if (!existingBorder || existingBorder === '') {
        element.style.borderBottom = '1px dotted #ccc';
      }

      element.style.cursor = 'pointer';
      element.title = `Semantic structure: ${matched.relationship}`;
    }

    // Lists and Arrays Management Functions
    function refreshListsUI() {
      const container = document.getElementById('listsContainer');
      container.innerHTML = '';

      // Render key-value lists
      listsData.keyValueLists.forEach((list, listIndex) => {
        const listElement = createKeyValueListElement(list, listIndex);
        container.appendChild(listElement);
      });

      // Render arrays
      listsData.arrays.forEach((array, arrayIndex) => {
        const arrayElement = createArrayElement(array, arrayIndex);
        container.appendChild(arrayElement);
      });
    }

    function createKeyValueListElement(list, listIndex) {
      const container = document.createElement('div');
      container.className = 'list-container';
      container.dataset.listIndex = listIndex;
      container.dataset.type = 'keyValue';

      const header = document.createElement('div');
      header.className = 'list-header';

      const title = document.createElement('h3');
      title.className = 'list-title';
      title.contentEditable = true;
      title.textContent = list.name || 'Key-Value List';
      title.addEventListener('blur', () => {
        list.name = title.textContent;
        autoSavePatternHierarchy();
      });

      const typeBadge = document.createElement('span');
      typeBadge.className = 'list-type';
      typeBadge.textContent = 'Key-Value';

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn btn-danger btn-xs';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', () => {
        listsData.keyValueLists.splice(listIndex, 1);
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      header.appendChild(title);
      header.appendChild(typeBadge);
      header.appendChild(deleteBtn);

      const content = document.createElement('div');
      content.className = 'list-content';

      // Render key-value pairs
      list.items.forEach((item, itemIndex) => {
        const row = document.createElement('div');
        row.className = 'key-value-row';

        const keyInput = document.createElement('input');
        keyInput.placeholder = 'Key';
        keyInput.value = item.key || '';
        keyInput.addEventListener('input', () => {
          item.key = keyInput.value;
          autoSavePatternHierarchy();
        });

        const valueInput = document.createElement('input');
        valueInput.placeholder = 'Value';
        valueInput.value = item.value || '';
        valueInput.addEventListener('input', () => {
          item.value = valueInput.value;
          autoSavePatternHierarchy();
        });

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-danger btn-xs';
        removeBtn.textContent = '✕';
        removeBtn.addEventListener('click', () => {
          list.items.splice(itemIndex, 1);
          refreshListsUI();
          autoSavePatternHierarchy();
        });

        row.appendChild(keyInput);
        row.appendChild(valueInput);
        row.appendChild(removeBtn);
        content.appendChild(row);
      });

      const actions = document.createElement('div');
      actions.className = 'list-actions';

      const addItemBtn = document.createElement('button');
      addItemBtn.className = 'btn btn-secondary btn-xs';
      addItemBtn.textContent = '+ Add Item';
      addItemBtn.addEventListener('click', () => {
        list.items.push({ key: '', value: '' });
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      actions.appendChild(addItemBtn);
      content.appendChild(actions);

      container.appendChild(header);
      container.appendChild(content);

      return container;
    }

    function createArrayElement(array, arrayIndex) {
      const container = document.createElement('div');
      container.className = 'list-container';
      container.dataset.arrayIndex = arrayIndex;
      container.dataset.type = 'array';

      const header = document.createElement('div');
      header.className = 'list-header';

      const title = document.createElement('h3');
      title.className = 'list-title';
      title.contentEditable = true;
      title.textContent = array.name || 'Array';
      title.addEventListener('blur', () => {
        array.name = title.textContent;
        autoSavePatternHierarchy();
      });

      const typeBadge = document.createElement('span');
      typeBadge.className = 'list-type';
      typeBadge.textContent = 'Array';

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn btn-danger btn-xs';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', () => {
        listsData.arrays.splice(arrayIndex, 1);
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      header.appendChild(title);
      header.appendChild(typeBadge);
      header.appendChild(deleteBtn);

      const content = document.createElement('div');
      content.className = 'list-content';

      // Render array items
      array.items.forEach((item, itemIndex) => {
        const row = document.createElement('div');
        row.className = 'array-row';

        const valueInput = document.createElement('input');
        valueInput.placeholder = 'Value';
        valueInput.value = item || '';
        valueInput.addEventListener('input', () => {
          array.items[itemIndex] = valueInput.value;
          autoSavePatternHierarchy();
        });

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-danger btn-xs';
        removeBtn.textContent = '✕';
        removeBtn.addEventListener('click', () => {
          array.items.splice(itemIndex, 1);
          refreshListsUI();
          autoSavePatternHierarchy();
        });

        row.appendChild(valueInput);
        row.appendChild(removeBtn);
        content.appendChild(row);
      });

      const actions = document.createElement('div');
      actions.className = 'list-actions';

      const addItemBtn = document.createElement('button');
      addItemBtn.className = 'btn btn-secondary btn-xs';
      addItemBtn.textContent = '+ Add Item';
      addItemBtn.addEventListener('click', () => {
        array.items.push('');
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      actions.appendChild(addItemBtn);
      content.appendChild(actions);

      container.appendChild(header);
      container.appendChild(content);

      return container;
    }

    // Color management functions
    function updateDefaultColorButtons() {
      updateDefaultColorButton(1, defaultPattern.color1, defaultPattern.style1);
      updateDefaultColorButton(2, defaultPattern.color2, defaultPattern.style2);
    }

    function updateDefaultColorButton(colorNum, color, style) {
      const button = colorNum === 1 ? document.getElementById('defaultColor1Btn') : document.getElementById('defaultColor2Btn');
      const colorDisplay = colorNum === 1 ? document.getElementById('defaultColor1Display') : document.getElementById('defaultColor2Display');
      const styleDisplay = colorNum === 1 ? document.getElementById('defaultStyle1Display') : document.getElementById('defaultStyle2Display');

      if (button) {
        if (color && color.trim() !== '' && style && style.trim() !== '') {
          colorDisplay.textContent = color;
          styleDisplay.textContent = getStyleAbbreviation(style);
          applyStyleToButton(button, color, style);
        } else {
          // No color or style set, use default styling
          button.style.backgroundColor = '';
          button.style.color = '';
          button.style.border = '';
          button.style.textDecoration = '';
          colorDisplay.textContent = '-';
          styleDisplay.textContent = '';
        }
      }
    }

    function showDefaultColorPanel(colorNum) {
      const panel = colorNum === 1 ? document.getElementById('defaultColor1Panel') : document.getElementById('defaultColor2Panel');
      const textInput = colorNum === 1 ? document.getElementById('defaultColor1Text') : document.getElementById('defaultColor2Text');
      const picker = colorNum === 1 ? document.getElementById('defaultColor1Picker') : document.getElementById('defaultColor2Picker');
      const styleSelect = colorNum === 1 ? document.getElementById('defaultStyle1Select') : document.getElementById('defaultStyle2Select');
      const display = colorNum === 1 ? document.getElementById('defaultColor1Display') : document.getElementById('defaultColor2Display');
      const button = colorNum === 1 ? document.getElementById('defaultColor1Btn') : document.getElementById('defaultColor2Btn');
      const color = colorNum === 1 ? defaultPattern.color1 : defaultPattern.color2;
      const style = colorNum === 1 ? defaultPattern.style1 : defaultPattern.style2;

      // Set current values
      textInput.value = color;
      display.textContent = color || '-';
      styleSelect.value = style || 'background';

      // Try to set color picker value if it's a hex color
      if (color && color.match(/^#[0-9A-Fa-f]{6}$/)) {
        picker.value = color;
      }

      // Position the panel relative to the button
      if (button) {
        const rect = button.getBoundingClientRect();
        panel.style.position = 'absolute';
        panel.style.top = (rect.bottom + window.scrollY) + 'px';
        panel.style.left = rect.left + 'px';
      }

      panel.classList.add('show');
      textInput.focus();
    }

    function hideDefaultColorPanel(colorNum) {
      const panel = colorNum === 1 ? document.getElementById('defaultColor1Panel') : document.getElementById('defaultColor2Panel');
      panel.classList.remove('show');
    }

    // Rule style panel functions
    function showRuleStylePanel(ruleIndex, styleNum) {
      // Create or get the style panel for this rule
      let panel = document.getElementById(`ruleStylePanel_${ruleIndex}_${styleNum}`);
      if (!panel) {
        panel = createRuleStylePanel(ruleIndex, styleNum);
        document.body.appendChild(panel);
      }

      const rule = dictionary.rules[ruleIndex];
      const style = styleNum === 1 ? rule.style1 : rule.style2;

      // Set current values
      const styleSelect = panel.querySelector('.style-select');
      styleSelect.value = style || 'background';

      // Position the panel relative to the button
      const button = document.querySelector(`[data-idx="${ruleIndex}"] .style${styleNum}-btn`);
      if (button) {
        const rect = button.getBoundingClientRect();
        panel.style.position = 'absolute';
        panel.style.top = (rect.bottom + window.scrollY) + 'px';
        panel.style.left = rect.left + 'px';
      }

      panel.classList.add('show');
      styleSelect.focus();
    }

    function createRuleStylePanel(ruleIndex, styleNum) {
      const panel = document.createElement('div');
      panel.id = `ruleStylePanel_${ruleIndex}_${styleNum}`;
      panel.className = 'inline-form';
      panel.style.cssText = `
        position: absolute;
        min-width: 200px;
        background: white;
        border: 1px solid #dee2e6;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 1000;
      `;

      panel.innerHTML = `
        <div class="inline-form-row">
          <label>Style ${styleNum}:</label>
          <select class="style-select" style="flex: 1;">
            <option value="">None</option>
            <option value="background">Background</option>
            <option value="color">Text Color</option>
            <option value="underline">Underline</option>
            <option value="border">Border</option>
            <option value="symbol">Symbol</option>
          </select>
        </div>
        <div class="inline-form-actions">
          <button class="btn btn-success btn-small apply-rule-style">Apply</button>
          <button class="btn btn-danger btn-small cancel-rule-style">Cancel</button>
        </div>
      `;

      // Add event listeners
      const applyBtn = panel.querySelector('.apply-rule-style');
      const cancelBtn = panel.querySelector('.cancel-rule-style');

      applyBtn.addEventListener('click', () => {
        const style = panel.querySelector('.style-select').value;
        const rule = dictionary.rules[ruleIndex];
        if (styleNum === 1) {
          rule.style1 = style;
        } else {
          rule.style2 = style;
        }
        refreshRuleUI();
        applyRules();
        autoSavePatternHierarchy();
        hideRuleStylePanel(ruleIndex, styleNum);
      });

      cancelBtn.addEventListener('click', () => {
        hideRuleStylePanel(ruleIndex, styleNum);
      });

      return panel;
    }

    function hideRuleStylePanel(ruleIndex, styleNum) {
      const panel = document.getElementById(`ruleStylePanel_${ruleIndex}_${styleNum}`);
      if (panel) {
        panel.classList.remove('show');
      }
    }

    // Object color panel functions
    function showObjectColorPanel(objectIndex, colorNum) {
      // Create or get the color panel for this object
      let panel = document.getElementById(`objectColorPanel_${objectIndex}_${colorNum}`);
      if (!panel) {
        panel = createObjectColorPanel(objectIndex, colorNum);
        document.body.appendChild(panel);
      }

      const obj = objectsData.objects[objectIndex];
      if (!obj) {
        console.error(`Object not found at index ${objectIndex}`);
        return;
      }
      const color = colorNum === 1 ? obj.color1 : obj.color2;
      const style = colorNum === 1 ? obj.style1 : obj.style2;

      // Set current values
      const textInput = panel.querySelector('.color-text');
      const picker = panel.querySelector('.color-picker');

      textInput.value = color || '';

      // Try to set color picker value if it's a hex color
      if (color && color.match(/^#[0-9A-Fa-f]{6}$/)) {
        picker.value = color;
      }

      // Position the panel in the center of the screen
      panel.style.position = 'fixed';
      panel.style.top = '50%';
      panel.style.left = '50%';
      panel.style.transform = 'translate(-50%, -50%)';
      panel.style.zIndex = '10000';

      panel.classList.add('show');
      textInput.focus();
    }

    function createObjectColorPanel(objectIndex, colorNum) {
      const panel = document.createElement('div');
      panel.id = `objectColorPanel_${objectIndex}_${colorNum}`;
      panel.className = 'inline-form';
      panel.style.cssText = `
        position: absolute;
        min-width: 250px;
        background: white;
        border: 1px solid #dee2e6;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 1000;
      `;

      panel.innerHTML = `
        <div class="inline-form-row">
          <label>Color ${colorNum}:</label>
          <input type="text" class="color-text" placeholder="color (e.g. #ff0000) or leave empty for none" style="flex: 1;" />
        </div>
        <div class="inline-form-row">
          <label>Picker:</label>
          <input type="color" class="color-picker" value="#ff00ff" style="width: 50px; height: 30px;" />
        </div>
        <div class="inline-form-actions">
          <button class="btn btn-success btn-small apply-object-color">Apply</button>
          <button class="btn btn-danger btn-small cancel-object-color">Cancel</button>
        </div>
      `;

      // Add event listeners
      const applyBtn = panel.querySelector('.apply-object-color');
      const cancelBtn = panel.querySelector('.cancel-object-color');
      const textInput = panel.querySelector('.color-text');
      const picker = panel.querySelector('.color-picker');

      applyBtn.addEventListener('click', () => {
        const color = textInput.value;
        const obj = objectsData.objects[objectIndex];
        if (colorNum === 1) {
          obj.color1 = color;
        } else {
          obj.color2 = color;
        }
        refreshObjectsUI();
        refreshGroupsSidebar(); // Refresh sidebar to show updated colors
        applyRules();
        autoSavePatternHierarchy();
        hideObjectColorPanel(objectIndex, colorNum);
      });

      cancelBtn.addEventListener('click', () => {
        hideObjectColorPanel(objectIndex, colorNum);
      });

      // Sync picker with text input
      picker.addEventListener('input', () => {
        textInput.value = picker.value;
      });

      textInput.addEventListener('input', () => {
        if (textInput.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          picker.value = textInput.value;
        }
      });

      return panel;
    }

    function hideObjectColorPanel(objectIndex, colorNum) {
      const panel = document.getElementById(`objectColorPanel_${objectIndex}_${colorNum}`);
      if (panel) {
        panel.classList.remove('show');
      }
    }

    // Event Listeners
    document.addEventListener('DOMContentLoaded', function () {
      // Initialize tabs
      initTabs();

      // Handle URL parameters
      handleURLParameters();

      // Basic event listeners
      document.getElementById('clearBtn').addEventListener('click', () => {
        document.getElementById('sourceText').value = '';
        applyRules();
      });

      // Auto-update preview when input text changes
      document.getElementById('sourceText').addEventListener('input', () => {
        applyRules();
      });
      // Removed addRule and addObject event listeners - sections removed

      // Removed category dropdown functions - section removed

      // Function to generate random color
      function generateRandomColor() {
        const colors = [
          '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
          '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
          '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2',
          '#FAD7A0', '#A9CCE3', '#F9E79F', '#D5A6BD', '#A3E4D7'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      // Removed object category dropdown functions - section removed

      // Removed createNewGroup and createNewObject functions - sections removed

      // Removed dropdown click handlers - sections removed
      document.getElementById('downloadMd').addEventListener('click', downloadMarkdown);
      document.getElementById('downloadPdf').addEventListener('click', downloadPDF);
      document.getElementById('copyHtml').addEventListener('click', copyStyledHTML);
      document.getElementById('copyPlain').addEventListener('click', copyPlainText);
      document.getElementById('copyShareableUrl').addEventListener('click', copyShareableURL);
      document.getElementById('copyMarkdownUrl').addEventListener('click', () => {
        const text = document.getElementById('sourceText').value || '';
        if (!text || text.trim() === '') {
          alert('Please enter some text first before copying a shareable URL.');
          return;
        }
        const shareableURL = generateShareableURL(text, 'markdown');
        if (!shareableURL) {
          return; // User cancelled or URL generation failed
        }
        navigator.clipboard.writeText(shareableURL).then(() => {
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #007aff;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
          `;
          notification.textContent = 'Markdown export URL copied to clipboard!';
          document.body.appendChild(notification);

          setTimeout(() => {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 3000);
        });
      });
      document.getElementById('copyPdfUrl').addEventListener('click', () => {
        const text = document.getElementById('sourceText').value || '';
        if (!text || text.trim() === '') {
          alert('Please enter some text first before copying a shareable URL.');
          return;
        }
        const shareableURL = generateShareableURL(text, 'pdf');
        if (!shareableURL) {
          return; // User cancelled or URL generation failed
        }
        navigator.clipboard.writeText(shareableURL).then(() => {
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #007aff;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
          `;
          notification.textContent = 'PDF export URL copied to clipboard!';
          document.body.appendChild(notification);

          setTimeout(() => {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 3000);
        });
      });

      document.getElementById('testUrlLength').addEventListener('click', () => {
        testURLLength();
        alert('Check the browser console (F12) to see URL length test results!');
      });

      // bob.json operations
      document.getElementById('loadBobJson').addEventListener('click', async () => {
        try {
          // Try to use File System Access API for file selection
          if ('showOpenFilePicker' in window) {
            try {
              const [fileHandle] = await window.showOpenFilePicker({
                types: [{
                  description: 'JSON files',
                  accept: { 'application/json': ['.json'] }
                }]
              });
              const file = await fileHandle.getFile();
              const content = await file.text();
              const data = JSON.parse(content);

              // Load the data
              if (data.defaultPattern) {
                defaultPattern = data.defaultPattern;
              }
              if (data.dictionary) {
                dictionary = data.dictionary;
              }
              if (data.listsData) {
                listsData = data.listsData;
              }
              if (data.objectsData) {
                objectsData = data.objectsData;
              }

              // Update UI
              updatePatternUI();
              refreshRuleUI();
              refreshObjectsUI();
              refreshListsUI();
              refreshGroupsSidebar();
              applyRules();

              console.log('Loaded from selected file');
              showNotification('File loaded successfully!', 'success');
            } catch (e) {
              console.log('File System Access API failed, falling back to localStorage');
              loadPatternHierarchy();
            }
          } else {
            // Fallback to localStorage
            loadPatternHierarchy();
          }
        } catch (error) {
          console.error('Error loading file:', error);
          alert('Error loading file. Please make sure it\'s a valid JSON file.');
        }
      });

      document.getElementById('saveBobJson').addEventListener('click', exportPatternHierarchy);

      // Default pattern event listeners
      document.getElementById('defaultPatternEnabled').addEventListener('change', applyRules);

      // Color button and panel functionality
      const defaultColor1Btn = document.getElementById('defaultColor1Btn');
      const defaultColor2Btn = document.getElementById('defaultColor2Btn');
      const defaultColor1Panel = document.getElementById('defaultColor1Panel');
      const defaultColor2Panel = document.getElementById('defaultColor2Panel');
      const defaultColor1Text = document.getElementById('defaultColor1Text');
      const defaultColor2Text = document.getElementById('defaultColor2Text');
      const defaultColor1Picker = document.getElementById('defaultColor1Picker');
      const defaultColor2Picker = document.getElementById('defaultColor2Picker');
      const applyDefaultColor1Btn = document.getElementById('applyDefaultColor1');
      const applyDefaultColor2Btn = document.getElementById('applyDefaultColor2');
      const cancelDefaultColor1Btn = document.getElementById('cancelDefaultColor1');
      const cancelDefaultColor2Btn = document.getElementById('cancelDefaultColor2');

      // Show/hide color panels
      defaultColor1Btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isVisible = defaultColor1Panel.classList.contains('show');
        if (isVisible) {
          hideDefaultColorPanel(1);
        } else {
          showDefaultColorPanel(1);
        }
      });

      defaultColor2Btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isVisible = defaultColor2Panel.classList.contains('show');
        if (isVisible) {
          hideDefaultColorPanel(2);
        } else {
          showDefaultColorPanel(2);
        }
      });

      // Hide panels when clicking outside
      document.addEventListener('click', (e) => {
        if (!defaultColor1Btn.contains(e.target) && !defaultColor1Panel.contains(e.target)) {
          hideDefaultColorPanel(1);
        }
        if (!defaultColor2Btn.contains(e.target) && !defaultColor2Panel.contains(e.target)) {
          hideDefaultColorPanel(2);
        }

        // Hide rule color panels when clicking outside
        const ruleColorPanels = document.querySelectorAll('[id^="ruleColorPanel_"]');
        ruleColorPanels.forEach(panel => {
          if (!panel.contains(e.target)) {
            panel.classList.remove('show');
          }
        });

        // Hide object color panels when clicking outside
        const objectColorPanels = document.querySelectorAll('[id^="objectColorPanel_"]');
        objectColorPanels.forEach(panel => {
          if (!panel.contains(e.target)) {
            panel.classList.remove('show');
          }
        });
      });

      // Apply color changes
      applyDefaultColor1Btn.addEventListener('click', () => {
        const color = defaultColor1Text.value;
        const style = document.getElementById('defaultStyle1Select').value;
        defaultPattern.color1 = color;
        defaultPattern.style1 = style;
        updateDefaultColorButtons();
        updatePatternUI();
        applyRules();
        autoSavePatternHierarchy();
        hideDefaultColorPanel(1);
      });

      applyDefaultColor2Btn.addEventListener('click', () => {
        const color = defaultColor2Text.value;
        const style = document.getElementById('defaultStyle2Select').value;
        defaultPattern.color2 = color;
        defaultPattern.style2 = style;
        updateDefaultColorButtons();
        updatePatternUI();
        applyRules();
        autoSavePatternHierarchy();
        hideDefaultColorPanel(2);
      });

      // Cancel color changes
      cancelDefaultColor1Btn.addEventListener('click', () => {
        hideDefaultColorPanel(1);
        defaultColor1Text.value = defaultPattern.color1;
        document.getElementById('defaultColor1Display').textContent = defaultPattern.color1;
      });

      cancelDefaultColor2Btn.addEventListener('click', () => {
        hideDefaultColorPanel(2);
        defaultColor2Text.value = defaultPattern.color2;
        document.getElementById('defaultColor2Display').textContent = defaultPattern.color2 || '-';
      });

      // Sync color pickers with text inputs
      defaultColor1Picker.addEventListener('input', () => {
        defaultColor1Text.value = defaultColor1Picker.value;
      });

      defaultColor2Picker.addEventListener('input', () => {
        defaultColor2Text.value = defaultColor2Picker.value;
      });

      // Sync text inputs with color pickers
      defaultColor1Text.addEventListener('input', () => {
        if (defaultColor1Text.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          defaultColor1Picker.value = defaultColor1Text.value;
        }
      });

      defaultColor2Text.addEventListener('input', () => {
        if (defaultColor2Text.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          defaultColor2Picker.value = defaultColor2Text.value;
        }
      });

      // Pattern building event listeners
      const basePatternInput = document.getElementById('basePatternInput');
      if (basePatternInput) {
        basePatternInput.addEventListener('input', () => {
          defaultPattern.structure.basePattern = basePatternInput.value;
          updatePatternUI();
          applyRules();
          autoSavePatternHierarchy();
        });
      }



      // Wrapper toggle event listeners
      const wrapperToggles = document.querySelectorAll('.wrapper-toggle');
      wrapperToggles.forEach(btn => {
        btn.addEventListener('click', () => {
          const wrapper = btn.dataset.wrapper;
          const isActive = btn.dataset.active === 'true';

          switch (wrapper) {
            case 'word-boundary':
              updatePatternWithWordBoundaries(!isActive);
              break;
            case 'start-anchor':
              updatePatternWithAnchors('start', !isActive);
              break;
            case 'end-anchor':
              updatePatternWithAnchors('end', !isActive);
              break;
          }
          applyRules();
        });
      });

      // Add regex toggle buttons event listeners
      document.getElementById('addPrependRegexToggle').addEventListener('click', () => {
        const form = document.getElementById('inlineRegexForm');
        const toggleModeBtn = document.getElementById('togglePrependMode');
        const newRegexValue = document.getElementById('newRegexValue');
        const newRegexLabel = document.getElementById('newRegexLabel');

        // Set to prepend mode
        toggleModeBtn.textContent = '^';
        toggleModeBtn.title = 'Toggle between append (+) and prepend (^) mode';

        // Clear form
        newRegexValue.value = '';
        newRegexLabel.value = '';

        // Show form
        form.classList.add('show');
        newRegexValue.focus();
      });

      document.getElementById('addRegexToggle').addEventListener('click', () => {
        const form = document.getElementById('inlineRegexForm');
        const toggleModeBtn = document.getElementById('togglePrependMode');
        const newRegexValue = document.getElementById('newRegexValue');
        const newRegexLabel = document.getElementById('newRegexLabel');

        // Set to append mode
        toggleModeBtn.textContent = '+';
        toggleModeBtn.title = 'Toggle between append (+) and prepend (^) mode';

        // Clear form
        newRegexValue.value = '';
        newRegexLabel.value = '';

        // Show form
        form.classList.add('show');
        newRegexValue.focus();
      });

      // Inline regex form event listeners
      document.getElementById('togglePrependMode').addEventListener('click', () => {
        const btn = document.getElementById('togglePrependMode');
        const isPrepend = btn.textContent === '^';
        btn.textContent = isPrepend ? '+' : '^';
        btn.title = isPrepend ? 'Toggle between append (+) and prepend (^) mode' : 'Toggle between append (+) and prepend (^) mode';
      });

      document.getElementById('saveRegexToggle').addEventListener('click', () => {
        const newRegexValue = document.getElementById('newRegexValue').value;
        const newRegexLabel = document.getElementById('newRegexLabel').value;
        const toggleModeBtn = document.getElementById('togglePrependMode');
        const isPrepend = toggleModeBtn.textContent === '^';

        if (newRegexValue.trim()) {
          updatePatternWithRegexToggle(newRegexValue, isPrepend, true, newRegexLabel || 'Custom Toggle');

          // Hide form
          document.getElementById('inlineRegexForm').classList.remove('show');

          // Clear form
          document.getElementById('newRegexValue').value = '';
          document.getElementById('newRegexLabel').value = '';
        }
      });

      document.getElementById('cancelRegexToggle').addEventListener('click', () => {
        document.getElementById('inlineRegexForm').classList.remove('show');
        document.getElementById('newRegexValue').value = '';
        document.getElementById('newRegexLabel').value = '';
      });

      // Lists and arrays event listeners
      document.getElementById('addKeyValueList').addEventListener('click', () => {
        listsData.keyValueLists.push({
          name: 'New Key-Value List',
          items: [{ key: '', value: '' }]
        });
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      document.getElementById('addArray').addEventListener('click', () => {
        listsData.arrays.push({
          name: 'New Array',
          items: ['']
        });
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      // Bulk load objects event listeners
      // Removed bulk load objects event listeners - section removed

      // Preview buttons event listeners
      document.getElementById('loadSampleMd').addEventListener('click', loadSampleMd);
      document.getElementById('convertBob').addEventListener('click', () => {
        convertBobToMarkdown().catch(error => {
          console.error('Error converting Bob:', error);
          alert('Error converting Bob. Check console for details.');
        });
      });

      // Function to update debug button state
      function updateDebugButtonState() {
        const debugBtn = document.getElementById('debugToggle');
        if (debugBtn) {
          debugBtn.textContent = `Debug: ${debugMode ? 'ON' : 'OFF'}`;
          debugBtn.style.background = debugMode ? '#28a745' : '#6c757d';
        }
      }

      // Debug toggle functionality
      document.getElementById('debugToggle').addEventListener('click', () => {
        debugMode = !debugMode;
        updateDebugButtonState();
        autoSavePatternHierarchy(); // Persist the debug state
        console.log(`Debug mode: ${debugMode ? 'enabled' : 'disabled'}`);
      });

      // Initialize debug button state
      updateDebugButtonState();

      // Refresh button event listener
      document.getElementById('refreshBtn').addEventListener('click', refreshFromBobJson);

      // Config button event listener
      document.getElementById('configBtn').addEventListener('click', () => {
        // Switch to config tab
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

        document.getElementById('config').classList.add('active');
      });

      // Removed priority order management event listeners - section removed

      // Initialize UI
      updatePatternUI();
      refreshRuleUI();
      refreshObjectsUI();
      refreshListsUI();

      // Object Editor Modal Event Listeners
      document.getElementById('closeObjectEditor').addEventListener('click', closeObjectEditor);
      document.getElementById('cancelObjectEdit').addEventListener('click', closeObjectEditor);
      document.getElementById('saveObject').addEventListener('click', (e) => {
        e.preventDefault();
        saveObjectChanges();
      });
      document.getElementById('deleteObject').addEventListener('click', deleteObject);

      // Object Editor Form Event Listeners for real-time JSON preview
      const formFields = [
        'objectEditorLabel',
        'objectEditorMatchRegex',
        'objectEditorGroupSelect',
        'objectEditorColor1',
        'objectEditorColor2',
        'objectEditorStyle1',
        'objectEditorStyle2',
        'objectEditorEnabled'
      ];

      formFields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) {
          field.addEventListener('input', updateObjectEditorJsonPreview);
          field.addEventListener('change', updateObjectEditorJsonPreview);
        }
      });

      // Color picker event listeners
      document.getElementById('objectEditorColor1Picker').addEventListener('input', (e) => {
        document.getElementById('objectEditorColor1').value = e.target.value;
        updateObjectEditorJsonPreview();
        updateColorPickerBackground('objectEditorColor1Picker', e.target.value);
      });

      document.getElementById('objectEditorColor2Picker').addEventListener('input', (e) => {
        document.getElementById('objectEditorColor2').value = e.target.value;
        updateObjectEditorJsonPreview();
        updateColorPickerBackground('objectEditorColor2Picker', e.target.value);
      });

      // Text input event listeners for color pickers
      document.getElementById('objectEditorColor1').addEventListener('input', (e) => {
        const color = e.target.value;
        const picker = document.getElementById('objectEditorColor1Picker');
        if (color.match(/^#[0-9A-Fa-f]{6}$/)) {
          picker.value = color;
          updateColorPickerBackground('objectEditorColor1Picker', color);
        }
        updateObjectEditorJsonPreview();
      });

      document.getElementById('objectEditorColor2').addEventListener('input', (e) => {
        const color = e.target.value;
        const picker = document.getElementById('objectEditorColor2Picker');
        if (color.match(/^#[0-9A-Fa-f]{6}$/)) {
          picker.value = color;
          updateColorPickerBackground('objectEditorColor2Picker', color);
        }
        updateObjectEditorJsonPreview();
      });

      // Close modal when clicking outside
      document.getElementById('objectEditorModal').addEventListener('click', (e) => {
        if (e.target.id === 'objectEditorModal') {
          closeObjectEditor();
        }
      });

      // Groups Editor Sidebar functionality
      const sidebar = document.getElementById('groupsEditorSidebar');
      const sidebarToggle = document.getElementById('groupsEditorToggle');
      const mainContent = document.getElementById('mainContent');

      function toggleSidebar() {
        const isOpen = sidebar.classList.contains('show');
        const openIcon = sidebarToggle.querySelector('.sidebar-open-icon');
        const closeIcon = sidebarToggle.querySelector('.sidebar-close-icon');

        if (isOpen) {
          sidebar.classList.remove('show');
          mainContent.classList.add('sidebar-closed');
          openIcon.style.display = 'block';
          closeIcon.style.display = 'none';
        } else {
          sidebar.classList.add('show');
          mainContent.classList.remove('sidebar-closed');
          openIcon.style.display = 'none';
          closeIcon.style.display = 'block';
          refreshGroupsSidebar();
        }
      }

      sidebarToggle.addEventListener('click', toggleSidebar);

      // Sidebar add buttons
      document.getElementById('sidebarAddGroup').addEventListener('click', createNewGroupFromSidebar);

      // Enhanced sidebar add object button with bulk add option
      const sidebarAddObjectBtn = document.getElementById('sidebarAddObject');
      sidebarAddObjectBtn.addEventListener('click', createNewObjectFromSidebar);

      // Add hover functionality for bulk add
      let sidebarAddTimeout;
      let sidebarAddExpanded = false;

      sidebarAddObjectBtn.addEventListener('mouseenter', () => {
        clearTimeout(sidebarAddTimeout);
        if (!sidebarAddExpanded) {
          sidebarAddTimeout = setTimeout(() => {
            showSidebarBulkAddOptions();
            sidebarAddExpanded = true;
          }, 200);
        }
      });

      sidebarAddObjectBtn.addEventListener('mouseleave', () => {
        clearTimeout(sidebarAddTimeout);
        sidebarAddTimeout = setTimeout(() => {
          hideSidebarBulkAddOptions();
          sidebarAddExpanded = false;
        }, 400);
      });

      // Note: Removed auto-close functionality as requested
      // Sidebar stays open until manually closed

      // Load pattern hierarchy from bob.json on page load
      loadPatternHierarchy();

      // Initialize debug button state after loading data
      setTimeout(() => {
        if (typeof updateDebugButtonState === 'function') {
          updateDebugButtonState();
        }
      }, 100);
    });

    // Removed bulk load objects functions - section removed



    // Sidebar bulk add functions
    function showSidebarBulkAddOptions() {
      // Remove any existing options
      const existingOptions = document.getElementById('sidebarBulkAddOptions');
      if (existingOptions) {
        existingOptions.remove();
      }

      const options = document.createElement('div');
      options.id = 'sidebarBulkAddOptions';
      options.className = 'sidebar-add-options';
      options.style.cssText = `
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #007aff;
        border-radius: 4px;
        padding: 0.25rem;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      `;

      const singleAddBtn = document.createElement('div');
      singleAddBtn.className = 'sidebar-option-btn';
      singleAddBtn.style.cssText = `
        padding: 0.25rem 0.5rem;
        cursor: pointer;
        border-radius: 2px;
        font-size: 0.75rem;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        transition: all 0.2s ease;
        color: #333;
      `;
      singleAddBtn.textContent = 'Add Single Object';
      singleAddBtn.addEventListener('mouseenter', () => {
        singleAddBtn.style.background = '#007aff';
        singleAddBtn.style.color = 'white';
      });
      singleAddBtn.addEventListener('mouseleave', () => {
        singleAddBtn.style.background = '#f8f9fa';
        singleAddBtn.style.color = '#333';
      });
      singleAddBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        createNewObjectFromSidebar();
        hideSidebarBulkAddOptions();
      });

      const bulkAddBtn = document.createElement('div');
      bulkAddBtn.className = 'sidebar-option-btn';
      bulkAddBtn.style.cssText = `
        padding: 0.25rem 0.5rem;
        cursor: pointer;
        border-radius: 2px;
        font-size: 0.75rem;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        transition: all 0.2s ease;
        margin-top: 2px;
        color: #333;
      `;
      bulkAddBtn.textContent = 'Bulk Add Objects';
      bulkAddBtn.addEventListener('mouseenter', () => {
        bulkAddBtn.style.background = '#007aff';
        bulkAddBtn.style.color = 'white';
      });
      bulkAddBtn.addEventListener('mouseleave', () => {
        bulkAddBtn.style.background = '#f8f9fa';
        bulkAddBtn.style.color = '#333';
      });
      bulkAddBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        showSidebarBulkAddForm();
        hideSidebarBulkAddOptions();
      });

      options.appendChild(singleAddBtn);
      options.appendChild(bulkAddBtn);

      const sidebarAddObjectBtn = document.getElementById('sidebarAddObject');
      sidebarAddObjectBtn.style.position = 'relative';
      sidebarAddObjectBtn.appendChild(options);
    }

    function hideSidebarBulkAddOptions() {
      const options = document.getElementById('sidebarBulkAddOptions');
      if (options) {
        options.remove();
      }
    }

    function showSidebarBulkAddForm() {
      // Remove any existing form
      const existingForm = document.getElementById('sidebarBulkAddForm');
      if (existingForm) {
        existingForm.remove();
      }

      const form = document.createElement('div');
      form.id = 'sidebarBulkAddForm';
      form.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 1rem;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1001;
        min-width: 400px;
        max-width: 600px;
      `;

      form.innerHTML = `
        <h4 style="margin: 0 0 1rem 0;">Bulk Add Objects</h4>
        <p style="margin-bottom: 1rem; font-size: 0.9rem; color: #666;">
          Paste CSV data with columns: label,color1,color2,style1,style2,match,group,enabled
        </p>
        <textarea id="sidebarBulkObjectsInput" placeholder="Paste CSV data here..."
          style="width: 100%; height: 200px; margin-bottom: 1rem; font-family: monospace;"></textarea>
        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
          <button id="sidebarBulkLoadBtn" style="background: #007aff; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">Load Objects</button>
          <button id="sidebarBulkCancelBtn" style="background: #666; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">Cancel</button>
        </div>
      `;

      document.body.appendChild(form);

      // Event listeners
      document.getElementById('sidebarBulkLoadBtn').addEventListener('click', () => {
        const input = document.getElementById('sidebarBulkObjectsInput').value.trim();
        if (!input) {
          alert('Please enter CSV data to load objects.');
          return;
        }

        const lines = input.split('\n');
        let loadedCount = 0;
        let errorCount = 0;
        const errors = [];

        // Skip header line if it matches the expected format
        const startIndex = lines[0].toLowerCase().includes('label,color1,color2,style1,style2,match,group,enabled') ? 1 : 0;

        for (let i = startIndex; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;

          const parts = line.split(',').map(part => part.trim());

          if (parts.length < 7) {
            errors.push(`Line ${i + 1}: Insufficient columns (expected 8, got ${parts.length})`);
            errorCount++;
            continue;
          }

          const [label, color1, color2, style1, style2, match, group, enabled] = parts;

          // Validate required fields
          if (!match || !group) {
            errors.push(`Line ${i + 1}: Missing required fields (match and group are required)`);
            errorCount++;
            continue;
          }

          // Create new object
          const newObject = {
            label: label || '',
            color1: color1 || '',
            color2: color2 || '',
            style1: style1 || '',
            style2: style2 || '',
            match: match,
            group: group,
            enabled: enabled === 'true' || enabled === '1' || enabled === ''
          };

          objectsData.objects.push(newObject);
          loadedCount++;
        }

        // Show results
        let message = `Loaded ${loadedCount} objects successfully.`;
        if (errorCount > 0) {
          message += `\n\n${errorCount} errors:\n${errors.join('\n')}`;
        }

        if (errorCount > 0) {
          alert(message);
        } else {
          alert(message);
        }

        // Refresh UI and save
        refreshObjectsUI();
        refreshGroupsSidebar();
        applyRules();
        autoSavePatternHierarchy();

        // Close form
        hideSidebarBulkAddForm();
      });

      document.getElementById('sidebarBulkCancelBtn').addEventListener('click', hideSidebarBulkAddForm);
    }

    function hideSidebarBulkAddForm() {
      const form = document.getElementById('sidebarBulkAddForm');
      if (form) {
        form.remove();
      }
    }

    // Removed downloadObjectsTemplate function - section removed

    // Priority order management functions
    function showPriorityOrder() {
      const orderList = dictionary.rules.map((rule, index) => {
        const emoji = getGroupEmoji(rule.label) || '❓';
        return `${index + 1}. ${emoji} ${rule.label || 'Unnamed Group'}`;
      }).join('\n');

      alert(`Current Group Priority Order:\n\n${orderList}\n\nGroups are applied in this order. The first matching group's style will be applied.`);
    }

    function resetPriorityOrder() {
      // Sort rules alphabetically by label
      dictionary.rules.sort((a, b) => {
        const labelA = (a.label || '').toLowerCase();
        const labelB = (b.label || '').toLowerCase();
        return labelA.localeCompare(labelB);
      });

      refreshRuleUI();
      applyRules();
      autoSavePatternHierarchy();

      alert('Groups have been reset to alphabetical order.');
    }

    function updatePriorityOrderDisplay() {
      const display = document.getElementById('currentPriorityOrder');
      if (!display) {
        // Element was removed from main UI, but function is still called for sidebar
        return;
      }
      if (dictionary.rules.length > 0) {
        const orderText = dictionary.rules.map((rule, index) => {
          const emoji = getGroupEmoji(rule.label) || '❓';
          return `${index + 1}. ${emoji} ${rule.label || 'Unnamed Group'}`;
        }).join(' → ');
        display.textContent = `Current order: ${orderText}`;
      } else {
        display.textContent = 'No groups defined';
      }
    }

    async function convertBobToMarkdown() {
      let markdown = '';

      // Generate dynamic bob.md content with current date/time
      const now = new Date();
      const dateOptions = {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      };
      const timeOptions = {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      };

      const currentDate = now.toLocaleDateString('en-US', dateOptions);
      const currentTime = now.toLocaleTimeString('en-US', timeOptions);

      // Get category emojis from listsData
      const categoryEmojis = {};
      if (listsData && listsData.keyValueLists) {
        const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
        if (categoriesList && categoriesList.items) {
          categoriesList.items.forEach(item => {
            categoryEmojis[item.key] = item.value;
          });
        }
      }

      // Get group enabled status from dictionary.rules
      const groupEnabledStatus = {};
      dictionary.rules.forEach(rule => {
        if (rule.label) {
          groupEnabledStatus[rule.label] = rule.enabled !== false; // Default to true if not specified
        }
      });

      // Group objects by their group and separate enabled/disabled
      const enabledGroups = {};
      const disabledGroups = {};

      objectsData.objects.forEach(obj => {
        const groupName = obj.group;
        const groupIsEnabled = groupEnabledStatus[groupName] !== false; // Default to true if not specified
        const objectIsEnabled = obj.enabled !== false; // Default to true if not specified
        const isEnabled = groupIsEnabled && objectIsEnabled; // Both group and object must be enabled

        if (isEnabled) {
          if (!enabledGroups[groupName]) {
            enabledGroups[groupName] = [];
          }
          enabledGroups[groupName].push(obj);
        } else {
          if (!disabledGroups[groupName]) {
            disabledGroups[groupName] = [];
          }
          disabledGroups[groupName].push(obj);
        }
      });

      // Get enabled groups for the summary (only groups that have enabled objects)
      const enabledGroupNames = Object.keys(enabledGroups).filter(groupName => enabledGroups[groupName].length > 0);
      const groupList = enabledGroupNames.sort().join(', ');

      const bobContent = `Today is ${currentDate} at ${currentTime}. Recognizable objects are ${groupList}.`;
      markdown += bobContent + '\n\n';

      // Sort groups by priority order (as they appear in dictionary.rules)
      const priorityOrder = dictionary.rules.map(rule => rule.label).filter(label => label);

      const sortedEnabledGroups = priorityOrder.filter(groupName =>
        enabledGroups[groupName] && enabledGroups[groupName].length > 0 && groupEnabledStatus[groupName] !== false
      );
      const sortedDisabledGroups = priorityOrder.filter(groupName =>
        (disabledGroups[groupName] && disabledGroups[groupName].length > 0) || groupEnabledStatus[groupName] === false
      );

      // Generate markdown for enabled groups first
      if (sortedEnabledGroups.length > 0) {
        markdown += '# Enabled Groups\n\n';

        sortedEnabledGroups.forEach(groupName => {
          const emoji = categoryEmojis[groupName] || '❓';
          markdown += `## ${emoji} ${groupName}\n\n`;

          // Sort objects within the group by label
          const sortedObjects = enabledGroups[groupName].sort((a, b) => {
            const labelA = (a.label || '').toLowerCase();
            const labelB = (b.label || '').toLowerCase();
            return labelA.localeCompare(labelB);
          });

          // Add objects to the group
          sortedObjects.forEach(obj => {
            const label = obj.label || obj.match;
            const matchString = obj.match;
            markdown += `- ${label} | ${matchString}\n`;
          });

          markdown += '\n';
        });
      }

      // Generate markdown for disabled groups
      if (sortedDisabledGroups.length > 0) {
        markdown += '# Disabled Groups\n\n';

        sortedDisabledGroups.forEach(groupName => {
          const emoji = categoryEmojis[groupName] || '❓';
          markdown += `## ${emoji} ${groupName}\n\n`;

          // Get all objects for this group (both enabled and disabled objects from disabled groups)
          let allGroupObjects = [];
          if (enabledGroups[groupName]) {
            allGroupObjects = allGroupObjects.concat(enabledGroups[groupName]);
          }
          if (disabledGroups[groupName]) {
            allGroupObjects = allGroupObjects.concat(disabledGroups[groupName]);
          }

          // Sort objects within the group by label
          const sortedObjects = allGroupObjects.sort((a, b) => {
            const labelA = (a.label || '').toLowerCase();
            const labelB = (b.label || '').toLowerCase();
            return labelA.localeCompare(labelB);
          });

          // Add objects to the group
          sortedObjects.forEach(obj => {
            const label = obj.label || obj.match;
            const matchString = obj.match;
            markdown += `- ${label} | ${matchString}\n`;
          });

          markdown += '\n';
        });
      }

      // Append sample.md content
      try {
        const sampleResponse = await fetch('sample.md');
        if (sampleResponse.ok) {
          const sampleContent = await sampleResponse.text();
          markdown += '\n' + sampleContent;
        }
      } catch (error) {
        console.warn('Could not load sample.md:', error);
      }

      // Set the markdown in the textarea
      document.getElementById('sourceText').value = markdown;
      applyRules();
    }

    // Function to get object style combining object colors with group styles
    function getObjectStyleWithGroupStyles(obj) {
      // Find the group for this object
      const group = dictionary.rules.find(rule => rule.label === obj.group);
      if (!group) {
        return getObjectPreviewStyle(obj); // Fallback to object-only style
      }

      // Create a combined object with group styles
      const combinedObj = {
        color1: obj.color1 || '',
        color2: obj.color2 || '',
        style1: group.style1 || '',
        style2: group.style2 || ''
      };

      return getObjectPreviewStyle(combinedObj);
    }
  </script>
</body>

</html>