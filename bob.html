<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Text Parser & Colorizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif;
      padding: 1rem;
      max-width: 900px;
      margin: auto;
    }

    textarea {
      width: 100%;
      height: 120px;
      font-family: monospace;
    }

    .preview {
      border: 1px solid #ccc;
      padding: 0.5rem;
      min-height: 100px;
      white-space: pre-wrap;
    }

    .word {
      padding: 2px 3px;
      border-radius: 3px;
      display: inline-block;
      margin: 1px;
    }

    .rule-row {
      display: flex;
      gap: 0;
      margin-bottom: 0;
      flex-wrap: wrap;
    }

    .small {
      font-size: 0.75rem;
      color: #555;
    }

    .flex {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      cursor: pointer;
      border-radius: 5px;
      background: #007aff;
      color: white;
      font-weight: 600;
    }

    .btn-secondary {
      background: #555;
    }

    input,
    select {
      padding: 6px;
    }

    .code {
      background: #f5f5f5;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: monospace;
    }

    .inline-form {
      display: none;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      margin: 0.5rem 0;
      animation: slideDown 0.2s ease-out;
    }

    .inline-form.show {
      display: block;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .inline-form-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .inline-form-row label {
      font-weight: 500;
      min-width: 80px;
    }

    .inline-form-row input {
      flex: 1;
      min-width: 120px;
    }

    .inline-form-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      margin-top: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.5rem;
      font-size: 0.875rem;
    }

    .btn-success {
      background: #28a745;
    }

    .btn-danger {
      background: #dc3545;
    }

    .custom-toggle-container {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin: 0.25rem 0;
    }

    .toggle-button {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.5rem 0.75rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.875rem;
      transition: background-color 0.2s;
    }

    .toggle-button.active {
      background: #28a745;
      color: white;
    }

    .toggle-button.inactive {
      background: #555;
      color: white;
    }

    .toggle-delete {
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      margin-left: 0.25rem;
    }

    .list-container {
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 1rem;
      background: #f8f9fa;
    }

    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #dee2e6;
    }

    .list-title {
      font-weight: 600;
      font-size: 1.1rem;
      margin: 0;
    }

    .list-type {
      font-size: 0.75rem;
      color: #6c757d;
      background: #e9ecef;
      padding: 0.25rem 0.5rem;
      border-radius: 3px;
    }

    .list-content {
      margin-top: 0.5rem;
    }

    .key-value-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
      align-items: center;
    }

    .key-value-row input {
      flex: 1;
      min-width: 100px;
    }

    .array-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
      align-items: center;
    }

    .array-row input {
      flex: 1;
      min-width: 100px;
    }

    .list-actions {
      display: flex;
      gap: 0.25rem;
      margin-top: 0.5rem;
    }

    .btn-xs {
      padding: 0.125rem 0.25rem;
      font-size: 0.75rem;
    }

    /* Color button and panel styles */
    .color-btn {
      position: relative;
      border: 2px solid #dee2e6;
      transition: all 0.2s ease;
    }

    .color-btn:hover {
      border-color: #007aff;
    }

    #defaultColor1Panel,
    #defaultColor2Panel {
      position: absolute;
      top: 100%;
      left: 0;
      min-width: 250px;
      background: white;
      border: 1px solid #dee2e6;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    #defaultColor1Display,
    #defaultColor2Display {
      display: inline-block;
      max-width: 40px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: 600;
    }
  </style>
</head>

<body>
  <h1>Local Parser + Colorizer</h1>
  <p>Paste/OCR text, load or edit a dictionary of rules; results are rendered with colors. Export to Markdown or PDF.
  </p>

  <section>
    <h2>1. Input Text</h2>
    <textarea id="sourceText" placeholder="Paste OCR text here..."></textarea>
    <div style="margin-top:0.5rem;">
      <button class="btn" id="applyBtn">Apply Rules</button>
      <button class="btn btn-secondary" id="clearBtn">Clear</button>
    </div>
  </section>

  <section>
    <h2>2. Default Search Pattern</h2>
    <div style="margin-bottom:0.5rem;">
      <label>
        <input type="checkbox" id="defaultPatternEnabled" checked>
        Enable default search pattern
      </label>
    </div>
    <div id="defaultPatternContainer">
      <div class="rule-row" data-step="0">
        <select id="defaultLabel" style="width: 110px;">
          <option value="">ðŸ’œ</option>
        </select>
        <button id="defaultColor1Btn" class="btn btn-secondary color-btn"
          style="width: 60px; text-align: left; position: relative;">
          <span id="defaultColor1Display">magenta</span>
        </button>
        <button id="defaultColor2Btn" class="btn btn-secondary color-btn"
          style="width: 60px; text-align: left; position: relative;">
          <span id="defaultColor2Display">-</span>
        </button>
        <div id="defaultColor1Panel" class="inline-form">
          <div class="inline-form-row">
            <label for="defaultColor1Text">Color 1:</label>
            <input id="defaultColor1Text" type="text" placeholder="color (e.g. #ff0000)" value="magenta"
              style="flex: 1;" />
          </div>
          <div class="inline-form-row">
            <label for="defaultColor1Picker">Picker:</label>
            <input id="defaultColor1Picker" type="color" value="#ff00ff" style="width: 50px; height: 30px;" />
          </div>
          <div class="inline-form-actions">
            <button class="btn btn-success btn-small" id="applyDefaultColor1">Apply</button>
            <button class="btn btn-danger btn-small" id="cancelDefaultColor1">Cancel</button>
          </div>
        </div>
        <div id="defaultColor2Panel" class="inline-form">
          <div class="inline-form-row">
            <label for="defaultColor2Text">Color 2:</label>
            <input id="defaultColor2Text" type="text" placeholder="color (e.g. #ff0000)" value="" style="flex: 1;" />
          </div>
          <div class="inline-form-row">
            <label for="defaultColor2Picker">Picker:</label>
            <input id="defaultColor2Picker" type="color" value="#0000ff" style="width: 50px; height: 30px;" />
          </div>
          <div class="inline-form-actions">
            <button class="btn btn-success btn-small" id="applyDefaultColor2">Apply</button>
            <button class="btn btn-danger btn-small" id="cancelDefaultColor2">Cancel</button>
          </div>
        </div>
        <button class="btn btn-secondary wrapper-toggle" data-wrapper="start-anchor" data-active="false">^</button>
        <button class="btn btn-secondary" id="addPrependRegexToggle">+</button>
        <div id="prependTogglesContainer" style="display: flex; gap: 0; align-items: center;"></div>
        <input id="basePatternInput" placeholder="Base pattern (e.g. [A-Z])" value="[A-Z]{1,4}" style="width: 70px;" />
        <div id="appendTogglesContainer" style="display: flex; gap: 0; align-items: center;"></div>
        <button class="btn btn-secondary" id="addRegexToggle">+</button>
        <button class="btn btn-secondary wrapper-toggle" data-wrapper="word-boundary" data-active="false">\b</button>
        <button class="btn btn-secondary wrapper-toggle" data-wrapper="end-anchor" data-active="false">$</button>
      </div>

      <!-- Inline form for adding regex toggles -->
      <div id="inlineRegexForm" class="inline-form">
        <div class="inline-form-row">
          <label for="newRegexValue">Regex:</label>
          <input type="text" id="newRegexValue" placeholder="Enter regex string (e.g. [0-9]+)" />
          <button class="btn btn-secondary btn-small" id="togglePrependMode"
            title="Toggle between append (+) and prepend (^) mode">+</button>
        </div>
        <div class="inline-form-row">
          <label for="newRegexLabel">Label:</label>
          <input type="text" id="newRegexLabel" placeholder="Enter button label (e.g. Numbers)" />
        </div>
        <div class="inline-form-actions">
          <button class="btn btn-success btn-small" id="saveRegexToggle">Add Toggle</button>
          <button class="btn btn-danger btn-small" id="cancelRegexToggle">Cancel</button>
        </div>
      </div>
    </div>

    <div style="margin-top: 0.5rem;">
      <strong>Constructed Pattern:</strong> <code id="constructedPattern">[A-Z]{1,4}</code>
    </div>
    <div style="margin-top: 0.5rem;">
      <strong>Current Matches:</strong>
      <pre id="currentMatches" class="code" style="max-height:100px; overflow:auto; font-size: 0.875rem;"></pre>
    </div>
    <div style="margin-top: 0.5rem;">
      <strong>Reconstructed Pattern:</strong> <code id="reconstructedPattern" class="code"></code>
    </div>
    <p class="small">This pattern will be applied to any text that doesn't match other rules. Build your pattern
      progressively by adding wrappers to each step.</p>
  </section>

  <section>
    <h2>3. Dictionary / Rules</h2>
    <div>
      <button class="btn btn-secondary" id="loadBobJson">Load from Storage</button>
      <button class="btn btn-secondary" id="saveBobJson">Export to File</button>
    </div>
    <div style="margin-top:0.5rem;">
      <div id="rulesContainer"></div>
      <div style="margin-top:0.5rem;"><button class="btn" id="addRule">+ Add Rule</button></div>
    </div>
    <p class="small">Rules match words using JavaScript regular expressions (case-insensitive by default). First
      matching rule applies.</p>
  </section>

  <section>
    <h2>4. Preview</h2>
    <div style="margin-bottom:0.5rem;">
      <button class="btn" id="loadSampleMd">Load Sample.md</button>
      <button class="btn btn-secondary" id="refreshPreview">Refresh Preview</button>
    </div>
    <div class="preview" id="preview"></div>
  </section>

  <section>
    <h2>5. Export</h2>
    <div class="flex">
      <div>
        <label>Markdown filename: <input id="mdName" value="export.md"></label>
        <div style="margin-top:0.25rem;">
          <button class="btn" id="downloadMd">Download Markdown</button>
        </div>
      </div>
      <div>
        <label>PDF filename: <input id="pdfName" value="export.pdf"></label>
        <div style="margin-top:0.25rem;">
          <button class="btn" id="downloadPdf">Download PDF</button>
        </div>
      </div>
      <div>
        <div style="margin-bottom:4px;">Clipboard:</div>
        <button class="btn" id="copyHtml">Copy Styled HTML</button>
        <button class="btn" id="copyPlain">Copy Plain Text</button>
      </div>
    </div>
  </section>

  <section>
    <h2>6. Lists & Arrays Manager</h2>
    <div style="margin-bottom:0.5rem;">
      <button class="btn" id="addKeyValueList">+ Add Key-Value List</button>
      <button class="btn btn-secondary" id="addArray">+ Add Array</button>
    </div>
    <div id="listsContainer"></div>
    <p class="small">Manage lists of key:value pairs and arrays that sync with bob.json. Use these for storing
      configuration data, mappings, or any structured data.</p>
  </section>

  <section>
    <h2>7. Dictionary JSON</h2>
    <pre id="rawJson" class="code" style="max-height:200px; overflow:auto;"></pre>
  </section>

  <template id="ruleTemplate">
    <div class="rule-row">
      <input aria-label="match" placeholder="regex (e.g. ^[A-M])" class="match" />
      <input aria-label="color" type="text" placeholder="color (e.g. #ff0000 or red)" class="color" />
      <input aria-label="label" placeholder="label (optional)" class="label" />
      <button class="btn btn-secondary removeRule">âœ•</button>
    </div>
  </template>

  <!-- jsPDF from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    integrity="sha512-your-integrity-placeholder" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
    // minimal dictionary structure
    let dictionary = { rules: [] };

    // Default pattern JSON structure
    let defaultPattern = {
      label: "Default",
      color1: "magenta",
      color2: "",
      structure: {
        startAnchor: false,
        startWordBoundary: false,
        customPrependToggles: [],
        basePattern: "[A-Z]{1,4}",
        customAppendToggles: [],
        endWordBoundary: false,
        endAnchor: false
      }
    };

    // Function to load pattern hierarchy from localStorage or bob.json
    async function loadPatternHierarchy() {
      // First try to load from localStorage
      const localStorageData = localStorage.getItem('bobPatternHierarchy');
      if (localStorageData) {
        try {
          const data = JSON.parse(localStorageData);

          // Load default pattern
          if (data.defaultPattern) {
            defaultPattern = data.defaultPattern;
          }

          // Load dictionary
          if (data.dictionary) {
            dictionary = data.dictionary;
          }

          // Load lists and arrays data
          if (data.listsData) {
            listsData = data.listsData;
          }

          // Update UI
          updatePatternUI();
          refreshRuleUI();
          refreshListsUI();
          applyRules();

          console.log('Pattern hierarchy loaded from localStorage');
          return;
        } catch (error) {
          console.error('Error parsing localStorage data:', error);
        }
      }

      // Fallback to loading from bob.json file
      try {
        const response = await fetch('bob.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        // Load default pattern
        if (data.defaultPattern) {
          defaultPattern = data.defaultPattern;
        }

        // Load dictionary
        if (data.dictionary) {
          dictionary = data.dictionary;
        }

        // Load lists and arrays data
        if (data.listsData) {
          listsData = data.listsData;
        }

        // Update UI
        updatePatternUI();
        refreshRuleUI();
        refreshListsUI();
        applyRules();

        console.log('Pattern hierarchy loaded from bob.json');
      } catch (error) {
        console.error('Error loading bob.json:', error);
        // If neither localStorage nor file exists, start with empty data
        console.log('No existing data found, starting with empty configuration');
      }
    }

    // Function to save pattern hierarchy to localStorage (silent)
    function savePatternHierarchy() {
      try {
        const data = {
          defaultPattern: defaultPattern,
          dictionary: dictionary,
          listsData: listsData
        };

        // Save to localStorage for immediate syncing
        localStorage.setItem('bobPatternHierarchy', JSON.stringify(data));
        console.log('Pattern hierarchy saved to localStorage');
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }
    }

    // Function to export pattern hierarchy to file (with user interaction)
    async function exportPatternHierarchy() {
      try {
        const data = {
          defaultPattern: defaultPattern,
          dictionary: dictionary,
          listsData: listsData
        };

        // Try to use File System Access API for silent saving
        if ('showSaveFilePicker' in window) {
          try {
            const handle = await window.showSaveFilePicker({
              suggestedName: 'bob.json',
              types: [{
                description: 'JSON files',
                accept: { 'application/json': ['.json'] }
              }]
            });
            const writable = await handle.createWritable();
            await writable.write(JSON.stringify(data, null, 2));
            await writable.close();
            console.log('Pattern hierarchy exported to bob.json via File System Access API');
            return;
          } catch (e) {
            console.log('File System Access API failed, falling back to download');
          }
        }

        // Fallback to download method
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'bob.json';
        a.click();

        console.log('Pattern hierarchy exported to bob.json via download');
      } catch (error) {
        console.error('Error exporting bob.json:', error);
      }
    }

    // Function to auto-save pattern hierarchy
    function autoSavePatternHierarchy() {
      // Debounce the save operation
      clearTimeout(window.autoSaveTimeout);
      window.autoSaveTimeout = setTimeout(() => {
        savePatternHierarchy();
        // Show a brief visual indicator
        showSaveIndicator();
      }, 1000); // Save after 1 second of inactivity
    }

    // Function to show save indicator
    function showSaveIndicator() {
      // Create or update save indicator
      let indicator = document.getElementById('saveIndicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'saveIndicator';
        indicator.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #28a745;
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-size: 12px;
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.3s ease;
        `;
        document.body.appendChild(indicator);
      }

      indicator.textContent = 'âœ“ Saved';
      indicator.style.opacity = '1';

      // Hide after 2 seconds
      setTimeout(() => {
        indicator.style.opacity = '0';
      }, 2000);
    }

    function refreshRuleUI() {
      const container = document.getElementById('rulesContainer');
      container.innerHTML = '';
      dictionary.rules.forEach((r, idx) => {
        const tpl = document.getElementById('ruleTemplate');
        const node = tpl.content.cloneNode(true);
        const row = node.querySelector('.rule-row');
        row.dataset.idx = idx;
        row.querySelector('.match').value = r.match;
        row.querySelector('.color').value = r.color;
        row.querySelector('.label').value = r.label || '';
        row.querySelector('.removeRule').addEventListener('click', () => {
          dictionary.rules.splice(idx, 1);
          refreshRuleUI();
          applyRules();
          autoSavePatternHierarchy();
        });
        // live change
        ['match', 'color', 'label'].forEach(k => {
          row.querySelector('.' + k).addEventListener('input', () => {
            dictionary.rules[idx][k] = row.querySelector('.' + k).value;
            updateRawJson();
            autoSavePatternHierarchy();
          });
        });
        container.appendChild(node);
      });
      updateRawJson();
    }

    function updateRawJson() {
      document.getElementById('rawJson').textContent = JSON.stringify(dictionary, null, 2);
    }

    function applyRules() {
      const text = document.getElementById('sourceText').value || '';
      const words = text.split(/(\s+)/); // keep spaces
      const preview = document.getElementById('preview');
      preview.innerHTML = '';
      const elements = [];

      // Get default pattern settings
      const defaultEnabled = document.getElementById('defaultPatternEnabled').checked;
      const defaultPattern = buildPatternFromJSON();
      const defaultLabel = defaultPattern.label;

      // Find all matches for multi-word patterns first
      const multiWordMatches = new Set();

      // Check dictionary rules for multi-word patterns
      for (const rule of dictionary.rules) {
        if (rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              // Store the start and end positions of the match
              multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Check default pattern for multi-word patterns
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            // Store the start and end positions of the match
            multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      words.forEach((token, index) => {
        let cleaned = token;
        if (token.trim() === '') {
          preview.append(document.createTextNode(token));
          return;
        }
        let matched = null;

        // Calculate the position of this token in the original text
        const tokenStart = words.slice(0, index).join('').length;
        const tokenEnd = tokenStart + token.length;
        const tokenRange = `${tokenStart}-${tokenEnd}`;

        // Check if this token is part of a multi-word match
        let isPartOfMultiWordMatch = false;
        for (const matchRange of multiWordMatches) {
          const [matchStart, matchEnd] = matchRange.split('-').map(Number);
          // Check if this token overlaps with the match
          if (tokenStart < matchEnd && tokenEnd > matchStart) {
            isPartOfMultiWordMatch = true;
            break;
          }
        }

        // First check dictionary rules
        for (const rule of dictionary.rules) {
          try {
            const flags = 'i';
            let regex = new RegExp(rule.match, flags);

            // Check if pattern contains spaces (multi-word pattern)
            if (rule.match.includes(' ')) {
              // For multi-word patterns, check if this token is part of a match
              if (isPartOfMultiWordMatch) {
                matched = rule;
                break;
              }
            } else {
              // For single-word patterns, test against the current token
              if (regex.test(token)) {
                matched = rule;
                break;
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad regex', rule.match);
          }
        }

        // If no match found and default pattern is enabled, try default pattern
        if (!matched && defaultEnabled && defaultPattern) {
          try {
            const flags = 'i';
            let regex = new RegExp(defaultPattern.pattern, flags);

            // Check if pattern contains spaces (multi-word pattern)
            if (defaultPattern.pattern.includes(' ')) {
              // For multi-word patterns, check if this token is part of a match
              if (isPartOfMultiWordMatch) {
                matched = {
                  color1: defaultPattern.color1,
                  color2: defaultPattern.color2,
                  label: defaultPattern.label
                };
              }
            } else {
              // For single-word patterns, test against the current token
              if (regex.test(token)) {
                matched = {
                  color1: defaultPattern.color1,
                  color2: defaultPattern.color2,
                  label: defaultPattern.label
                };
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad default regex', defaultPattern.pattern);
          }
        }

        const span = document.createElement('span');
        span.textContent = token;
        span.className = 'word';
        if (matched) {
          // Handle gradient if two colors are present
          if (matched.color1 && matched.color2 && matched.color2.trim() !== '') {
            // Create gradient background
            span.style.background = `linear-gradient(90deg, ${matched.color1}, ${matched.color2})`;
            span.style.color = getContrastColor(matched.color1); // Use contrast from first color
            span.style.padding = '2px 4px';
            span.style.borderRadius = '3px';
          } else if (matched.color1) {
            // Single color - use text color
            span.style.color = matched.color1;
          }
          span.title = matched.label || '';
        } else {
          span.style.color = 'inherit';
        }
        preview.appendChild(span);
      });

      // Update current matches display
      const matchesDisplay = document.getElementById('currentMatches');
      if (matchesDisplay) {
        const matches = findCurrentMatches();
        matchesDisplay.textContent = matches.length > 0 ? matches.join(', ') : 'No matches found';
      }
    }

    function downloadMarkdown() {
      const text = document.getElementById('sourceText').value || '';
      // Build markdown with inline color hints using HTML spans
      const previewDiv = document.getElementById('preview');
      let md = '';
      // Iterate over children to preserve spaces
      previewDiv.childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          md += node.textContent;
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const span = node;
          const word = span.textContent;
          const bg = span.style.background;
          const label = span.title;
          if (bg || label) {
            // use inline HTML for color
            md += `<span style="background:${bg}">${word}</span>`;
          } else {
            md += word;
          }
        }
      });
      const blob = new Blob([md], { type: 'text/markdown' });
      const name = document.getElementById('mdName').value || 'export.md';
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.click();
    }

    async function downloadPDF() {
      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        alert('jsPDF not loaded');
        return;
      }
      const pdf = new jsPDF();
      const preview = document.getElementById('preview');
      // Simplest: convert text content with minimal styling
      const lines = [];
      preview.childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          lines.push(node.textContent);
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          let word = node.textContent;
          // add markers for colored
          if (node.style.background) {
            word = `[${word}]`;
          }
          lines.push(word);
        }
      });
      const full = lines.join('');
      // split to fit
      const pageWidth = pdf.internal.pageSize.getWidth();
      const margin = 10;
      const usableWidth = pageWidth - margin * 2;
      const split = pdf.splitTextToSize(full, usableWidth);
      pdf.text(split, margin, 20);
      const name = document.getElementById('pdfName').value || 'export.pdf';
      pdf.save(name);
    }

    function copyStyledHTML() {
      const preview = document.getElementById('preview');
      navigator.clipboard.write([
        new ClipboardItem({
          'text/html': new Blob([preview.innerHTML], { type: 'text/html' }),
          'text/plain': new Blob([preview.textContent], { type: 'text/plain' })
        })
      ]).then(() => alert('Copied styled HTML to clipboard'));
    }

    function copyPlainText() {
      const preview = document.getElementById('preview');
      navigator.clipboard.writeText(preview.textContent).then(() => alert('Copied plain text'));
    }

    async function loadSampleMd() {
      try {
        const response = await fetch('sample.md');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const content = await response.text();
        document.getElementById('sourceText').value = content;
        applyRules();
      } catch (error) {
        console.error('Error loading sample.md:', error);
        alert('Error loading sample.md. Make sure the file exists in the same directory as this HTML file.');
      }
    }

    function refreshPreview() {
      applyRules();
    }

    function buildPatternFromJSON() {
      let pattern = '';

      // Add start anchor if present
      if (defaultPattern.structure.startAnchor) {
        pattern += '^';
      }

      // Add start word boundary if present
      if (defaultPattern.structure.startWordBoundary) {
        pattern += '\\b';
      }

      // Add custom prepend toggles
      defaultPattern.structure.customPrependToggles.forEach(toggle => {
        if (toggle.active) {
          pattern += toggle.regex;
        }
      });

      // Add base pattern
      pattern += defaultPattern.structure.basePattern;

      // Add custom append toggles
      defaultPattern.structure.customAppendToggles.forEach(toggle => {
        if (toggle.active) {
          pattern += toggle.regex;
        }
      });

      // Add end word boundary if present
      if (defaultPattern.structure.endWordBoundary) {
        pattern += '\\b';
      }

      // Add end anchor if present
      if (defaultPattern.structure.endAnchor) {
        pattern += '$';
      }

      return {
        pattern: pattern,
        color1: defaultPattern.color1,
        color2: defaultPattern.color2,
        label: defaultPattern.label
      };
    }

    function updatePatternUI() {
      // Update input fields
      const defaultLabelSelect = document.getElementById('defaultLabel');
      if (defaultLabelSelect) {
        defaultLabelSelect.value = defaultPattern.label;
      }
      updateDefaultColorButtons();
      document.getElementById('basePatternInput').value = defaultPattern.structure.basePattern;

      // Update wrapper button states
      const startAnchorBtn = document.querySelector('[data-wrapper="start-anchor"]');
      const wordBoundaryBtn = document.querySelector('[data-wrapper="word-boundary"]');
      const endAnchorBtn = document.querySelector('[data-wrapper="end-anchor"]');

      if (startAnchorBtn) {
        startAnchorBtn.dataset.active = defaultPattern.structure.startAnchor;
        startAnchorBtn.style.background = defaultPattern.structure.startAnchor ? '#28a745' : '#555';
      }

      if (wordBoundaryBtn) {
        wordBoundaryBtn.dataset.active = defaultPattern.structure.endWordBoundary;
        wordBoundaryBtn.style.background = defaultPattern.structure.endWordBoundary ? '#28a745' : '#555';
      }

      if (endAnchorBtn) {
        endAnchorBtn.dataset.active = defaultPattern.structure.endAnchor;
        endAnchorBtn.style.background = defaultPattern.structure.endAnchor ? '#28a745' : '#555';
      }

      // Update constructed pattern display
      const pattern = buildPatternFromJSON();
      const display = document.getElementById('constructedPattern');
      if (display) {
        display.textContent = pattern.pattern || '(empty)';
      }

      // Update current matches display
      const matchesDisplay = document.getElementById('currentMatches');
      if (matchesDisplay) {
        const matches = findCurrentMatches();
        matchesDisplay.textContent = matches.length > 0 ? matches.join(', ') : 'No matches found';
      }

      // Update reconstructed pattern display
      const reconstructedDisplay = document.getElementById('reconstructedPattern');
      if (reconstructedDisplay) {
        reconstructedDisplay.textContent = pattern || '(empty)';
      }

      // Update custom toggles display
      updateCustomTogglesDisplay();
    }

    function updateCustomTogglesDisplay() {
      // Update prepend toggles
      const prependContainer = document.getElementById('prependTogglesContainer');
      if (prependContainer) {
        prependContainer.innerHTML = '';
        defaultPattern.structure.customPrependToggles.forEach(toggle => {
          const toggleElement = createToggleElement(toggle, true);
          prependContainer.appendChild(toggleElement);
        });
      }

      // Update append toggles
      const appendContainer = document.getElementById('appendTogglesContainer');
      if (appendContainer) {
        appendContainer.innerHTML = '';
        defaultPattern.structure.customAppendToggles.forEach(toggle => {
          const toggleElement = createToggleElement(toggle, false);
          appendContainer.appendChild(toggleElement);
        });
      }
    }

    function createToggleElement(toggle, isPrepend) {
      const container = document.createElement('div');
      container.className = 'custom-toggle-container';

      // Main toggle button (label only)
      const toggleButton = document.createElement('button');
      toggleButton.className = `toggle-button ${toggle.active ? 'active' : 'inactive'}`;
      toggleButton.title = `Regex: ${toggle.regex}`;
      toggleButton.textContent = toggle.label;

      // Toggle functionality
      toggleButton.addEventListener('click', () => {
        toggleCustomToggle(toggle.id, isPrepend);
      });

      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'toggle-delete';
      deleteBtn.textContent = 'âœ•';
      deleteBtn.title = 'Delete toggle';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent triggering the toggle button
        deleteCustomToggle(toggle.id, isPrepend);
      });

      container.appendChild(toggleButton);
      container.appendChild(deleteBtn);

      return container;
    }

    function updatePatternWithAnchors(anchorType, addAnchor) {
      if (anchorType === 'start') {
        defaultPattern.structure.startAnchor = addAnchor;
      } else if (anchorType === 'end') {
        defaultPattern.structure.endAnchor = addAnchor;
      }
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function updatePatternWithWordBoundaries(addBoundaries) {
      defaultPattern.structure.startWordBoundary = addBoundaries;
      defaultPattern.structure.endWordBoundary = addBoundaries;
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function updatePatternWithRegexToggle(regex, isPrepend, addRegex, label = 'Custom Toggle') {
      if (addRegex) {
        const toggleInfo = {
          id: Date.now().toString(),
          label: label,
          regex: regex,
          position: isPrepend ? 'prepend' : 'append',
          active: true
        };

        if (isPrepend) {
          defaultPattern.structure.customPrependToggles.push(toggleInfo);
        } else {
          defaultPattern.structure.customAppendToggles.push(toggleInfo);
        }
      } else {
        // Remove the regex from the appropriate array
        if (isPrepend) {
          defaultPattern.structure.customPrependToggles = defaultPattern.structure.customPrependToggles.filter(t => t.regex !== regex);
        } else {
          defaultPattern.structure.customAppendToggles = defaultPattern.structure.customAppendToggles.filter(t => t.regex !== regex);
        }
      }
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function toggleCustomToggle(toggleId, isPrepend) {
      const toggles = isPrepend ? defaultPattern.structure.customPrependToggles : defaultPattern.structure.customAppendToggles;
      const toggle = toggles.find(t => t.id === toggleId);
      if (toggle) {
        toggle.active = !toggle.active;
        updatePatternUI();
        applyRules();
        autoSavePatternHierarchy();
      }
    }

    function deleteCustomToggle(toggleId, isPrepend) {
      if (isPrepend) {
        defaultPattern.structure.customPrependToggles = defaultPattern.structure.customPrependToggles.filter(t => t.id !== toggleId);
      } else {
        defaultPattern.structure.customAppendToggles = defaultPattern.structure.customAppendToggles.filter(t => t.id !== toggleId);
      }
      updatePatternUI();
      applyRules();
      autoSavePatternHierarchy();
    }

    function buildPatternHierarchy() {
      const pattern = buildDefaultPattern();
      const defaultLabel = document.getElementById('defaultLabel').value;
      const defaultColor = document.getElementById('defaultColor').value;

      const hierarchy = {
        pattern: pattern,
        label: defaultLabel,
        color: defaultColor,
        structure: {
          startAnchor: false,
          startWordBoundary: false,
          customPrependToggles: [],
          basePattern: '',
          customAppendToggles: [],
          endWordBoundary: false,
          endAnchor: false
        }
      };

      // Get the base pattern from the input field (without custom toggles)
      const patternInput = document.querySelector('#defaultPatternContainer .default-pattern-step');
      let basePattern = patternInput.value;

      // Remove any custom toggles from the base pattern for analysis
      const activeToggles = document.querySelectorAll('.regex-toggle[data-active="true"]');
      activeToggles.forEach(toggle => {
        const regex = toggle.dataset.regex;
        const isPrepend = toggle.dataset.prepend === 'true';

        if (isPrepend) {
          // Remove prepend toggles from the beginning (after any anchors/word boundaries)
          if (basePattern.startsWith('^\\b') && basePattern.substring(3).startsWith(regex)) {
            // Start anchor + word boundary + regex
            basePattern = `^\\b${basePattern.substring(3 + regex.length)}`;
          } else if (basePattern.startsWith('^') && basePattern.substring(1).startsWith(regex)) {
            // Start anchor + regex
            basePattern = `^${basePattern.substring(1 + regex.length)}`;
          } else if (basePattern.startsWith('\\b') && basePattern.substring(2).startsWith(regex)) {
            // Word boundary + regex
            basePattern = `\\b${basePattern.substring(2 + regex.length)}`;
          } else if (basePattern.startsWith(regex)) {
            // Just regex at start
            basePattern = basePattern.substring(regex.length);
          }
        } else {
          // Remove append toggles from the end (before any anchors/word boundaries)
          if (basePattern.endsWith('\\b$') && basePattern.substring(0, basePattern.length - 3).endsWith(regex)) {
            // Regex + word boundary + end anchor
            basePattern = `${basePattern.substring(0, basePattern.length - 3 - regex.length)}\\b$`;
          } else if (basePattern.endsWith('$') && basePattern.substring(0, basePattern.length - 1).endsWith(regex)) {
            // Regex + end anchor
            basePattern = `${basePattern.substring(0, basePattern.length - 1 - regex.length)}$`;
          } else if (basePattern.endsWith('\\b') && basePattern.substring(0, basePattern.length - 2).endsWith(regex)) {
            // Regex + word boundary
            basePattern = `${basePattern.substring(0, basePattern.length - 2 - regex.length)}\\b`;
          } else if (basePattern.endsWith(regex)) {
            // Just regex at end
            basePattern = basePattern.substring(0, basePattern.length - regex.length);
          }
        }
      });

      // Analyze the base pattern structure
      let remainingPattern = basePattern;

      // Check for start anchor
      if (remainingPattern.startsWith('^')) {
        hierarchy.structure.startAnchor = true;
        remainingPattern = remainingPattern.substring(1);
      }

      // Check for start word boundary
      if (remainingPattern.startsWith('\\b')) {
        hierarchy.structure.startWordBoundary = true;
        remainingPattern = remainingPattern.substring(2);
      }

      // Check for end anchor
      if (remainingPattern.endsWith('$')) {
        hierarchy.structure.endAnchor = true;
        remainingPattern = remainingPattern.substring(0, remainingPattern.length - 1);
      }

      // Check for end word boundary
      if (remainingPattern.endsWith('\\b')) {
        hierarchy.structure.endWordBoundary = true;
        remainingPattern = remainingPattern.substring(0, remainingPattern.length - 2);
      }

      // The remaining pattern is the true base pattern
      hierarchy.structure.basePattern = remainingPattern;

      // Add custom toggles to the hierarchy
      activeToggles.forEach(toggle => {
        const toggleInfo = {
          label: toggle.dataset.label,
          regex: toggle.dataset.regex,
          position: toggle.dataset.prepend === 'true' ? 'prepend' : 'append'
        };

        if (toggleInfo.position === 'prepend') {
          hierarchy.structure.customPrependToggles.push(toggleInfo);
        } else {
          hierarchy.structure.customAppendToggles.push(toggleInfo);
        }
      });

      return hierarchy;
    }

    function reconstructPatternFromHierarchy(hierarchy) {
      let reconstructedPattern = '';

      // Add start anchor if present
      if (hierarchy.structure.startAnchor) {
        reconstructedPattern += '^';
      }

      // Add start word boundary if present
      if (hierarchy.structure.startWordBoundary) {
        reconstructedPattern += '\\b';
      }

      // Add custom prepend toggles
      hierarchy.structure.customPrependToggles.forEach(toggle => {
        reconstructedPattern += toggle.regex;
      });

      // Add base pattern
      reconstructedPattern += hierarchy.structure.basePattern;

      // Add custom append toggles
      hierarchy.structure.customAppendToggles.forEach(toggle => {
        reconstructedPattern += toggle.regex;
      });

      // Add end word boundary if present
      if (hierarchy.structure.endWordBoundary) {
        reconstructedPattern += '\\b';
      }

      // Add end anchor if present
      if (hierarchy.structure.endAnchor) {
        reconstructedPattern += '$';
      }

      return reconstructedPattern;
    }

    function findCurrentMatches() {
      const text = document.getElementById('sourceText').value || '';
      const matches = [];

      // Get default pattern settings
      const defaultEnabled = document.getElementById('defaultPatternEnabled').checked;
      const defaultPattern = buildPatternFromJSON();

      // Split text the same way as applyRules() does
      const tokens = text.split(/(\s+)/); // keep spaces

      // Find all matches for multi-word patterns first
      const multiWordMatches = new Set();

      // Check dictionary rules for multi-word patterns
      for (const rule of dictionary.rules) {
        if (rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              // Store the start and end positions of the match
              multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Check default pattern for multi-word patterns
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            // Store the start and end positions of the match
            multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      // For multi-word patterns, we need to extract the actual matched phrases
      const matchedPhrases = new Set();

      // Extract matched phrases from dictionary rules
      for (const rule of dictionary.rules) {
        if (rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              matchedPhrases.add(match[0]);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Extract matched phrases from default pattern
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            matchedPhrases.add(match[0]);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      // Add multi-word matched phrases
      matchedPhrases.forEach(phrase => {
        matches.push(phrase);
      });

      // Process individual tokens for single-word patterns
      tokens.forEach((token, index) => {
        if (token.trim() === '') {
          return; // Skip empty tokens
        }

        let matched = false;

        // Calculate the position of this token in the original text
        const tokenStart = tokens.slice(0, index).join('').length;
        const tokenEnd = tokenStart + token.length;

        // Check if this token is part of a multi-word match
        let isPartOfMultiWordMatch = false;
        for (const matchRange of multiWordMatches) {
          const [matchStart, matchEnd] = matchRange.split('-').map(Number);
          // Check if this token overlaps with the match
          if (tokenStart < matchEnd && tokenEnd > matchStart) {
            isPartOfMultiWordMatch = true;
            break;
          }
        }

        // Skip tokens that are part of multi-word matches (we already added the full phrases)
        if (isPartOfMultiWordMatch) {
          return;
        }

        // First check dictionary rules
        for (const rule of dictionary.rules) {
          try {
            const flags = 'i';
            let regex = new RegExp(rule.match, flags);

            // Only check single-word patterns here
            if (!rule.match.includes(' ')) {
              const match = token.match(regex);
              if (match) {
                matches.push(match[0]);
                matched = true;
                break;
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad regex', rule.match);
          }
        }

        // If no match found and default pattern is enabled, try default pattern
        if (!matched && defaultEnabled && defaultPattern) {
          try {
            const flags = 'i';
            let regex = new RegExp(defaultPattern.pattern, flags);

            // Only check single-word patterns here
            if (!defaultPattern.pattern.includes(' ')) {
              const match = token.match(regex);
              if (match) {
                matches.push(match[0]);
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad default regex', defaultPattern.pattern);
          }
        }
      });

      // Remove duplicates and return
      return [...new Set(matches)];
    }

    function updateConstructedPatternDisplay() {
      const pattern = buildPatternFromJSON();
      const display = document.getElementById('constructedPattern');
      if (display) {
        display.textContent = pattern.pattern || '(empty)';
      }

      // Update current matches display
      const matchesDisplay = document.getElementById('currentMatches');
      if (matchesDisplay) {
        const matches = findCurrentMatches();
        matchesDisplay.textContent = matches.length > 0 ? matches.join(', ') : 'No matches found';
      }

      // Update reconstructed pattern display
      const hierarchy = buildPatternHierarchy();
      const reconstructedPattern = reconstructPatternFromHierarchy(hierarchy);
      const reconstructedDisplay = document.getElementById('reconstructedPattern');
      if (reconstructedDisplay) {
        reconstructedDisplay.textContent = reconstructedPattern || '(empty)';
      }
    }



    function setupStepEventListeners(stepElement) {
      const input = stepElement.querySelector('#basePatternInput');
      const wrapperBtns = stepElement.querySelectorAll('.wrapper-toggle');

      input.addEventListener('input', () => {
        defaultPattern.structure.basePattern = input.value;
        updatePatternUI();
        applyRules();
        autoSavePatternHierarchy();
      });

      wrapperBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const wrapper = btn.dataset.wrapper;
          const isActive = btn.dataset.active === 'true';

          switch (wrapper) {
            case 'word-boundary':
              updatePatternWithWordBoundaries(!isActive);
              break;
            case 'start-anchor':
              updatePatternWithAnchors('start', !isActive);
              break;
            case 'end-anchor':
              updatePatternWithAnchors('end', !isActive);
              break;
          }
          applyRules();
        });
      });
    }



    function showInlineRegexForm(prependMode = false) {
      const form = document.getElementById('inlineRegexForm');
      const regexInput = document.getElementById('newRegexValue');
      const labelInput = document.getElementById('newRegexLabel');
      const prependToggle = document.getElementById('togglePrependMode');

      // Clear previous values
      regexInput.value = '';
      labelInput.value = '';

      // Set prepend mode based on parameter
      prependToggle.textContent = prependMode ? '^' : '+';
      prependToggle.dataset.mode = prependMode ? 'prepend' : 'append';

      // Show the form with animation
      form.classList.add('show');

      // Focus on the first input
      regexInput.focus();
    }

    function hideInlineRegexForm() {
      const form = document.getElementById('inlineRegexForm');
      form.classList.remove('show');
    }

    function addRegexToggle() {
      const regexValue = document.getElementById('newRegexValue').value.trim();
      const label = document.getElementById('newRegexLabel').value.trim();
      const prependMode = document.getElementById('togglePrependMode').dataset.mode === 'prepend';

      if (!regexValue || !label) {
        alert('Please fill in both regex value and label');
        return;
      }

      // Add to JSON structure with the user-provided label
      updatePatternWithRegexToggle(regexValue, prependMode, true, label);

      // Hide the form
      hideInlineRegexForm();

      applyRules();
      autoSavePatternHierarchy();
    }

    function setupAddRegexToggleListener() {
      const addButton = document.getElementById('addRegexToggle');
      const saveButton = document.getElementById('saveRegexToggle');
      const cancelButton = document.getElementById('cancelRegexToggle');
      const prependToggle = document.getElementById('togglePrependMode');

      if (addButton) {
        addButton.addEventListener('click', () => showInlineRegexForm(false));
      }

      if (saveButton) {
        saveButton.addEventListener('click', addRegexToggle);
      }

      if (cancelButton) {
        cancelButton.addEventListener('click', hideInlineRegexForm);
      }

      if (prependToggle) {
        prependToggle.addEventListener('click', () => {
          const currentMode = prependToggle.dataset.mode;
          const newMode = currentMode === 'append' ? 'prepend' : 'append';
          prependToggle.dataset.mode = newMode;
          prependToggle.textContent = newMode === 'append' ? '+' : '^';
          prependToggle.title = newMode === 'append' ? 'Toggle between append (+) and prepend (^) mode' : 'Toggle between append (+) and prepend (^) mode';
        });
      }

      // Allow Enter key to submit the form
      const regexInput = document.getElementById('newRegexValue');
      const labelInput = document.getElementById('newRegexLabel');

      if (regexInput) {
        regexInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            addRegexToggle();
          }
        });
      }

      if (labelInput) {
        labelInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            addRegexToggle();
          }
        });
      }
    }

    document.getElementById('applyBtn').addEventListener('click', () => applyRules());
    document.getElementById('clearBtn').addEventListener('click', () => {
      document.getElementById('sourceText').value = '';
      applyRules();
    });
    document.getElementById('addRule').addEventListener('click', () => {
      dictionary.rules.push({ match: "", color: "", label: "", mode: "word" });
      refreshRuleUI();
      autoSavePatternHierarchy();
    });
    document.getElementById('downloadMd').addEventListener('click', downloadMarkdown);
    document.getElementById('downloadPdf').addEventListener('click', downloadPDF);
    document.getElementById('copyHtml').addEventListener('click', copyStyledHTML);
    document.getElementById('copyPlain').addEventListener('click', copyPlainText);


    // Add event listeners for bob.json operations
    document.getElementById('loadBobJson').addEventListener('click', loadPatternHierarchy);
    document.getElementById('saveBobJson').addEventListener('click', exportPatternHierarchy);

    // Default pattern event listeners
    document.getElementById('defaultPatternEnabled').addEventListener('change', applyRules);

    // Color button and panel functionality
    const defaultColor1Btn = document.getElementById('defaultColor1Btn');
    const defaultColor2Btn = document.getElementById('defaultColor2Btn');
    const defaultColor1Panel = document.getElementById('defaultColor1Panel');
    const defaultColor2Panel = document.getElementById('defaultColor2Panel');
    const defaultColor1Text = document.getElementById('defaultColor1Text');
    const defaultColor2Text = document.getElementById('defaultColor2Text');
    const defaultColor1Picker = document.getElementById('defaultColor1Picker');
    const defaultColor2Picker = document.getElementById('defaultColor2Picker');
    const defaultColor1Display = document.getElementById('defaultColor1Display');
    const defaultColor2Display = document.getElementById('defaultColor2Display');
    const applyDefaultColor1Btn = document.getElementById('applyDefaultColor1');
    const applyDefaultColor2Btn = document.getElementById('applyDefaultColor2');
    const cancelDefaultColor1Btn = document.getElementById('cancelDefaultColor1');
    const cancelDefaultColor2Btn = document.getElementById('cancelDefaultColor2');

    // Show/hide color panels
    defaultColor1Btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const isVisible = defaultColor1Panel.classList.contains('show');
      if (isVisible) {
        hideDefaultColorPanel(1);
      } else {
        showDefaultColorPanel(1);
      }
    });

    defaultColor2Btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const isVisible = defaultColor2Panel.classList.contains('show');
      if (isVisible) {
        hideDefaultColorPanel(2);
      } else {
        showDefaultColorPanel(2);
      }
    });

    // Hide panels when clicking outside
    document.addEventListener('click', (e) => {
      if (!defaultColor1Btn.contains(e.target) && !defaultColor1Panel.contains(e.target)) {
        hideDefaultColorPanel(1);
      }
      if (!defaultColor2Btn.contains(e.target) && !defaultColor2Panel.contains(e.target)) {
        hideDefaultColorPanel(2);
      }
    });

    // Sync color pickers with text inputs
    defaultColor1Text.addEventListener('input', () => {
      const color = defaultColor1Text.value;
      if (color.match(/^#[0-9A-Fa-f]{6}$/)) {
        defaultColor1Picker.value = color;
      }
    });

    defaultColor2Text.addEventListener('input', () => {
      const color = defaultColor2Text.value;
      if (color.match(/^#[0-9A-Fa-f]{6}$/)) {
        defaultColor2Picker.value = color;
      }
    });

    // Sync text inputs with color pickers
    defaultColor1Picker.addEventListener('input', () => {
      defaultColor1Text.value = defaultColor1Picker.value;
    });

    defaultColor2Picker.addEventListener('input', () => {
      defaultColor2Text.value = defaultColor2Picker.value;
    });

    // Allow Enter key to apply colors
    defaultColor1Text.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        applyDefaultColor1Btn.click();
      }
    });

    defaultColor2Text.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        applyDefaultColor2Btn.click();
      }
    });

    // Apply color changes
    applyDefaultColor1Btn.addEventListener('click', () => {
      const color = defaultColor1Text.value;
      defaultPattern.color1 = color;
      defaultColor1Display.textContent = color;
      updateDefaultColorButtons();
      updatePatternUI();
      applyRules();
      autoSavePatternHierarchy();
      hideDefaultColorPanel(1);
    });

    applyDefaultColor2Btn.addEventListener('click', () => {
      const color = defaultColor2Text.value;
      defaultPattern.color2 = color;
      defaultColor2Display.textContent = color || '-';
      updateDefaultColorButtons();
      updatePatternUI();
      applyRules();
      autoSavePatternHierarchy();
      hideDefaultColorPanel(2);
    });

    // Cancel color changes
    cancelDefaultColor1Btn.addEventListener('click', () => {
      hideDefaultColorPanel(1);
      // Reset to current value
      defaultColor1Text.value = defaultPattern.color1;
      defaultColor1Display.textContent = defaultPattern.color1;
    });

    cancelDefaultColor2Btn.addEventListener('click', () => {
      hideDefaultColorPanel(2);
      // Reset to current value
      defaultColor2Text.value = defaultPattern.color2;
      defaultColor2Display.textContent = defaultPattern.color2 || '-';
    });

    function showDefaultColorPanel(colorNum) {
      const panel = colorNum === 1 ? defaultColor1Panel : defaultColor2Panel;
      const textInput = colorNum === 1 ? defaultColor1Text : defaultColor2Text;
      const picker = colorNum === 1 ? defaultColor1Picker : defaultColor2Picker;
      const display = colorNum === 1 ? defaultColor1Display : defaultColor2Display;
      const color = colorNum === 1 ? defaultPattern.color1 : defaultPattern.color2;

      // Set current values
      textInput.value = color;
      display.textContent = color || '-';

      // Try to set color picker value if it's a hex color
      if (color && color.match(/^#[0-9A-Fa-f]{6}$/)) {
        picker.value = color;
      }

      panel.classList.add('show');
      textInput.focus();
    }

    function hideDefaultColorPanel(colorNum) {
      const panel = colorNum === 1 ? defaultColor1Panel : defaultColor2Panel;
      panel.classList.remove('show');
    }

    function updateDefaultColorButtons() {
      updateDefaultColorButton(1, defaultPattern.color1);
      updateDefaultColorButton(2, defaultPattern.color2);
    }

    function updateDefaultColorButton(colorNum, color) {
      const button = colorNum === 1 ? defaultColor1Btn : defaultColor2Btn;
      const display = colorNum === 1 ? defaultColor1Display : defaultColor2Display;

      if (button) {
        if (color && color.trim() !== '') {
          // Try to set the background color
          try {
            button.style.backgroundColor = color;
            // Ensure text is readable by setting appropriate text color
            button.style.color = getContrastColor(color);
            display.textContent = color;
          } catch (e) {
            // If color is invalid, reset to default
            button.style.backgroundColor = '';
            button.style.color = '';
            display.textContent = color || '-';
          }
        } else {
          // No color set, use default styling
          button.style.backgroundColor = '';
          button.style.color = '';
          display.textContent = '-';
        }
      }
    }

    function getContrastColor(color) {
      // Handle hex colors
      if (color.startsWith('#')) {
        const hex = color.replace('#', '');
        if (hex.length === 6) {
          // Convert to RGB
          const r = parseInt(hex.substr(0, 2), 16);
          const g = parseInt(hex.substr(2, 2), 16);
          const b = parseInt(hex.substr(4, 2), 16);

          // Calculate luminance
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

          // Return black or white based on luminance
          return luminance > 0.5 ? '#000000' : '#ffffff';
        }
      }

      // For non-hex colors, use a simple heuristic
      const colorLower = color.toLowerCase();
      if (colorLower === 'white' || colorLower === 'yellow' || colorLower === 'cyan' || colorLower === 'lightgray' || colorLower === 'lightgrey') {
        return '#000000';
      } else {
        return '#ffffff';
      }
    }

    // Setup event listeners after DOM is loaded
    function setupEventListeners() {
      const defaultLabelSelect = document.getElementById('defaultLabel');
      if (defaultLabelSelect) {
        defaultLabelSelect.addEventListener('change', () => {
          defaultPattern.label = document.getElementById('defaultLabel').value;
          updatePatternUI();
          applyRules();
          autoSavePatternHierarchy();
        });
      }
    }

    // Setup add regex toggle listener
    setupAddRegexToggleListener();

    // Add event listener for the new prepend "+" button
    document.getElementById('addPrependRegexToggle').addEventListener('click', () => showInlineRegexForm(true));

    // Preview buttons event listeners
    document.getElementById('loadSampleMd').addEventListener('click', loadSampleMd);
    document.getElementById('refreshPreview').addEventListener('click', refreshPreview);

    // Initialize first step event listeners
    setupStepEventListeners(document.querySelector('#defaultPatternContainer .rule-row'));

    // Initialize pattern UI
    updatePatternUI();

    // Load pattern hierarchy from bob.json on page load
    loadPatternHierarchy();

    // Setup event listeners after everything is loaded
    setupEventListeners();

    // Function to populate category dropdown
    function populateCategoryDropdown() {
      const dropdown = document.getElementById('defaultLabel');
      if (!dropdown) return;

      // Clear existing options except the first one
      while (dropdown.children.length > 1) {
        dropdown.removeChild(dropdown.lastChild);
      }

      // Find the categories list
      const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
      if (categoriesList && categoriesList.items) {
        categoriesList.items.forEach(item => {
          const option = document.createElement('option');
          option.value = item.key;
          option.textContent = `${item.value} ${item.key}`;
          dropdown.appendChild(option);
        });
      }
    }

    // Call populateCategoryDropdown after loading data
    async function loadPatternHierarchy() {
      // First try to load from localStorage
      const localStorageData = localStorage.getItem('bobPatternHierarchy');
      if (localStorageData) {
        try {
          const data = JSON.parse(localStorageData);

          // Load default pattern
          if (data.defaultPattern) {
            defaultPattern = data.defaultPattern;
          }

          // Load dictionary
          if (data.dictionary) {
            dictionary = data.dictionary;
          }

          // Load lists and arrays data
          if (data.listsData) {
            listsData = data.listsData;
          }

          // Update UI
          updatePatternUI();
          refreshRuleUI();
          refreshListsUI();
          populateCategoryDropdown();
          applyRules();
          setupEventListeners();

          console.log('Pattern hierarchy loaded from localStorage');
          return;
        } catch (error) {
          console.error('Error parsing localStorage data:', error);
        }
      }

      // Fallback to loading from bob.json file
      try {
        const response = await fetch('bob.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        // Load default pattern
        if (data.defaultPattern) {
          defaultPattern = data.defaultPattern;
        }

        // Load dictionary
        if (data.dictionary) {
          dictionary = data.dictionary;
        }

        // Load lists and arrays data
        if (data.listsData) {
          listsData = data.listsData;
        }

        // Update UI
        updatePatternUI();
        refreshRuleUI();
        refreshListsUI();
        populateCategoryDropdown();
        applyRules();
        setupEventListeners();

        console.log('Pattern hierarchy loaded from bob.json');
      } catch (error) {
        console.error('Error loading bob.json:', error);
        // If neither localStorage nor file exists, start with empty data
        console.log('No existing data found, starting with empty configuration');
      }
    }

    // Lists and Arrays Management
    let listsData = {
      keyValueLists: [],
      arrays: []
    };

    function refreshListsUI() {
      const container = document.getElementById('listsContainer');
      container.innerHTML = '';

      // Render key-value lists
      listsData.keyValueLists.forEach((list, listIndex) => {
        const listElement = createKeyValueListElement(list, listIndex);
        container.appendChild(listElement);
      });

      // Render arrays
      listsData.arrays.forEach((array, arrayIndex) => {
        const arrayElement = createArrayElement(array, arrayIndex);
        container.appendChild(arrayElement);
      });

      // Update category dropdown
      populateCategoryDropdown();
    }

    function createKeyValueListElement(list, listIndex) {
      const container = document.createElement('div');
      container.className = 'list-container';
      container.dataset.listIndex = listIndex;
      container.dataset.type = 'keyValue';

      const header = document.createElement('div');
      header.className = 'list-header';

      const title = document.createElement('h3');
      title.className = 'list-title';
      title.contentEditable = true;
      title.textContent = list.name || 'Key-Value List';
      title.addEventListener('blur', () => {
        list.name = title.textContent;
        autoSavePatternHierarchy();
      });

      const typeBadge = document.createElement('span');
      typeBadge.className = 'list-type';
      typeBadge.textContent = 'Key-Value';

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn btn-danger btn-xs';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', () => {
        listsData.keyValueLists.splice(listIndex, 1);
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      header.appendChild(title);
      header.appendChild(typeBadge);
      header.appendChild(deleteBtn);

      const content = document.createElement('div');
      content.className = 'list-content';

      // Render key-value pairs
      list.items.forEach((item, itemIndex) => {
        const row = document.createElement('div');
        row.className = 'key-value-row';

        const keyInput = document.createElement('input');
        keyInput.placeholder = 'Key';
        keyInput.value = item.key || '';
        keyInput.addEventListener('input', () => {
          item.key = keyInput.value;
          autoSavePatternHierarchy();
        });

        const valueInput = document.createElement('input');
        valueInput.placeholder = 'Value';
        valueInput.value = item.value || '';
        valueInput.addEventListener('input', () => {
          item.value = valueInput.value;
          autoSavePatternHierarchy();
        });

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-danger btn-xs';
        removeBtn.textContent = 'âœ•';
        removeBtn.addEventListener('click', () => {
          list.items.splice(itemIndex, 1);
          refreshListsUI();
          autoSavePatternHierarchy();
        });

        row.appendChild(keyInput);
        row.appendChild(valueInput);
        row.appendChild(removeBtn);
        content.appendChild(row);
      });

      const actions = document.createElement('div');
      actions.className = 'list-actions';

      const addItemBtn = document.createElement('button');
      addItemBtn.className = 'btn btn-secondary btn-xs';
      addItemBtn.textContent = '+ Add Item';
      addItemBtn.addEventListener('click', () => {
        list.items.push({ key: '', value: '' });
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      actions.appendChild(addItemBtn);
      content.appendChild(actions);

      container.appendChild(header);
      container.appendChild(content);

      return container;
    }

    function createArrayElement(array, arrayIndex) {
      const container = document.createElement('div');
      container.className = 'list-container';
      container.dataset.arrayIndex = arrayIndex;
      container.dataset.type = 'array';

      const header = document.createElement('div');
      header.className = 'list-header';

      const title = document.createElement('h3');
      title.className = 'list-title';
      title.contentEditable = true;
      title.textContent = array.name || 'Array';
      title.addEventListener('blur', () => {
        array.name = title.textContent;
        autoSavePatternHierarchy();
      });

      const typeBadge = document.createElement('span');
      typeBadge.className = 'list-type';
      typeBadge.textContent = 'Array';

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn btn-danger btn-xs';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', () => {
        listsData.arrays.splice(arrayIndex, 1);
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      header.appendChild(title);
      header.appendChild(typeBadge);
      header.appendChild(deleteBtn);

      const content = document.createElement('div');
      content.className = 'list-content';

      // Render array items
      array.items.forEach((item, itemIndex) => {
        const row = document.createElement('div');
        row.className = 'array-row';

        const valueInput = document.createElement('input');
        valueInput.placeholder = 'Value';
        valueInput.value = item || '';
        valueInput.addEventListener('input', () => {
          array.items[itemIndex] = valueInput.value;
          autoSavePatternHierarchy();
        });

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-danger btn-xs';
        removeBtn.textContent = 'âœ•';
        removeBtn.addEventListener('click', () => {
          array.items.splice(itemIndex, 1);
          refreshListsUI();
          autoSavePatternHierarchy();
        });

        row.appendChild(valueInput);
        row.appendChild(removeBtn);
        content.appendChild(row);
      });

      const actions = document.createElement('div');
      actions.className = 'list-actions';

      const addItemBtn = document.createElement('button');
      addItemBtn.className = 'btn btn-secondary btn-xs';
      addItemBtn.textContent = '+ Add Item';
      addItemBtn.addEventListener('click', () => {
        array.items.push('');
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      actions.appendChild(addItemBtn);
      content.appendChild(actions);

      container.appendChild(header);
      container.appendChild(content);

      return container;
    }

    // Event listeners for lists and arrays
    document.getElementById('addKeyValueList').addEventListener('click', () => {
      listsData.keyValueLists.push({
        name: 'New Key-Value List',
        items: [{ key: '', value: '' }]
      });
      refreshListsUI();
      autoSavePatternHierarchy();
    });

    document.getElementById('addArray').addEventListener('click', () => {
      listsData.arrays.push({
        name: 'New Array',
        items: ['']
      });
      refreshListsUI();
      autoSavePatternHierarchy();
    });
  </script>
</body>

</html>