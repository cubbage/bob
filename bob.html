<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Text Parser & Colorizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif;
      padding: 1rem;
      max-width: 900px;
      margin: auto;
    }

    textarea {
      width: 100%;
      height: 120px;
      font-family: monospace;
    }

    .preview {
      border: 1px solid #ccc;
      padding: 0.5rem;
      min-height: 100px;
      white-space: pre-wrap;
    }

    .word {
      padding: 2px 3px;
      border-radius: 3px;
      display: inline-block;
      margin: 1px;
    }

    .rule-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
      flex-wrap: wrap;
    }

    .small {
      font-size: 0.75rem;
      color: #555;
    }

    .flex {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      cursor: pointer;
      border-radius: 5px;
      background: #007aff;
      color: white;
      font-weight: 600;
    }

    .btn-secondary {
      background: #555;
    }

    input,
    select {
      padding: 6px;
    }

    .code {
      background: #f5f5f5;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: monospace;
    }

    .inline-form {
      display: none;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      margin: 0.5rem 0;
      animation: slideDown 0.2s ease-out;
    }

    .inline-form.show {
      display: block;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .inline-form-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .inline-form-row label {
      font-weight: 500;
      min-width: 80px;
    }

    .inline-form-row input {
      flex: 1;
      min-width: 120px;
    }

    .inline-form-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      margin-top: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.5rem;
      font-size: 0.875rem;
    }

    .btn-success {
      background: #28a745;
    }

    .btn-danger {
      background: #dc3545;
    }

    .custom-toggle-container {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin: 0.25rem 0;
    }

    .toggle-button {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.5rem 0.75rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.875rem;
      transition: background-color 0.2s;
    }

    .toggle-button.active {
      background: #28a745;
      color: white;
    }

    .toggle-button.inactive {
      background: #555;
      color: white;
    }

    .toggle-delete {
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      margin-left: 0.25rem;
    }

    .toggle-regex-tooltip {
      font-family: monospace;
      font-size: 0.75rem;
      color: #666;
      margin-left: 0.5rem;
    }
  </style>
</head>

<body>
  <h1>Local Parser + Colorizer</h1>
  <p>Paste/OCR text, load or edit a dictionary of rules; results are rendered with colors. Export to Markdown or PDF.
  </p>

  <section>
    <h2>1. Input Text</h2>
    <textarea id="sourceText" placeholder="Paste OCR text here..."></textarea>
    <div style="margin-top:0.5rem;">
      <button class="btn" id="applyBtn">Apply Rules</button>
      <button class="btn btn-secondary" id="clearBtn">Clear</button>
    </div>
  </section>

  <section>
    <h2>2. Default Search Pattern</h2>
    <div style="margin-bottom:0.5rem;">
      <label>
        <input type="checkbox" id="defaultPatternEnabled" checked>
        Enable default search pattern
      </label>
    </div>
    <div id="defaultPatternContainer">
      <div class="rule-row" data-step="0">
        <input id="defaultLabel" placeholder="label (optional)" value="Default" style="width: 100px;" />
        <input id="defaultColor" type="text" placeholder="color (e.g. #ff0000)" value="magenta" style="width: 120px;" />
        <button class="btn btn-secondary wrapper-toggle" data-wrapper="start-anchor" data-active="false">^</button>
        <button class="btn btn-secondary" id="addPrependRegexToggle">+</button>
        <input id="basePatternInput" placeholder="Base pattern (e.g. [A-Z])" value="[A-Z]{1,4}" style="flex: 1;" />
        <button class="btn btn-secondary" id="addRegexToggle">+</button>
        <button class="btn btn-secondary wrapper-toggle" data-wrapper="word-boundary" data-active="false">\b</button>
        <button class="btn btn-secondary wrapper-toggle" data-wrapper="end-anchor" data-active="false">$</button>
      </div>

      <!-- Inline form for adding regex toggles -->
      <div id="inlineRegexForm" class="inline-form">
        <div class="inline-form-row">
          <label for="newRegexValue">Regex:</label>
          <input type="text" id="newRegexValue" placeholder="Enter regex string (e.g. [0-9]+)" />
          <button class="btn btn-secondary btn-small" id="togglePrependMode"
            title="Toggle between append (+) and prepend (^) mode">+</button>
        </div>
        <div class="inline-form-row">
          <label for="newRegexLabel">Label:</label>
          <input type="text" id="newRegexLabel" placeholder="Enter button label (e.g. Numbers)" />
        </div>
        <div class="inline-form-actions">
          <button class="btn btn-success btn-small" id="saveRegexToggle">Add Toggle</button>
          <button class="btn btn-danger btn-small" id="cancelRegexToggle">Cancel</button>
        </div>
      </div>
    </div>

    <div style="margin-top: 0.5rem;">
      <strong>Constructed Pattern:</strong> <code id="constructedPattern">[A-Z]{1,4}</code>
    </div>
    <div style="margin-top: 0.5rem;">
      <strong>Pattern Hierarchy:</strong>
      <pre id="patternHierarchy" class="code" style="max-height:100px; overflow:auto; font-size: 0.875rem;"></pre>
    </div>
    <div style="margin-top: 0.5rem;">
      <strong>Reconstructed Pattern:</strong> <code id="reconstructedPattern" class="code"></code>
    </div>
    <div style="margin-top: 0.5rem;">
      <strong>Custom Toggles:</strong>
      <div id="customTogglesContainer"></div>
    </div>
    <p class="small">This pattern will be applied to any text that doesn't match other rules. Build your pattern
      progressively by adding wrappers to each step.</p>
  </section>

  <section>
    <h2>3. Dictionary / Rules</h2>
    <div>
      <button class="btn" id="loadSample">Load Sample Dictionary</button>
      <button class="btn btn-secondary" id="importJSON">Import JSON</button>
      <button class="btn btn-secondary" id="exportJSON">Export Current Dictionary</button>
    </div>
    <div style="margin-top:0.5rem;">
      <div id="rulesContainer"></div>
      <div style="margin-top:0.5rem;"><button class="btn" id="addRule">+ Add Rule</button></div>
    </div>
    <p class="small">Rules match words using JavaScript regular expressions (case-insensitive by default). First
      matching rule applies.</p>
  </section>

  <section>
    <h2>4. Preview</h2>
    <div style="margin-bottom:0.5rem;">
      <button class="btn" id="loadSampleMd">Load Sample.md</button>
      <button class="btn btn-secondary" id="refreshPreview">Refresh Preview</button>
    </div>
    <div class="preview" id="preview"></div>
  </section>

  <section>
    <h2>5. Export</h2>
    <div class="flex">
      <div>
        <label>Markdown filename: <input id="mdName" value="export.md"></label>
        <div style="margin-top:0.25rem;">
          <button class="btn" id="downloadMd">Download Markdown</button>
        </div>
      </div>
      <div>
        <label>PDF filename: <input id="pdfName" value="export.pdf"></label>
        <div style="margin-top:0.25rem;">
          <button class="btn" id="downloadPdf">Download PDF</button>
        </div>
      </div>
      <div>
        <div style="margin-bottom:4px;">Clipboard:</div>
        <button class="btn" id="copyHtml">Copy Styled HTML</button>
        <button class="btn" id="copyPlain">Copy Plain Text</button>
      </div>
    </div>
  </section>

  <section>
    <h2>6. Dictionary JSON</h2>
    <pre id="rawJson" class="code" style="max-height:200px; overflow:auto;"></pre>
  </section>

  <template id="ruleTemplate">
    <div class="rule-row">
      <input aria-label="match" placeholder="regex (e.g. ^[A-M])" class="match" />
      <input aria-label="color" type="text" placeholder="color (e.g. #ff0000 or red)" class="color" />
      <input aria-label="label" placeholder="label (optional)" class="label" />
      <button class="btn btn-secondary removeRule">✕</button>
    </div>
  </template>

  <!-- jsPDF from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    integrity="sha512-your-integrity-placeholder" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
    // minimal dictionary structure
    let dictionary = { rules: [] };

    // Default pattern JSON structure
    let defaultPattern = {
      label: "Default",
      color: "magenta",
      structure: {
        startAnchor: false,
        startWordBoundary: false,
        customPrependToggles: [],
        basePattern: "[A-Z]{1,4}",
        customAppendToggles: [],
        endWordBoundary: false,
        endAnchor: false
      }
    };

    function refreshRuleUI() {
      const container = document.getElementById('rulesContainer');
      container.innerHTML = '';
      dictionary.rules.forEach((r, idx) => {
        const tpl = document.getElementById('ruleTemplate');
        const node = tpl.content.cloneNode(true);
        const row = node.querySelector('.rule-row');
        row.dataset.idx = idx;
        row.querySelector('.match').value = r.match;
        row.querySelector('.color').value = r.color;
        row.querySelector('.label').value = r.label || '';
        row.querySelector('.removeRule').addEventListener('click', () => {
          dictionary.rules.splice(idx, 1);
          refreshRuleUI();
          applyRules();
        });
        // live change
        ['match', 'color', 'label'].forEach(k => {
          row.querySelector('.' + k).addEventListener('input', () => {
            dictionary.rules[idx][k] = row.querySelector('.' + k).value;
            updateRawJson();
          });
        });
        container.appendChild(node);
      });
      updateRawJson();
    }

    function updateRawJson() {
      document.getElementById('rawJson').textContent = JSON.stringify(dictionary, null, 2);
    }

    function applyRules() {
      const text = document.getElementById('sourceText').value || '';
      const words = text.split(/(\s+)/); // keep spaces
      const preview = document.getElementById('preview');
      preview.innerHTML = '';
      const elements = [];

      // Get default pattern settings
      const defaultEnabled = document.getElementById('defaultPatternEnabled').checked;
      const defaultPattern = buildPatternFromJSON();
      const defaultColor = defaultPattern.color;
      const defaultLabel = defaultPattern.label;

      words.forEach(token => {
        let cleaned = token;
        if (token.trim() === '') {
          preview.append(document.createTextNode(token));
          return;
        }
        let matched = null;

        // First check dictionary rules
        for (const rule of dictionary.rules) {
          try {
            const flags = 'i';
            let regex = new RegExp(rule.match, flags);
            if (regex.test(token)) {
              matched = rule;
              break;
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad regex', rule.match);
          }
        }

        // If no match found and default pattern is enabled, try default pattern
        if (!matched && defaultEnabled && defaultPattern) {
          try {
            const flags = 'i';
            let regex = new RegExp(defaultPattern, flags);
            if (regex.test(token)) {
              matched = { color: defaultColor, label: defaultLabel };
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad default regex', defaultPattern);
          }
        }

        const span = document.createElement('span');
        span.textContent = token;
        span.className = 'word';
        if (matched) {
          span.style.color = matched.color || '';
          span.title = matched.label || '';
        } else {
          span.style.color = 'inherit';
        }
        preview.appendChild(span);
      });
    }

    function downloadMarkdown() {
      const text = document.getElementById('sourceText').value || '';
      // Build markdown with inline color hints using HTML spans
      const previewDiv = document.getElementById('preview');
      let md = '';
      // Iterate over children to preserve spaces
      previewDiv.childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          md += node.textContent;
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const span = node;
          const word = span.textContent;
          const bg = span.style.background;
          const label = span.title;
          if (bg || label) {
            // use inline HTML for color
            md += `<span style="background:${bg}">${word}</span>`;
          } else {
            md += word;
          }
        }
      });
      const blob = new Blob([md], { type: 'text/markdown' });
      const name = document.getElementById('mdName').value || 'export.md';
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.click();
    }

    async function downloadPDF() {
      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        alert('jsPDF not loaded');
        return;
      }
      const pdf = new jsPDF();
      const preview = document.getElementById('preview');
      // Simplest: convert text content with minimal styling
      const lines = [];
      preview.childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          lines.push(node.textContent);
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          let word = node.textContent;
          // add markers for colored
          if (node.style.background) {
            word = `[${word}]`;
          }
          lines.push(word);
        }
      });
      const full = lines.join('');
      // split to fit
      const pageWidth = pdf.internal.pageSize.getWidth();
      const margin = 10;
      const usableWidth = pageWidth - margin * 2;
      const split = pdf.splitTextToSize(full, usableWidth);
      pdf.text(split, margin, 20);
      const name = document.getElementById('pdfName').value || 'export.pdf';
      pdf.save(name);
    }

    function copyStyledHTML() {
      const preview = document.getElementById('preview');
      navigator.clipboard.write([
        new ClipboardItem({
          'text/html': new Blob([preview.innerHTML], { type: 'text/html' }),
          'text/plain': new Blob([preview.textContent], { type: 'text/plain' })
        })
      ]).then(() => alert('Copied styled HTML to clipboard'));
    }

    function copyPlainText() {
      const preview = document.getElementById('preview');
      navigator.clipboard.writeText(preview.textContent).then(() => alert('Copied plain text'));
    }

    async function loadSampleMd() {
      try {
        const response = await fetch('sample.md');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const content = await response.text();
        document.getElementById('sourceText').value = content;
        applyRules();
      } catch (error) {
        console.error('Error loading sample.md:', error);
        alert('Error loading sample.md. Make sure the file exists in the same directory as this HTML file.');
      }
    }

    function refreshPreview() {
      applyRules();
    }

    function buildPatternFromJSON() {
      let pattern = '';

      // Add start anchor if present
      if (defaultPattern.structure.startAnchor) {
        pattern += '^';
      }

      // Add start word boundary if present
      if (defaultPattern.structure.startWordBoundary) {
        pattern += '\\b';
      }

      // Add custom prepend toggles
      defaultPattern.structure.customPrependToggles.forEach(toggle => {
        if (toggle.active) {
          pattern += toggle.regex;
        }
      });

      // Add base pattern
      pattern += defaultPattern.structure.basePattern;

      // Add custom append toggles
      defaultPattern.structure.customAppendToggles.forEach(toggle => {
        if (toggle.active) {
          pattern += toggle.regex;
        }
      });

      // Add end word boundary if present
      if (defaultPattern.structure.endWordBoundary) {
        pattern += '\\b';
      }

      // Add end anchor if present
      if (defaultPattern.structure.endAnchor) {
        pattern += '$';
      }

      return pattern;
    }

    function updatePatternUI() {
      // Update input fields
      document.getElementById('defaultLabel').value = defaultPattern.label;
      document.getElementById('defaultColor').value = defaultPattern.color;
      document.getElementById('basePatternInput').value = defaultPattern.structure.basePattern;

      // Update wrapper button states
      const startAnchorBtn = document.querySelector('[data-wrapper="start-anchor"]');
      const wordBoundaryBtn = document.querySelector('[data-wrapper="word-boundary"]');
      const endAnchorBtn = document.querySelector('[data-wrapper="end-anchor"]');

      if (startAnchorBtn) {
        startAnchorBtn.dataset.active = defaultPattern.structure.startAnchor;
        startAnchorBtn.style.background = defaultPattern.structure.startAnchor ? '#28a745' : '#555';
      }

      if (wordBoundaryBtn) {
        wordBoundaryBtn.dataset.active = defaultPattern.structure.endWordBoundary;
        wordBoundaryBtn.style.background = defaultPattern.structure.endWordBoundary ? '#28a745' : '#555';
      }

      if (endAnchorBtn) {
        endAnchorBtn.dataset.active = defaultPattern.structure.endAnchor;
        endAnchorBtn.style.background = defaultPattern.structure.endAnchor ? '#28a745' : '#555';
      }

      // Update constructed pattern display
      const pattern = buildPatternFromJSON();
      const display = document.getElementById('constructedPattern');
      if (display) {
        display.textContent = pattern || '(empty)';
      }

      // Update pattern hierarchy display
      const hierarchyDisplay = document.getElementById('patternHierarchy');
      if (hierarchyDisplay) {
        hierarchyDisplay.textContent = JSON.stringify(defaultPattern, null, 2);
      }

      // Update reconstructed pattern display
      const reconstructedDisplay = document.getElementById('reconstructedPattern');
      if (reconstructedDisplay) {
        reconstructedDisplay.textContent = pattern || '(empty)';
      }

      // Update custom toggles display
      updateCustomTogglesDisplay();
    }

    function updateCustomTogglesDisplay() {
      const container = document.getElementById('customTogglesContainer');
      if (!container) return;

      container.innerHTML = '';

      // Render prepend toggles
      if (defaultPattern.structure.customPrependToggles.length > 0) {
        const prependSection = document.createElement('div');
        prependSection.innerHTML = '<strong>Prepend Toggles:</strong>';
        container.appendChild(prependSection);

        defaultPattern.structure.customPrependToggles.forEach(toggle => {
          const toggleElement = createToggleElement(toggle, true);
          container.appendChild(toggleElement);
        });
      }

      // Render append toggles
      if (defaultPattern.structure.customAppendToggles.length > 0) {
        const appendSection = document.createElement('div');
        appendSection.innerHTML = '<strong>Append Toggles:</strong>';
        container.appendChild(appendSection);

        defaultPattern.structure.customAppendToggles.forEach(toggle => {
          const toggleElement = createToggleElement(toggle, false);
          container.appendChild(toggleElement);
        });
      }

      if (defaultPattern.structure.customPrependToggles.length === 0 &&
        defaultPattern.structure.customAppendToggles.length === 0) {
        container.innerHTML = '<em>No custom toggles added yet.</em>';
      }
    }

    function createToggleElement(toggle, isPrepend) {
      const container = document.createElement('div');
      container.className = 'custom-toggle-container';

      // Main toggle button (label + regex tooltip)
      const toggleButton = document.createElement('button');
      toggleButton.className = `toggle-button ${toggle.active ? 'active' : 'inactive'}`;
      toggleButton.title = `Regex: ${toggle.regex}`;

      // Label text
      const labelText = document.createElement('span');
      labelText.textContent = toggle.label;

      // Regex tooltip
      const regexTooltip = document.createElement('span');
      regexTooltip.className = 'toggle-regex-tooltip';
      regexTooltip.textContent = `(${toggle.regex})`;

      toggleButton.appendChild(labelText);
      toggleButton.appendChild(regexTooltip);

      // Toggle functionality
      toggleButton.addEventListener('click', () => {
        toggleCustomToggle(toggle.id, isPrepend);
      });

      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'toggle-delete';
      deleteBtn.textContent = '✕';
      deleteBtn.title = 'Delete toggle';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent triggering the toggle button
        deleteCustomToggle(toggle.id, isPrepend);
      });

      container.appendChild(toggleButton);
      container.appendChild(deleteBtn);

      return container;
    }

    function updatePatternWithAnchors(anchorType, addAnchor) {
      if (anchorType === 'start') {
        defaultPattern.structure.startAnchor = addAnchor;
      } else if (anchorType === 'end') {
        defaultPattern.structure.endAnchor = addAnchor;
      }
      updatePatternUI();
    }

    function updatePatternWithWordBoundaries(addBoundaries) {
      defaultPattern.structure.startWordBoundary = addBoundaries;
      defaultPattern.structure.endWordBoundary = addBoundaries;
      updatePatternUI();
    }

    function updatePatternWithRegexToggle(regex, isPrepend, addRegex, label = 'Custom Toggle') {
      if (addRegex) {
        const toggleInfo = {
          id: Date.now().toString(),
          label: label,
          regex: regex,
          position: isPrepend ? 'prepend' : 'append',
          active: true
        };

        if (isPrepend) {
          defaultPattern.structure.customPrependToggles.push(toggleInfo);
        } else {
          defaultPattern.structure.customAppendToggles.push(toggleInfo);
        }
      } else {
        // Remove the regex from the appropriate array
        if (isPrepend) {
          defaultPattern.structure.customPrependToggles = defaultPattern.structure.customPrependToggles.filter(t => t.regex !== regex);
        } else {
          defaultPattern.structure.customAppendToggles = defaultPattern.structure.customAppendToggles.filter(t => t.regex !== regex);
        }
      }
      updatePatternUI();
    }

    function toggleCustomToggle(toggleId, isPrepend) {
      const toggles = isPrepend ? defaultPattern.structure.customPrependToggles : defaultPattern.structure.customAppendToggles;
      const toggle = toggles.find(t => t.id === toggleId);
      if (toggle) {
        toggle.active = !toggle.active;
        updatePatternUI();
        applyRules();
      }
    }

    function deleteCustomToggle(toggleId, isPrepend) {
      if (isPrepend) {
        defaultPattern.structure.customPrependToggles = defaultPattern.structure.customPrependToggles.filter(t => t.id !== toggleId);
      } else {
        defaultPattern.structure.customAppendToggles = defaultPattern.structure.customAppendToggles.filter(t => t.id !== toggleId);
      }
      updatePatternUI();
      applyRules();
    }

    function buildPatternHierarchy() {
      const pattern = buildDefaultPattern();
      const defaultLabel = document.getElementById('defaultLabel').value;
      const defaultColor = document.getElementById('defaultColor').value;

      const hierarchy = {
        pattern: pattern,
        label: defaultLabel,
        color: defaultColor,
        structure: {
          startAnchor: false,
          startWordBoundary: false,
          customPrependToggles: [],
          basePattern: '',
          customAppendToggles: [],
          endWordBoundary: false,
          endAnchor: false
        }
      };

      // Get the base pattern from the input field (without custom toggles)
      const patternInput = document.querySelector('#defaultPatternContainer .default-pattern-step');
      let basePattern = patternInput.value;

      // Remove any custom toggles from the base pattern for analysis
      const activeToggles = document.querySelectorAll('.regex-toggle[data-active="true"]');
      activeToggles.forEach(toggle => {
        const regex = toggle.dataset.regex;
        const isPrepend = toggle.dataset.prepend === 'true';

        if (isPrepend) {
          // Remove prepend toggles from the beginning (after any anchors/word boundaries)
          if (basePattern.startsWith('^\\b') && basePattern.substring(3).startsWith(regex)) {
            // Start anchor + word boundary + regex
            basePattern = `^\\b${basePattern.substring(3 + regex.length)}`;
          } else if (basePattern.startsWith('^') && basePattern.substring(1).startsWith(regex)) {
            // Start anchor + regex
            basePattern = `^${basePattern.substring(1 + regex.length)}`;
          } else if (basePattern.startsWith('\\b') && basePattern.substring(2).startsWith(regex)) {
            // Word boundary + regex
            basePattern = `\\b${basePattern.substring(2 + regex.length)}`;
          } else if (basePattern.startsWith(regex)) {
            // Just regex at start
            basePattern = basePattern.substring(regex.length);
          }
        } else {
          // Remove append toggles from the end (before any anchors/word boundaries)
          if (basePattern.endsWith('\\b$') && basePattern.substring(0, basePattern.length - 3).endsWith(regex)) {
            // Regex + word boundary + end anchor
            basePattern = `${basePattern.substring(0, basePattern.length - 3 - regex.length)}\\b$`;
          } else if (basePattern.endsWith('$') && basePattern.substring(0, basePattern.length - 1).endsWith(regex)) {
            // Regex + end anchor
            basePattern = `${basePattern.substring(0, basePattern.length - 1 - regex.length)}$`;
          } else if (basePattern.endsWith('\\b') && basePattern.substring(0, basePattern.length - 2).endsWith(regex)) {
            // Regex + word boundary
            basePattern = `${basePattern.substring(0, basePattern.length - 2 - regex.length)}\\b`;
          } else if (basePattern.endsWith(regex)) {
            // Just regex at end
            basePattern = basePattern.substring(0, basePattern.length - regex.length);
          }
        }
      });

      // Analyze the base pattern structure
      let remainingPattern = basePattern;

      // Check for start anchor
      if (remainingPattern.startsWith('^')) {
        hierarchy.structure.startAnchor = true;
        remainingPattern = remainingPattern.substring(1);
      }

      // Check for start word boundary
      if (remainingPattern.startsWith('\\b')) {
        hierarchy.structure.startWordBoundary = true;
        remainingPattern = remainingPattern.substring(2);
      }

      // Check for end anchor
      if (remainingPattern.endsWith('$')) {
        hierarchy.structure.endAnchor = true;
        remainingPattern = remainingPattern.substring(0, remainingPattern.length - 1);
      }

      // Check for end word boundary
      if (remainingPattern.endsWith('\\b')) {
        hierarchy.structure.endWordBoundary = true;
        remainingPattern = remainingPattern.substring(0, remainingPattern.length - 2);
      }

      // The remaining pattern is the true base pattern
      hierarchy.structure.basePattern = remainingPattern;

      // Add custom toggles to the hierarchy
      activeToggles.forEach(toggle => {
        const toggleInfo = {
          label: toggle.dataset.label,
          regex: toggle.dataset.regex,
          position: toggle.dataset.prepend === 'true' ? 'prepend' : 'append'
        };

        if (toggleInfo.position === 'prepend') {
          hierarchy.structure.customPrependToggles.push(toggleInfo);
        } else {
          hierarchy.structure.customAppendToggles.push(toggleInfo);
        }
      });

      return hierarchy;
    }

    function reconstructPatternFromHierarchy(hierarchy) {
      let reconstructedPattern = '';

      // Add start anchor if present
      if (hierarchy.structure.startAnchor) {
        reconstructedPattern += '^';
      }

      // Add start word boundary if present
      if (hierarchy.structure.startWordBoundary) {
        reconstructedPattern += '\\b';
      }

      // Add custom prepend toggles
      hierarchy.structure.customPrependToggles.forEach(toggle => {
        reconstructedPattern += toggle.regex;
      });

      // Add base pattern
      reconstructedPattern += hierarchy.structure.basePattern;

      // Add custom append toggles
      hierarchy.structure.customAppendToggles.forEach(toggle => {
        reconstructedPattern += toggle.regex;
      });

      // Add end word boundary if present
      if (hierarchy.structure.endWordBoundary) {
        reconstructedPattern += '\\b';
      }

      // Add end anchor if present
      if (hierarchy.structure.endAnchor) {
        reconstructedPattern += '$';
      }

      return reconstructedPattern;
    }

    function updateConstructedPatternDisplay() {
      const pattern = buildDefaultPattern();
      const display = document.getElementById('constructedPattern');
      if (display) {
        display.textContent = pattern || '(empty)';
      }

      // Update pattern hierarchy display
      const hierarchy = buildPatternHierarchy();
      const hierarchyDisplay = document.getElementById('patternHierarchy');
      if (hierarchyDisplay) {
        hierarchyDisplay.textContent = JSON.stringify(hierarchy, null, 2);
      }

      // Update reconstructed pattern display
      const reconstructedPattern = reconstructPatternFromHierarchy(hierarchy);
      const reconstructedDisplay = document.getElementById('reconstructedPattern');
      if (reconstructedDisplay) {
        reconstructedDisplay.textContent = reconstructedPattern || '(empty)';
      }
    }



    function setupStepEventListeners(stepElement) {
      const input = stepElement.querySelector('#basePatternInput');
      const wrapperBtns = stepElement.querySelectorAll('.wrapper-toggle');

      input.addEventListener('input', () => {
        defaultPattern.structure.basePattern = input.value;
        updatePatternUI();
        applyRules();
      });

      wrapperBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const wrapper = btn.dataset.wrapper;
          const isActive = btn.dataset.active === 'true';

          switch (wrapper) {
            case 'word-boundary':
              updatePatternWithWordBoundaries(!isActive);
              break;
            case 'start-anchor':
              updatePatternWithAnchors('start', !isActive);
              break;
            case 'end-anchor':
              updatePatternWithAnchors('end', !isActive);
              break;
          }
          applyRules();
        });
      });
    }



    function showInlineRegexForm(prependMode = false) {
      const form = document.getElementById('inlineRegexForm');
      const regexInput = document.getElementById('newRegexValue');
      const labelInput = document.getElementById('newRegexLabel');
      const prependToggle = document.getElementById('togglePrependMode');

      // Clear previous values
      regexInput.value = '';
      labelInput.value = '';

      // Set prepend mode based on parameter
      prependToggle.textContent = prependMode ? '^' : '+';
      prependToggle.dataset.mode = prependMode ? 'prepend' : 'append';

      // Show the form with animation
      form.classList.add('show');

      // Focus on the first input
      regexInput.focus();
    }

    function hideInlineRegexForm() {
      const form = document.getElementById('inlineRegexForm');
      form.classList.remove('show');
    }

    function addRegexToggle() {
      const regexValue = document.getElementById('newRegexValue').value.trim();
      const label = document.getElementById('newRegexLabel').value.trim();
      const prependMode = document.getElementById('togglePrependMode').dataset.mode === 'prepend';

      if (!regexValue || !label) {
        alert('Please fill in both regex value and label');
        return;
      }

      // Add to JSON structure with the user-provided label
      updatePatternWithRegexToggle(regexValue, prependMode, true, label);

      // Hide the form
      hideInlineRegexForm();

      applyRules();
    }

    function setupAddRegexToggleListener() {
      const addButton = document.getElementById('addRegexToggle');
      const saveButton = document.getElementById('saveRegexToggle');
      const cancelButton = document.getElementById('cancelRegexToggle');
      const prependToggle = document.getElementById('togglePrependMode');

      if (addButton) {
        addButton.addEventListener('click', () => showInlineRegexForm(false));
      }

      if (saveButton) {
        saveButton.addEventListener('click', addRegexToggle);
      }

      if (cancelButton) {
        cancelButton.addEventListener('click', hideInlineRegexForm);
      }

      if (prependToggle) {
        prependToggle.addEventListener('click', () => {
          const currentMode = prependToggle.dataset.mode;
          const newMode = currentMode === 'append' ? 'prepend' : 'append';
          prependToggle.dataset.mode = newMode;
          prependToggle.textContent = newMode === 'append' ? '+' : '^';
          prependToggle.title = newMode === 'append' ? 'Toggle between append (+) and prepend (^) mode' : 'Toggle between append (+) and prepend (^) mode';
        });
      }

      // Allow Enter key to submit the form
      const regexInput = document.getElementById('newRegexValue');
      const labelInput = document.getElementById('newRegexLabel');

      if (regexInput) {
        regexInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            addRegexToggle();
          }
        });
      }

      if (labelInput) {
        labelInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            addRegexToggle();
          }
        });
      }
    }

    function loadSampleDictionary() {
      dictionary = {
        rules: [
          { match: "\\ba[a-zA-Z0-9]+(?:['’-][a-zA-Z0-9]+)*\\b", color: "red", label: "A" },
          { match: "\\bs[a-zA-Z0-9]+(?:['’-][a-zA-Z0-9]+)*\\b", color: "blue", label: "S" },
          { match: "\\bm[a-zA-Z0-9]+(?:['’-][a-zA-Z0-9]+)*\\b", color: "green", label: "M" },
          { match: "\\bg[a-zA-Z0-9]+(?:['’-][a-zA-Z0-9]+)*\\b", color: "orange", label: "G" },
        ]
      };
      refreshRuleUI();
      applyRules();
    }

    document.getElementById('applyBtn').addEventListener('click', () => applyRules());
    document.getElementById('clearBtn').addEventListener('click', () => {
      document.getElementById('sourceText').value = '';
      applyRules();
    });
    document.getElementById('addRule').addEventListener('click', () => {
      dictionary.rules.push({ match: "", color: "", label: "", mode: "word" });
      refreshRuleUI();
    });
    document.getElementById('downloadMd').addEventListener('click', downloadMarkdown);
    document.getElementById('downloadPdf').addEventListener('click', downloadPDF);
    document.getElementById('copyHtml').addEventListener('click', copyStyledHTML);
    document.getElementById('copyPlain').addEventListener('click', copyPlainText);
    document.getElementById('loadSample').addEventListener('click', loadSampleDictionary);
    document.getElementById('importJSON').addEventListener('click', async () => {
      try {
        const [fileHandle] = await window.showOpenFilePicker({ types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }], multiple: false });
        const file = await fileHandle.getFile();
        const text = await file.text();
        dictionary = JSON.parse(text);
        refreshRuleUI();
        applyRules();
      } catch (e) {
        console.warn('import cancelled or failed', e);
      }
    });
    document.getElementById('exportJSON').addEventListener('click', () => {
      const blob = new Blob([JSON.stringify(dictionary, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'dictionary.json';
      a.click();
    });

    // Default pattern event listeners
    document.getElementById('defaultPatternEnabled').addEventListener('change', applyRules);
    document.getElementById('defaultColor').addEventListener('input', () => {
      defaultPattern.color = document.getElementById('defaultColor').value;
      updatePatternUI();
      applyRules();
    });
    document.getElementById('defaultLabel').addEventListener('input', () => {
      defaultPattern.label = document.getElementById('defaultLabel').value;
      updatePatternUI();
      applyRules();
    });

    // Setup add regex toggle listener
    setupAddRegexToggleListener();

    // Add event listener for the new prepend "+" button
    document.getElementById('addPrependRegexToggle').addEventListener('click', () => showInlineRegexForm(true));

    // Preview buttons event listeners
    document.getElementById('loadSampleMd').addEventListener('click', loadSampleMd);
    document.getElementById('refreshPreview').addEventListener('click', refreshPreview);

    // Initialize first step event listeners
    setupStepEventListeners(document.querySelector('#defaultPatternContainer .rule-row'));

    // Initialize pattern UI
    updatePatternUI();

    // initial
    loadSampleDictionary();
  </script>
</body>

</html>