<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Text Parser & Colorizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif;
      padding: 1rem;
      max-width: 1200px;
      margin: auto;
    }

    /* Tab Styles */
    .tab-container {
      margin-top: 2rem;
    }

    .tab-buttons {
      display: flex;
      border-bottom: 2px solid #e0e0e0;
      margin-bottom: 1rem;
    }

    .tab-button {
      padding: 0.75rem 1.5rem;
      border: none;
      background: none;
      cursor: pointer;
      font-weight: 500;
      color: #666;
      border-bottom: 3px solid transparent;
      transition: all 0.2s ease;
    }

    .tab-button.active {
      color: #007aff;
      border-bottom-color: #007aff;
      background: #f8f9fa;
    }

    .tab-button:hover {
      color: #007aff;
      background: #f8f9fa;
    }

    .tab-content {
      display: none;
      padding: 1rem 0;
    }

    .tab-content.active {
      display: block;
    }

    /* Existing Styles */
    textarea {
      width: 100%;
      height: 120px;
      font-family: monospace;
    }

    .preview {
      border: 1px solid #ccc;
      padding: 0.5rem;
      min-height: 100px;
      white-space: pre-wrap;
    }

    .word {
      padding: 2px 3px;
      border-radius: 3px;
      display: inline-block;
      margin: 1px;
    }

    .rule-row {
      display: flex;
      gap: 0;
      margin-bottom: 0;
      flex-wrap: wrap;
    }

    .small {
      font-size: 0.75rem;
      color: #555;
    }

    .flex {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      cursor: pointer;
      border-radius: 5px;
      background: #007aff;
      color: white;
      font-weight: 600;
    }

    .btn-secondary {
      background: #555;
    }

    input,
    select {
      padding: 6px;
    }

    .code {
      background: #f5f5f5;
      padding: 4px 6px;
      border-radius: 4px;
      font-family: monospace;
    }

    .inline-form {
      display: none;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      margin: 0.5rem 0;
      animation: slideDown 0.2s ease-out;
    }

    .inline-form.show {
      display: block;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .inline-form-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .inline-form-row label {
      font-weight: 500;
      min-width: 80px;
    }

    .inline-form-row input {
      flex: 1;
      min-width: 80px;
    }

    .inline-form-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      margin-top: 0.5rem;
    }

    .btn-small {
      padding: 0.25rem 0.5rem;
      font-size: 0.875rem;
    }

    .btn-success {
      background: #28a745;
    }

    .btn-danger {
      background: #dc3545;
    }

    .custom-toggle-container {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin: 0.25rem 0;
    }

    .toggle-button {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.5rem 0.75rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.875rem;
      transition: background-color 0.2s;
    }

    .toggle-button.active {
      background: #28a745;
      color: white;
    }

    .toggle-button.inactive {
      background: #555;
      color: white;
    }

    .toggle-delete {
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      margin-left: 0.25rem;
    }

    .list-container {
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 1rem;
      background: #f8f9fa;
    }

    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #dee2e6;
    }

    .list-title {
      font-weight: 600;
      font-size: 1.1rem;
      margin: 0;
    }

    .list-type {
      font-size: 0.75rem;
      color: #6c757d;
      background: #e9ecef;
      padding: 0.25rem 0.5rem;
      border-radius: 3px;
    }

    .list-content {
      margin-top: 0.5rem;
    }

    .key-value-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
      align-items: center;
    }

    .key-value-row input {
      flex: 1;
      min-width: 100px;
    }

    .array-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
      align-items: center;
    }

    .array-row input {
      flex: 1;
      min-width: 100px;
    }

    .list-actions {
      display: flex;
      gap: 0.25rem;
      margin-top: 0.5rem;
    }

    .btn-xs {
      padding: 0.125rem 0.25rem;
      font-size: 0.75rem;
    }

    .color-btn {
      position: relative;
      border: 2px solid #dee2e6;
      transition: all 0.2s ease;
    }

    .color-btn:hover {
      border-color: #007aff;
    }

    #defaultColor1Panel,
    #defaultColor2Panel {
      position: absolute;
      min-width: 250px;
      background: white;
      border: 1px solid #dee2e6;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    #defaultColor1Display,
    #defaultColor2Display {
      display: inline-block;
      max-width: 40px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: 600;
    }

    /* JSON Display */
    .json-display {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 1rem;
      max-height: 400px;
      overflow: auto;
      font-family: monospace;
      font-size: 0.875rem;
      line-height: 1.4;
      white-space: pre;
    }

    /* JSON Syntax Highlighting */
    .json-key {
      color: #0066cc;
      font-weight: 600;
    }

    .json-string {
      color: #28a745;
    }

    .json-number {
      color: #fd7e14;
    }

    .json-boolean {
      color: #6f42c1;
    }

    .json-null {
      color: #6c757d;
    }

    .json-punctuation {
      color: #495057;
    }

    /* Refresh Button */
    .refresh-btn {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #007aff;
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      font-size: 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.2s ease;
      z-index: 1000;
    }

    .refresh-btn:hover {
      background: #0056b3;
      transform: scale(1.1);
    }

    .refresh-btn:active {
      transform: scale(0.95);
    }

    /* Section headers */
    .section-header {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #e0e0e0;
    }

    .section-header h3 {
      margin: 0;
      color: #333;
    }

    /* Dropdown styling */
    .dropdown-option:hover {
      background-color: #f8f9fa;
    }

    .dropdown-option:last-child {
      border-bottom: none !important;
    }

    /* Style abbreviation styling */
    .style1-display,
    .style2-display {
      font-size: 0.7em;
      opacity: 0.8;
      margin-left: 2px;
    }

    /* Group regex field width */
    .rule-row .match {
      width: 80px;
      min-width: 80px;
    }
  </style>
</head>

<body>
  <!-- Refresh Button -->
  <button class="refresh-btn" id="refreshBtn" title="Refresh from bob.json and switch to JSON tab">ðŸ”„</button>

  <div class="tab-container">
    <div class="tab-buttons">
      <button class="tab-button active" data-tab="input-preview">Input Text + Preview + Export</button>
      <button class="tab-button" data-tab="search-dictionary">Default Search Pattern + Groups</button>
      <button class="tab-button" data-tab="lists-arrays">Lists and Arrays Manager</button>
      <button class="tab-button" data-tab="json-view">bob.json</button>
    </div>

    <!-- Tab 1: Input Text + Preview + Export -->
    <div id="input-preview" class="tab-content active">
      <div style="margin-bottom:0.5rem;">
        <button class="btn" id="loadSampleMd">Load Sample.md</button>
      </div>

      <div class="section-header">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <h3>Input Text</h3>
          <button class="btn btn-secondary" id="clearBtn">Clear</button>
        </div>
      </div>
      <textarea id="sourceText" placeholder="Paste OCR text here..."></textarea>

      <div class="section-header">
        <h3>Preview</h3>
      </div>
      <div class="preview" id="preview"></div>

      <div class="section-header">
        <h3>Export</h3>
      </div>
      <div class="flex">
        <div>
          <label>Markdown filename: <input id="mdName" value="export.md"></label>
          <div style="margin-top:0.25rem;">
            <button class="btn" id="downloadMd">Download Markdown</button>
          </div>
        </div>
        <div>
          <label>PDF filename: <input id="pdfName" value="export.pdf"></label>
          <div style="margin-top:0.25rem;">
            <button class="btn" id="downloadPdf">Download PDF</button>
          </div>
        </div>
        <div>
          <div style="margin-bottom:4px;">Clipboard:</div>
          <button class="btn" id="copyHtml">Copy Styled HTML</button>
          <button class="btn" id="copyPlain">Copy Plain Text</button>
        </div>
      </div>
    </div>

    <!-- Tab 2: Default Search Pattern + Dictionary / Rules -->
    <div id="search-dictionary" class="tab-content">
      <div class="section-header">
        <h3>Default Search Pattern</h3>
      </div>
      <div style="margin-bottom:0.5rem;">
        <label>
          <input type="checkbox" id="defaultPatternEnabled" checked>
          Enable default search pattern
        </label>
      </div>
      <div id="defaultPatternContainer">
        <div class="rule-row" data-step="0">
          <button id="defaultColor1Btn" class="btn btn-secondary color-btn"
            style="width: 80px; text-align: left; position: relative;">
            <span id="defaultColor1Display">magenta</span>
            <span id="defaultStyle1Display">bg</span>
          </button>
          <button id="defaultColor2Btn" class="btn btn-secondary color-btn"
            style="width: 80px; text-align: left; position: relative;">
            <span id="defaultColor2Display">-</span>
            <span id="defaultStyle2Display"></span>
          </button>
          <div id="defaultColor1Panel" class="inline-form">
            <div class="inline-form-row">
              <label for="defaultColor1Text">Color 1:</label>
              <input id="defaultColor1Text" type="text" placeholder="color (e.g. #ff0000)" value="magenta"
                style="flex: 1;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultColor1Picker">Picker:</label>
              <input id="defaultColor1Picker" type="color" value="#ff00ff" style="width: 50px; height: 30px;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultStyle1Select">Style:</label>
              <select id="defaultStyle1Select" style="flex: 1;">
                <option value="background">Background</option>
                <option value="color">Text Color</option>
                <option value="underline">Underline</option>
                <option value="border">Border</option>
              </select>
            </div>
            <div class="inline-form-actions">
              <button class="btn btn-success btn-small" id="applyDefaultColor1">Apply</button>
              <button class="btn btn-danger btn-small" id="cancelDefaultColor1">Cancel</button>
            </div>
          </div>
          <div id="defaultColor2Panel" class="inline-form">
            <div class="inline-form-row">
              <label for="defaultColor2Text">Color 2:</label>
              <input id="defaultColor2Text" type="text" placeholder="color (e.g. #ff0000)" value="" style="flex: 1;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultColor2Picker">Picker:</label>
              <input id="defaultColor2Picker" type="color" value="#0000ff" style="width: 50px; height: 30px;" />
            </div>
            <div class="inline-form-row">
              <label for="defaultStyle2Select">Style:</label>
              <select id="defaultStyle2Select" style="flex: 1;">
                <option value="background">Background</option>
                <option value="color">Text Color</option>
                <option value="underline">Underline</option>
                <option value="border">Border</option>
              </select>
            </div>
            <div class="inline-form-actions">
              <button class="btn btn-success btn-small" id="applyDefaultColor2">Apply</button>
              <button class="btn btn-danger btn-small" id="cancelDefaultColor2">Cancel</button>
            </div>
          </div>
          <button class="btn btn-secondary wrapper-toggle" data-wrapper="start-anchor" data-active="false">^</button>
          <button class="btn btn-secondary" id="addPrependRegexToggle">+</button>
          <div id="prependTogglesContainer" style="display: flex; gap: 0; align-items: center;"></div>
          <input id="basePatternInput" placeholder="Base pattern (e.g. [A-Z])" value="[A-Z]{1,4}"
            style="width: 70px;" />
          <div id="appendTogglesContainer" style="display: flex; gap: 0; align-items: center;"></div>
          <button class="btn btn-secondary" id="addRegexToggle">+</button>
          <button class="btn btn-secondary wrapper-toggle" data-wrapper="word-boundary" data-active="false">\b</button>
          <button class="btn btn-secondary wrapper-toggle" data-wrapper="end-anchor" data-active="false">$</button>
        </div>

        <!-- Inline form for adding regex toggles -->
        <div id="inlineRegexForm" class="inline-form">
          <div class="inline-form-row">
            <label for="newRegexValue">Regex:</label>
            <input type="text" id="newRegexValue" placeholder="Enter regex string (e.g. [0-9]+)" />
            <button class="btn btn-secondary btn-small" id="togglePrependMode"
              title="Toggle between append (+) and prepend (^) mode">+</button>
          </div>
          <div class="inline-form-row">
            <label for="newRegexLabel">Label:</label>
            <input type="text" id="newRegexLabel" placeholder="Enter button label (e.g. Numbers)" />
          </div>
          <div class="inline-form-actions">
            <button class="btn btn-success btn-small" id="saveRegexToggle">Add Toggle</button>
            <button class="btn btn-danger btn-small" id="cancelRegexToggle">Cancel</button>
          </div>
        </div>
      </div>

      <div style="margin-top: 0.5rem;">
        <strong>Constructed Pattern:</strong> <code id="constructedPattern">[A-Z]{1,4}</code>
      </div>
      <div style="margin-top: 0.5rem;">
        <strong>Current Matches:</strong>
        <pre id="currentMatches" class="code" style="max-height:100px; overflow:auto; font-size: 0.875rem;"></pre>
      </div>
      <p class="small">This pattern will be applied to any text that doesn't match other rules. Build your pattern
        progressively by adding wrappers to each step.</p>

      <div class="section-header">
        <h3>Groups</h3>
      </div>
      <div style="margin-top:0.5rem;">
        <div id="rulesContainer"></div>
        <div style="margin-top:0.5rem;">
          <div class="dropdown-container" style="position: relative; display: inline-block;">
            <button class="btn" id="addRule">+ Add Group</button>
            <div id="categoryDropdown" class="dropdown-menu"
              style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #dee2e6; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 1000; max-width: 100px;">
              <!-- Categories will be populated dynamically -->
            </div>
          </div>
        </div>
      </div>
      <p class="small">Groups match words using JavaScript regular expressions (case-insensitive by default). First
        matching group applies.</p>
    </div>

    <!-- Tab 3: Lists and Arrays Manager -->
    <div id="lists-arrays" class="tab-content">
      <div class="section-header">
        <h3>Lists and Arrays Manager</h3>
      </div>
      <div style="margin-bottom:0.5rem;">
        <button class="btn" id="addKeyValueList">+ Add Key-Value List</button>
        <button class="btn btn-secondary" id="addArray">+ Add Array</button>
      </div>
      <div id="listsContainer"></div>
      <p class="small">Manage lists of key:value pairs and arrays that sync with bob.json. Use these for storing
        configuration data, mappings, or any structured data.</p>
    </div>

    <!-- Tab 4: bob.json -->
    <div id="json-view" class="tab-content">
      <div class="section-header">
        <h3>bob.json</h3>
        <p class="small">This shows the current state of your configuration data. The data is automatically saved to
          localStorage and can be exported to bob.json.</p>
      </div>
      <div style="margin-bottom:1rem;">
        <button class="btn btn-secondary" id="loadBobJson">Load from Storage</button>
        <button class="btn btn-secondary" id="saveBobJson">Export to File</button>
      </div>
      <div class="json-display" id="rawJson"></div>
    </div>
  </div>

  <template id="ruleTemplate">
    <div class="rule-row">
      <select class="category" style="width: 150px;">
        <option value="">ðŸ’œ</option>
      </select>
      <button class="color1-btn btn btn-secondary color-btn" style="width: 80px; text-align: left; position: relative;">
        <span class="color1-display">magenta</span>
        <span class="style1-display">bg</span>
      </button>
      <button class="color2-btn btn btn-secondary color-btn" style="width: 80px; text-align: left; position: relative;">
        <span class="color2-display">-</span>
        <span class="style2-display"></span>
      </button>
      <input aria-label="match" placeholder="regex (e.g. ^[A-M])" class="match" />
      <button class="btn btn-secondary removeRule">âœ•</button>
    </div>
  </template>

  <!-- jsPDF from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
    integrity="sha512-your-integrity-placeholder" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
    // Tab functionality
    function initTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const targetTab = button.getAttribute('data-tab');

          // Remove active class from all buttons and contents
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));

          // Add active class to clicked button and corresponding content
          button.classList.add('active');
          document.getElementById(targetTab).classList.add('active');
        });
      });
    }

    // minimal dictionary structure
    let dictionary = { rules: [] };

    // Default pattern JSON structure
    let defaultPattern = {
      label: "Default",
      color1: "magenta",
      color2: "",
      style1: "background",
      style2: "",
      structure: {
        startAnchor: false,
        startWordBoundary: false,
        customPrependToggles: [],
        basePattern: "[A-Z]{1,4}",
        customAppendToggles: [],
        endWordBoundary: false,
        endAnchor: false
      }
    };

    // Lists and Arrays Management
    let listsData = {
      keyValueLists: [],
      arrays: []
    };

    // Function to load pattern hierarchy from localStorage or bob.json
    async function loadPatternHierarchy() {
      // First try to load from localStorage
      const localStorageData = localStorage.getItem('bobPatternHierarchy');
      if (localStorageData) {
        try {
          const data = JSON.parse(localStorageData);

          // Load default pattern
          if (data.defaultPattern) {
            defaultPattern = data.defaultPattern;
          }

          // Load dictionary
          if (data.dictionary) {
            dictionary = data.dictionary;
          }

          // Load lists and arrays data
          if (data.listsData) {
            listsData = data.listsData;
          }

          // Update UI
          updatePatternUI();
          refreshRuleUI();
          refreshListsUI();
          applyRules();

          console.log('Pattern hierarchy loaded from localStorage');
          return;
        } catch (error) {
          console.error('Error parsing localStorage data:', error);
        }
      }

      // Fallback to loading from bob.json file
      try {
        const response = await fetch('bob.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        // Load default pattern
        if (data.defaultPattern) {
          defaultPattern = data.defaultPattern;
        }

        // Load dictionary
        if (data.dictionary) {
          dictionary = data.dictionary;
        }

        // Load lists and arrays data
        if (data.listsData) {
          listsData = data.listsData;
        }

        // Update UI
        updatePatternUI();
        refreshRuleUI();
        refreshListsUI();
        applyRules();

        console.log('Pattern hierarchy loaded from bob.json');
      } catch (error) {
        console.error('Error loading bob.json:', error);
        // If neither localStorage nor file exists, start with empty data
        console.log('No existing data found, starting with empty configuration');
      }
    }

    // Function to refresh from bob.json and switch to JSON tab
    async function refreshFromBobJson() {
      try {
        const response = await fetch('bob.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        // Load default pattern
        if (data.defaultPattern) {
          defaultPattern = data.defaultPattern;
        }

        // Load dictionary
        if (data.dictionary) {
          dictionary = data.dictionary;
        }

        // Load lists and arrays data
        if (data.listsData) {
          listsData = data.listsData;
        }

        // Update UI
        updatePatternUI();
        refreshRuleUI();
        refreshListsUI();
        applyRules();
        updateRawJson();

        // Note: Removed auto-switching to JSON tab as requested

        console.log('Refreshed from bob.json');

        // Show success indicator
        showRefreshIndicator();
      } catch (error) {
        console.error('Error refreshing from bob.json:', error);
        alert('Error loading bob.json. Make sure the file exists and is valid JSON.');
      }
    }

    // Function to show refresh indicator
    function showRefreshIndicator() {
      // Create or update refresh indicator
      let indicator = document.getElementById('refreshIndicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'refreshIndicator';
        indicator.style.cssText = `
          position: fixed;
          top: 80px;
          right: 20px;
          background: #28a745;
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-size: 12px;
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.3s ease;
        `;
        document.body.appendChild(indicator);
      }

      indicator.textContent = 'âœ“ Refreshed from bob.json';
      indicator.style.opacity = '1';

      // Hide after 2 seconds
      setTimeout(() => {
        indicator.style.opacity = '0';
      }, 2000);
    }

    // Function to save pattern hierarchy to localStorage (silent)
    function savePatternHierarchy() {
      try {
        const data = {
          defaultPattern: defaultPattern,
          dictionary: dictionary,
          listsData: listsData
        };

        // Save to localStorage for immediate syncing
        localStorage.setItem('bobPatternHierarchy', JSON.stringify(data));
        console.log('Pattern hierarchy saved to localStorage');
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }
    }

    // Function to export pattern hierarchy to file (with user interaction)
    async function exportPatternHierarchy() {
      try {
        const data = {
          defaultPattern: defaultPattern,
          dictionary: dictionary,
          listsData: listsData
        };

        // Try to use File System Access API for silent saving
        if ('showSaveFilePicker' in window) {
          try {
            const handle = await window.showSaveFilePicker({
              suggestedName: 'bob.json',
              types: [{
                description: 'JSON files',
                accept: { 'application/json': ['.json'] }
              }]
            });
            const writable = await handle.createWritable();
            await writable.write(JSON.stringify(data, null, 2));
            await writable.close();
            console.log('Pattern hierarchy exported to bob.json via File System Access API');
            return;
          } catch (e) {
            console.log('File System Access API failed, falling back to download');
          }
        }

        // Fallback to download method
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'bob.json';
        a.click();

        console.log('Pattern hierarchy exported to bob.json via download');
      } catch (error) {
        console.error('Error exporting bob.json:', error);
      }
    }

    // Function to auto-save pattern hierarchy
    function autoSavePatternHierarchy() {
      // Debounce the save operation
      clearTimeout(window.autoSaveTimeout);
      window.autoSaveTimeout = setTimeout(() => {
        savePatternHierarchy();
        // Show a brief visual indicator
        showSaveIndicator();
      }, 1000); // Save after 1 second of inactivity
    }

    // Function to show save indicator
    function showSaveIndicator() {
      // Create or update save indicator
      let indicator = document.getElementById('saveIndicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'saveIndicator';
        indicator.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #28a745;
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-size: 12px;
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.3s ease;
        `;
        document.body.appendChild(indicator);
      }

      indicator.textContent = 'âœ“ Saved';
      indicator.style.opacity = '1';

      // Hide after 2 seconds
      setTimeout(() => {
        indicator.style.opacity = '0';
      }, 2000);
    }

    function refreshRuleUI() {
      const container = document.getElementById('rulesContainer');
      container.innerHTML = '';
      dictionary.rules.forEach((r, idx) => {
        const tpl = document.getElementById('ruleTemplate');
        const node = tpl.content.cloneNode(true);
        const row = node.querySelector('.rule-row');
        row.dataset.idx = idx;

        // Populate category dropdown
        const categorySelect = row.querySelector('.category');
        categorySelect.innerHTML = '';

        // Add default option
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'ðŸ’œ';
        categorySelect.appendChild(defaultOption);

        // Add categories from listsData
        if (listsData && listsData.keyValueLists) {
          const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
          if (categoriesList && categoriesList.items) {
            categoriesList.items.forEach(item => {
              const option = document.createElement('option');
              option.value = item.key;
              option.textContent = `${item.value} ${item.key}`;
              categorySelect.appendChild(option);
            });
          }
        }

        // Set values
        row.querySelector('.match').value = r.match || '';
        row.querySelector('.category').value = r.label || '';

        // Set color and style displays
        const color1Display = row.querySelector('.color1-display');
        const color2Display = row.querySelector('.color2-display');
        const style1Display = row.querySelector('.style1-display');
        const style2Display = row.querySelector('.style2-display');
        const color1Btn = row.querySelector('.color1-btn');
        const color2Btn = row.querySelector('.color2-btn');

        if (r.color1) {
          color1Display.textContent = r.color1;
          style1Display.textContent = getStyleAbbreviation(r.style1 || 'background');
          applyStyleToButton(color1Btn, r.color1, r.style1 || 'background');
        } else {
          color1Display.textContent = 'magenta';
          style1Display.textContent = 'bg';
          color1Btn.style.backgroundColor = '';
          color1Btn.style.color = '';
          color1Btn.style.border = '';
          color1Btn.style.textDecoration = '';
        }

        if (r.color2) {
          color2Display.textContent = r.color2;
          style2Display.textContent = getStyleAbbreviation(r.style2 || 'background');
          applyStyleToButton(color2Btn, r.color2, r.style2 || 'background');
        } else {
          color2Display.textContent = '-';
          style2Display.textContent = '';
          color2Btn.style.backgroundColor = '';
          color2Btn.style.color = '';
          color2Btn.style.border = '';
          color2Btn.style.textDecoration = '';
        }

        // Add event listeners
        row.querySelector('.removeRule').addEventListener('click', () => {
          dictionary.rules.splice(idx, 1);
          refreshRuleUI();
          applyRules();
          autoSavePatternHierarchy();
        });

        // Live change listeners
        row.querySelector('.match').addEventListener('input', () => {
          dictionary.rules[idx].match = row.querySelector('.match').value;
          updateRawJson();
          autoSavePatternHierarchy();
        });

        row.querySelector('.category').addEventListener('change', () => {
          dictionary.rules[idx].label = row.querySelector('.category').value;
          updateRawJson();
          autoSavePatternHierarchy();
        });

        // Color button click handlers
        color1Btn.addEventListener('click', (e) => {
          e.stopPropagation();
          showRuleColorPanel(idx, 1);
        });

        color2Btn.addEventListener('click', (e) => {
          e.stopPropagation();
          showRuleColorPanel(idx, 2);
        });

        container.appendChild(node);
      });
      updateRawJson();
    }

    function prettifyJson(json) {
      const jsonString = JSON.stringify(json, null, 2);

      // Split into lines to preserve formatting
      const lines = jsonString.split('\n');
      const formattedLines = lines.map(line => {
        // Apply syntax highlighting to each line
        return line
          .replace(/"([^"]+)":/g, '<span class="json-key">"$1"</span><span class="json-punctuation">:</span>')
          .replace(/"([^"]*)"/g, '<span class="json-string">"$1"</span>')
          .replace(/\b(true|false)\b/g, '<span class="json-boolean">$1</span>')
          .replace(/\b(null)\b/g, '<span class="json-null">$1</span>')
          .replace(/\b(\d+\.?\d*)\b/g, '<span class="json-number">$1</span>')
          .replace(/([{}[\],])/g, '<span class="json-punctuation">$1</span>');
      });

      // Join lines back together, preserving line breaks
      return formattedLines.join('\n');
    }

    function updateRawJson() {
      const data = {
        defaultPattern: defaultPattern,
        dictionary: dictionary,
        listsData: listsData
      };
      const jsonElement = document.getElementById('rawJson');
      jsonElement.innerHTML = prettifyJson(data);
    }

    function applyRules() {
      const text = document.getElementById('sourceText').value || '';
      const words = text.split(/(\s+)/); // keep spaces
      const preview = document.getElementById('preview');
      preview.innerHTML = '';
      const elements = [];

      // Get default pattern settings
      const defaultEnabled = document.getElementById('defaultPatternEnabled').checked;
      const defaultPattern = buildPatternFromJSON();
      const defaultLabel = defaultPattern.label;

      // Find all matches for multi-word patterns first
      const multiWordMatches = new Set();

      // Check dictionary rules for multi-word patterns
      for (const rule of dictionary.rules) {
        if (rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              // Store the start and end positions of the match
              multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Check default pattern for multi-word patterns
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            // Store the start and end positions of the match
            multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      words.forEach((token, index) => {
        let cleaned = token;
        if (token.trim() === '') {
          preview.append(document.createTextNode(token));
          return;
        }
        let matched = null;

        // Calculate the position of this token in the original text
        const tokenStart = words.slice(0, index).join('').length;
        const tokenEnd = tokenStart + token.length;
        const tokenRange = `${tokenStart}-${tokenEnd}`;

        // Check if this token is part of a multi-word match
        let isPartOfMultiWordMatch = false;
        for (const matchRange of multiWordMatches) {
          const [matchStart, matchEnd] = matchRange.split('-').map(Number);
          // Check if this token overlaps with the match
          if (tokenStart < matchEnd && tokenEnd > matchStart) {
            isPartOfMultiWordMatch = true;
            break;
          }
        }

        // First check dictionary rules
        for (const rule of dictionary.rules) {
          try {
            const flags = 'i';
            let regex = new RegExp(rule.match, flags);

            // Check if pattern contains spaces (multi-word pattern)
            if (rule.match.includes(' ')) {
              // For multi-word patterns, check if this token is part of a match
              if (isPartOfMultiWordMatch) {
                matched = {
                  color1: rule.color1,
                  color2: rule.color2,
                  style1: rule.style1,
                  style2: rule.style2,
                  label: rule.label
                };
                break;
              }
            } else {
              // For single-word patterns, test against the current token
              if (regex.test(token)) {
                matched = {
                  color1: rule.color1,
                  color2: rule.color2,
                  style1: rule.style1,
                  style2: rule.style2,
                  label: rule.label
                };
                break;
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad regex', rule.match);
          }
        }

        // If no match found and default pattern is enabled, try default pattern
        if (!matched && defaultEnabled && defaultPattern) {
          try {
            const flags = 'i';
            let regex = new RegExp(defaultPattern.pattern, flags);

            // Check if pattern contains spaces (multi-word pattern)
            if (defaultPattern.pattern.includes(' ')) {
              // For multi-word patterns, check if this token is part of a match
              if (isPartOfMultiWordMatch) {
                matched = {
                  color1: defaultPattern.color1,
                  color2: defaultPattern.color2,
                  style1: defaultPattern.style1,
                  style2: defaultPattern.style2,
                  label: defaultPattern.label
                };
              }
            } else {
              // For single-word patterns, test against the current token
              if (regex.test(token)) {
                matched = {
                  color1: defaultPattern.color1,
                  color2: defaultPattern.color2,
                  style1: defaultPattern.style1,
                  style2: defaultPattern.style2,
                  label: defaultPattern.label
                };
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad default regex', defaultPattern.pattern);
          }
        }

        const span = document.createElement('span');
        span.textContent = token;
        span.className = 'word';
        if (matched) {
          // Apply styles based on the new style system
          if (matched.color1) {
            applyStyleToElement(span, matched.color1, matched.style1 || 'background');
          }
          if (matched.color2 && matched.color2.trim() !== '') {
            // For color2, only apply if it's different from color1's style
            if (matched.style2 && matched.style2 !== matched.style1) {
              applyStyleToElement(span, matched.color2, matched.style2);
            }
          }
          span.title = matched.label || '';
        } else {
          span.style.color = 'inherit';
        }
        preview.appendChild(span);
      });

      // Update current matches display
      const matchesDisplay = document.getElementById('currentMatches');
      if (matchesDisplay) {
        const matches = findCurrentMatches();
        matchesDisplay.textContent = matches.length > 0 ? matches.join(', ') : 'No matches found';
      }
    }

    function downloadMarkdown() {
      const text = document.getElementById('sourceText').value || '';
      // Build markdown with inline color hints using HTML spans
      const previewDiv = document.getElementById('preview');
      let md = '';
      // Iterate over children to preserve spaces
      previewDiv.childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          md += node.textContent;
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const span = node;
          const word = span.textContent;
          const bg = span.style.background;
          const label = span.title;
          if (bg || label) {
            // use inline HTML for color
            md += `<span style="background:${bg}">${word}</span>`;
          } else {
            md += word;
          }
        }
      });
      const blob = new Blob([md], { type: 'text/markdown' });
      const name = document.getElementById('mdName').value || 'export.md';
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.click();
    }

    async function downloadPDF() {
      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        alert('jsPDF not loaded');
        return;
      }
      const pdf = new jsPDF();
      const preview = document.getElementById('preview');
      // Simplest: convert text content with minimal styling
      const lines = [];
      preview.childNodes.forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          lines.push(node.textContent);
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          let word = node.textContent;
          // add markers for colored
          if (node.style.background) {
            word = `[${word}]`;
          }
          lines.push(word);
        }
      });
      const full = lines.join('');
      // split to fit
      const pageWidth = pdf.internal.pageSize.getWidth();
      const margin = 10;
      const usableWidth = pageWidth - margin * 2;
      const split = pdf.splitTextToSize(full, usableWidth);
      pdf.text(split, margin, 20);
      const name = document.getElementById('pdfName').value || 'export.pdf';
      pdf.save(name);
    }

    function copyStyledHTML() {
      const preview = document.getElementById('preview');
      navigator.clipboard.write([
        new ClipboardItem({
          'text/html': new Blob([preview.innerHTML], { type: 'text/html' }),
          'text/plain': new Blob([preview.textContent], { type: 'text/plain' })
        })
      ]).then(() => alert('Copied styled HTML to clipboard'));
    }

    function copyPlainText() {
      const preview = document.getElementById('preview');
      navigator.clipboard.writeText(preview.textContent).then(() => alert('Copied plain text'));
    }

    async function loadSampleMd() {
      try {
        const response = await fetch('sample.md');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const content = await response.text();
        document.getElementById('sourceText').value = content;
        applyRules();
      } catch (error) {
        console.error('Error loading sample.md:', error);
        alert('Error loading sample.md. Make sure the file exists in the same directory as this HTML file.');
      }
    }

    function refreshPreview() {
      applyRules();
    }

    function buildPatternFromJSON() {
      let pattern = '';

      // Add start anchor if present
      if (defaultPattern.structure.startAnchor) {
        pattern += '^';
      }

      // Add start word boundary if present
      if (defaultPattern.structure.startWordBoundary) {
        pattern += '\\b';
      }

      // Add custom prepend toggles
      defaultPattern.structure.customPrependToggles.forEach(toggle => {
        if (toggle.active) {
          pattern += toggle.regex;
        }
      });

      // Add base pattern
      pattern += defaultPattern.structure.basePattern;

      // Add custom append toggles
      defaultPattern.structure.customAppendToggles.forEach(toggle => {
        if (toggle.active) {
          pattern += toggle.regex;
        }
      });

      // Add end word boundary if present
      if (defaultPattern.structure.endWordBoundary) {
        pattern += '\\b';
      }

      // Add end anchor if present
      if (defaultPattern.structure.endAnchor) {
        pattern += '$';
      }

      return {
        pattern: pattern,
        color1: defaultPattern.color1,
        color2: defaultPattern.color2,
        style1: defaultPattern.style1,
        style2: defaultPattern.style2,
        label: defaultPattern.label
      };
    }

    function updatePatternUI() {
      // Update input fields
      updateDefaultColorButtons();
      document.getElementById('basePatternInput').value = defaultPattern.structure.basePattern;

      // Update wrapper button states
      const startAnchorBtn = document.querySelector('[data-wrapper="start-anchor"]');
      const wordBoundaryBtn = document.querySelector('[data-wrapper="word-boundary"]');
      const endAnchorBtn = document.querySelector('[data-wrapper="end-anchor"]');

      if (startAnchorBtn) {
        startAnchorBtn.dataset.active = defaultPattern.structure.startAnchor;
        startAnchorBtn.style.background = defaultPattern.structure.startAnchor ? '#28a745' : '#555';
      }

      if (wordBoundaryBtn) {
        wordBoundaryBtn.dataset.active = defaultPattern.structure.endWordBoundary;
        wordBoundaryBtn.style.background = defaultPattern.structure.endWordBoundary ? '#28a745' : '#555';
      }

      if (endAnchorBtn) {
        endAnchorBtn.dataset.active = defaultPattern.structure.endAnchor;
        endAnchorBtn.style.background = defaultPattern.structure.endAnchor ? '#28a745' : '#555';
      }

      // Update constructed pattern display
      const pattern = buildPatternFromJSON();
      const display = document.getElementById('constructedPattern');
      if (display) {
        display.textContent = pattern.pattern || '(empty)';
      }

      // Update current matches display
      const matchesDisplay = document.getElementById('currentMatches');
      if (matchesDisplay) {
        const matches = findCurrentMatches();
        matchesDisplay.textContent = matches.length > 0 ? matches.join(', ') : 'No matches found';
      }



      // Update custom toggles display
      updateCustomTogglesDisplay();
    }

    function updateCustomTogglesDisplay() {
      // Update prepend toggles
      const prependContainer = document.getElementById('prependTogglesContainer');
      if (prependContainer) {
        prependContainer.innerHTML = '';
        defaultPattern.structure.customPrependToggles.forEach(toggle => {
          const toggleElement = createToggleElement(toggle, true);
          prependContainer.appendChild(toggleElement);
        });
      }

      // Update append toggles
      const appendContainer = document.getElementById('appendTogglesContainer');
      if (appendContainer) {
        appendContainer.innerHTML = '';
        defaultPattern.structure.customAppendToggles.forEach(toggle => {
          const toggleElement = createToggleElement(toggle, false);
          appendContainer.appendChild(toggleElement);
        });
      }
    }

    function createToggleElement(toggle, isPrepend) {
      const container = document.createElement('div');
      container.className = 'custom-toggle-container';

      // Main toggle button (label only)
      const toggleButton = document.createElement('button');
      toggleButton.className = `toggle-button ${toggle.active ? 'active' : 'inactive'}`;
      toggleButton.title = `Regex: ${toggle.regex}`;
      toggleButton.textContent = toggle.label;

      // Toggle functionality
      toggleButton.addEventListener('click', () => {
        toggleCustomToggle(toggle.id, isPrepend);
      });

      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'toggle-delete';
      deleteBtn.textContent = 'âœ•';
      deleteBtn.title = 'Delete toggle';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent triggering the toggle button
        deleteCustomToggle(toggle.id, isPrepend);
      });

      container.appendChild(toggleButton);
      container.appendChild(deleteBtn);

      return container;
    }

    function updatePatternWithAnchors(anchorType, addAnchor) {
      if (anchorType === 'start') {
        defaultPattern.structure.startAnchor = addAnchor;
      } else if (anchorType === 'end') {
        defaultPattern.structure.endAnchor = addAnchor;
      }
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function updatePatternWithWordBoundaries(addBoundaries) {
      defaultPattern.structure.startWordBoundary = addBoundaries;
      defaultPattern.structure.endWordBoundary = addBoundaries;
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function updatePatternWithRegexToggle(regex, isPrepend, addRegex, label = 'Custom Toggle') {
      if (addRegex) {
        const toggleInfo = {
          id: Date.now().toString(),
          label: label,
          regex: regex,
          position: isPrepend ? 'prepend' : 'append',
          active: true
        };

        if (isPrepend) {
          defaultPattern.structure.customPrependToggles.push(toggleInfo);
        } else {
          defaultPattern.structure.customAppendToggles.push(toggleInfo);
        }
      } else {
        // Remove the regex from the appropriate array
        if (isPrepend) {
          defaultPattern.structure.customPrependToggles = defaultPattern.structure.customPrependToggles.filter(t => t.regex !== regex);
        } else {
          defaultPattern.structure.customAppendToggles = defaultPattern.structure.customAppendToggles.filter(t => t.regex !== regex);
        }
      }
      updatePatternUI();
      autoSavePatternHierarchy();
    }

    function toggleCustomToggle(toggleId, isPrepend) {
      const toggles = isPrepend ? defaultPattern.structure.customPrependToggles : defaultPattern.structure.customAppendToggles;
      const toggle = toggles.find(t => t.id === toggleId);
      if (toggle) {
        toggle.active = !toggle.active;
        updatePatternUI();
        applyRules();
        autoSavePatternHierarchy();
      }
    }

    function deleteCustomToggle(toggleId, isPrepend) {
      if (isPrepend) {
        defaultPattern.structure.customPrependToggles = defaultPattern.structure.customPrependToggles.filter(t => t.id !== toggleId);
      } else {
        defaultPattern.structure.customAppendToggles = defaultPattern.structure.customAppendToggles.filter(t => t.id !== toggleId);
      }
      updatePatternUI();
      applyRules();
      autoSavePatternHierarchy();
    }

    function findCurrentMatches() {
      const text = document.getElementById('sourceText').value || '';
      const matches = [];

      // Get default pattern settings
      const defaultEnabled = document.getElementById('defaultPatternEnabled').checked;
      const defaultPattern = buildPatternFromJSON();

      // Split text the same way as applyRules() does
      const tokens = text.split(/(\s+)/); // keep spaces

      // Find all matches for multi-word patterns first
      const multiWordMatches = new Set();

      // Check dictionary rules for multi-word patterns
      for (const rule of dictionary.rules) {
        if (rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              // Store the start and end positions of the match
              multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Check default pattern for multi-word patterns
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            // Store the start and end positions of the match
            multiWordMatches.add(`${match.index}-${match.index + match[0].length}`);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      // For multi-word patterns, we need to extract the actual matched phrases
      const matchedPhrases = new Set();

      // Extract matched phrases from dictionary rules
      for (const rule of dictionary.rules) {
        if (rule.match.includes(' ')) {
          try {
            const flags = 'gi';
            let regex = new RegExp(rule.match, flags);
            let match;
            while ((match = regex.exec(text)) !== null) {
              matchedPhrases.add(match[0]);
            }
          } catch (e) {
            console.warn('bad regex', rule.match);
          }
        }
      }

      // Extract matched phrases from default pattern
      if (defaultEnabled && defaultPattern && defaultPattern.pattern.includes(' ')) {
        try {
          const flags = 'gi';
          let regex = new RegExp(defaultPattern.pattern, flags);
          let match;
          while ((match = regex.exec(text)) !== null) {
            matchedPhrases.add(match[0]);
          }
        } catch (e) {
          console.warn('bad default regex', defaultPattern.pattern);
        }
      }

      // Add multi-word matched phrases
      matchedPhrases.forEach(phrase => {
        matches.push(phrase);
      });

      // Process individual tokens for single-word patterns
      tokens.forEach((token, index) => {
        if (token.trim() === '') {
          return; // Skip empty tokens
        }

        let matched = false;

        // Calculate the position of this token in the original text
        const tokenStart = tokens.slice(0, index).join('').length;
        const tokenEnd = tokenStart + token.length;

        // Check if this token is part of a multi-word match
        let isPartOfMultiWordMatch = false;
        for (const matchRange of multiWordMatches) {
          const [matchStart, matchEnd] = matchRange.split('-').map(Number);
          // Check if this token overlaps with the match
          if (tokenStart < matchEnd && tokenEnd > matchStart) {
            isPartOfMultiWordMatch = true;
            break;
          }
        }

        // Skip tokens that are part of multi-word matches (we already added the full phrases)
        if (isPartOfMultiWordMatch) {
          return;
        }

        // First check dictionary rules
        for (const rule of dictionary.rules) {
          try {
            const flags = 'i';
            let regex = new RegExp(rule.match, flags);

            // Only check single-word patterns here
            if (!rule.match.includes(' ')) {
              const match = token.match(regex);
              if (match) {
                matches.push(match[0]);
                matched = true;
                break;
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad regex', rule.match);
          }
        }

        // If no match found and default pattern is enabled, try default pattern
        if (!matched && defaultEnabled && defaultPattern) {
          try {
            const flags = 'i';
            let regex = new RegExp(defaultPattern.pattern, flags);

            // Only check single-word patterns here
            if (!defaultPattern.pattern.includes(' ')) {
              const match = token.match(regex);
              if (match) {
                matches.push(match[0]);
              }
            }
          } catch (e) {
            // invalid regex; skip
            console.warn('bad default regex', defaultPattern.pattern);
          }
        }
      });

      // Remove duplicates and return
      return [...new Set(matches)];
    }

    function getContrastColor(color) {
      // Handle hex colors
      if (color.startsWith('#')) {
        const hex = color.replace('#', '');
        if (hex.length === 6) {
          // Convert to RGB
          const r = parseInt(hex.substr(0, 2), 16);
          const g = parseInt(hex.substr(2, 2), 16);
          const b = parseInt(hex.substr(4, 2), 16);

          // Calculate luminance
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

          // Return black or white based on luminance
          return luminance > 0.5 ? '#000000' : '#ffffff';
        }
      }

      // For non-hex colors, use a simple heuristic
      const colorLower = color.toLowerCase();
      if (colorLower === 'white' || colorLower === 'yellow' || colorLower === 'cyan' || colorLower === 'lightgray' || colorLower === 'lightgrey') {
        return '#000000';
      } else {
        return '#ffffff';
      }
    }

    function getStyleAbbreviation(style) {
      switch (style) {
        case 'background': return 'bg';
        case 'color': return 'txt';
        case 'underline': return 'ul';
        case 'border': return 'bd';
        default: return 'bg';
      }
    }

    function applyStyleToButton(button, color, style) {
      // Reset all styles first
      button.style.backgroundColor = '';
      button.style.color = '';
      button.style.border = '';
      button.style.textDecoration = '';

      try {
        switch (style) {
          case 'background':
            button.style.backgroundColor = color;
            button.style.color = getContrastColor(color);
            break;
          case 'color':
            button.style.color = color;
            break;
          case 'underline':
            button.style.textDecoration = `underline ${color}`;
            break;
          case 'border':
            button.style.border = `2px solid ${color}`;
            break;
        }
      } catch (e) {
        // If color is invalid, reset to default
        button.style.backgroundColor = '';
        button.style.color = '';
        button.style.border = '';
        button.style.textDecoration = '';
      }
    }

    function applyStyleToElement(element, color, style) {
      try {
        switch (style) {
          case 'background':
            element.style.backgroundColor = color;
            element.style.color = getContrastColor(color);
            element.style.padding = '2px 4px';
            element.style.borderRadius = '3px';
            break;
          case 'color':
            element.style.color = color;
            break;
          case 'underline':
            element.style.textDecoration = `underline ${color}`;
            break;
          case 'border':
            element.style.border = `2px solid ${color}`;
            element.style.padding = '1px 3px';
            element.style.borderRadius = '3px';
            break;
        }
      } catch (e) {
        // If color is invalid, reset to default
        element.style.backgroundColor = '';
        element.style.color = '';
        element.style.border = '';
        element.style.textDecoration = '';
      }
    }

    // Lists and Arrays Management Functions
    function refreshListsUI() {
      const container = document.getElementById('listsContainer');
      container.innerHTML = '';

      // Render key-value lists
      listsData.keyValueLists.forEach((list, listIndex) => {
        const listElement = createKeyValueListElement(list, listIndex);
        container.appendChild(listElement);
      });

      // Render arrays
      listsData.arrays.forEach((array, arrayIndex) => {
        const arrayElement = createArrayElement(array, arrayIndex);
        container.appendChild(arrayElement);
      });
    }

    function createKeyValueListElement(list, listIndex) {
      const container = document.createElement('div');
      container.className = 'list-container';
      container.dataset.listIndex = listIndex;
      container.dataset.type = 'keyValue';

      const header = document.createElement('div');
      header.className = 'list-header';

      const title = document.createElement('h3');
      title.className = 'list-title';
      title.contentEditable = true;
      title.textContent = list.name || 'Key-Value List';
      title.addEventListener('blur', () => {
        list.name = title.textContent;
        autoSavePatternHierarchy();
      });

      const typeBadge = document.createElement('span');
      typeBadge.className = 'list-type';
      typeBadge.textContent = 'Key-Value';

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn btn-danger btn-xs';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', () => {
        listsData.keyValueLists.splice(listIndex, 1);
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      header.appendChild(title);
      header.appendChild(typeBadge);
      header.appendChild(deleteBtn);

      const content = document.createElement('div');
      content.className = 'list-content';

      // Render key-value pairs
      list.items.forEach((item, itemIndex) => {
        const row = document.createElement('div');
        row.className = 'key-value-row';

        const keyInput = document.createElement('input');
        keyInput.placeholder = 'Key';
        keyInput.value = item.key || '';
        keyInput.addEventListener('input', () => {
          item.key = keyInput.value;
          autoSavePatternHierarchy();
        });

        const valueInput = document.createElement('input');
        valueInput.placeholder = 'Value';
        valueInput.value = item.value || '';
        valueInput.addEventListener('input', () => {
          item.value = valueInput.value;
          autoSavePatternHierarchy();
        });

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-danger btn-xs';
        removeBtn.textContent = 'âœ•';
        removeBtn.addEventListener('click', () => {
          list.items.splice(itemIndex, 1);
          refreshListsUI();
          autoSavePatternHierarchy();
        });

        row.appendChild(keyInput);
        row.appendChild(valueInput);
        row.appendChild(removeBtn);
        content.appendChild(row);
      });

      const actions = document.createElement('div');
      actions.className = 'list-actions';

      const addItemBtn = document.createElement('button');
      addItemBtn.className = 'btn btn-secondary btn-xs';
      addItemBtn.textContent = '+ Add Item';
      addItemBtn.addEventListener('click', () => {
        list.items.push({ key: '', value: '' });
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      actions.appendChild(addItemBtn);
      content.appendChild(actions);

      container.appendChild(header);
      container.appendChild(content);

      return container;
    }

    function createArrayElement(array, arrayIndex) {
      const container = document.createElement('div');
      container.className = 'list-container';
      container.dataset.arrayIndex = arrayIndex;
      container.dataset.type = 'array';

      const header = document.createElement('div');
      header.className = 'list-header';

      const title = document.createElement('h3');
      title.className = 'list-title';
      title.contentEditable = true;
      title.textContent = array.name || 'Array';
      title.addEventListener('blur', () => {
        array.name = title.textContent;
        autoSavePatternHierarchy();
      });

      const typeBadge = document.createElement('span');
      typeBadge.className = 'list-type';
      typeBadge.textContent = 'Array';

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn btn-danger btn-xs';
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', () => {
        listsData.arrays.splice(arrayIndex, 1);
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      header.appendChild(title);
      header.appendChild(typeBadge);
      header.appendChild(deleteBtn);

      const content = document.createElement('div');
      content.className = 'list-content';

      // Render array items
      array.items.forEach((item, itemIndex) => {
        const row = document.createElement('div');
        row.className = 'array-row';

        const valueInput = document.createElement('input');
        valueInput.placeholder = 'Value';
        valueInput.value = item || '';
        valueInput.addEventListener('input', () => {
          array.items[itemIndex] = valueInput.value;
          autoSavePatternHierarchy();
        });

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-danger btn-xs';
        removeBtn.textContent = 'âœ•';
        removeBtn.addEventListener('click', () => {
          array.items.splice(itemIndex, 1);
          refreshListsUI();
          autoSavePatternHierarchy();
        });

        row.appendChild(valueInput);
        row.appendChild(removeBtn);
        content.appendChild(row);
      });

      const actions = document.createElement('div');
      actions.className = 'list-actions';

      const addItemBtn = document.createElement('button');
      addItemBtn.className = 'btn btn-secondary btn-xs';
      addItemBtn.textContent = '+ Add Item';
      addItemBtn.addEventListener('click', () => {
        array.items.push('');
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      actions.appendChild(addItemBtn);
      content.appendChild(actions);

      container.appendChild(header);
      container.appendChild(content);

      return container;
    }

    // Color management functions
    function updateDefaultColorButtons() {
      updateDefaultColorButton(1, defaultPattern.color1, defaultPattern.style1);
      updateDefaultColorButton(2, defaultPattern.color2, defaultPattern.style2);
    }

    function updateDefaultColorButton(colorNum, color, style) {
      const button = colorNum === 1 ? document.getElementById('defaultColor1Btn') : document.getElementById('defaultColor2Btn');
      const colorDisplay = colorNum === 1 ? document.getElementById('defaultColor1Display') : document.getElementById('defaultColor2Display');
      const styleDisplay = colorNum === 1 ? document.getElementById('defaultStyle1Display') : document.getElementById('defaultStyle2Display');

      if (button) {
        if (color && color.trim() !== '') {
          colorDisplay.textContent = color;
          styleDisplay.textContent = getStyleAbbreviation(style || 'background');
          applyStyleToButton(button, color, style || 'background');
        } else {
          // No color set, use default styling
          button.style.backgroundColor = '';
          button.style.color = '';
          button.style.border = '';
          button.style.textDecoration = '';
          colorDisplay.textContent = '-';
          styleDisplay.textContent = '';
        }
      }
    }

    function showDefaultColorPanel(colorNum) {
      const panel = colorNum === 1 ? document.getElementById('defaultColor1Panel') : document.getElementById('defaultColor2Panel');
      const textInput = colorNum === 1 ? document.getElementById('defaultColor1Text') : document.getElementById('defaultColor2Text');
      const picker = colorNum === 1 ? document.getElementById('defaultColor1Picker') : document.getElementById('defaultColor2Picker');
      const styleSelect = colorNum === 1 ? document.getElementById('defaultStyle1Select') : document.getElementById('defaultStyle2Select');
      const display = colorNum === 1 ? document.getElementById('defaultColor1Display') : document.getElementById('defaultColor2Display');
      const button = colorNum === 1 ? document.getElementById('defaultColor1Btn') : document.getElementById('defaultColor2Btn');
      const color = colorNum === 1 ? defaultPattern.color1 : defaultPattern.color2;
      const style = colorNum === 1 ? defaultPattern.style1 : defaultPattern.style2;

      // Set current values
      textInput.value = color;
      display.textContent = color || '-';
      styleSelect.value = style || 'background';

      // Try to set color picker value if it's a hex color
      if (color && color.match(/^#[0-9A-Fa-f]{6}$/)) {
        picker.value = color;
      }

      // Position the panel relative to the button
      if (button) {
        const rect = button.getBoundingClientRect();
        panel.style.position = 'absolute';
        panel.style.top = (rect.bottom + window.scrollY) + 'px';
        panel.style.left = rect.left + 'px';
      }

      panel.classList.add('show');
      textInput.focus();
    }

    function hideDefaultColorPanel(colorNum) {
      const panel = colorNum === 1 ? document.getElementById('defaultColor1Panel') : document.getElementById('defaultColor2Panel');
      panel.classList.remove('show');
    }

    // Rule color panel functions
    function showRuleColorPanel(ruleIndex, colorNum) {
      // Create or get the color panel for this rule
      let panel = document.getElementById(`ruleColorPanel_${ruleIndex}_${colorNum}`);
      if (!panel) {
        panel = createRuleColorPanel(ruleIndex, colorNum);
        document.body.appendChild(panel);
      }

      const rule = dictionary.rules[ruleIndex];
      const color = colorNum === 1 ? rule.color1 : rule.color2;
      const style = colorNum === 1 ? rule.style1 : rule.style2;

      // Set current values
      const textInput = panel.querySelector('.color-text');
      const picker = panel.querySelector('.color-picker');
      const styleSelect = panel.querySelector('.style-select');

      textInput.value = color || '';
      styleSelect.value = style || 'background';

      // Try to set color picker value if it's a hex color
      if (color && color.match(/^#[0-9A-Fa-f]{6}$/)) {
        picker.value = color;
      }

      // Position the panel relative to the button
      const button = document.querySelector(`[data-idx="${ruleIndex}"] .color${colorNum}-btn`);
      if (button) {
        const rect = button.getBoundingClientRect();
        panel.style.position = 'absolute';
        panel.style.top = (rect.bottom + window.scrollY) + 'px';
        panel.style.left = rect.left + 'px';
      }

      panel.classList.add('show');
      textInput.focus();
    }

    function createRuleColorPanel(ruleIndex, colorNum) {
      const panel = document.createElement('div');
      panel.id = `ruleColorPanel_${ruleIndex}_${colorNum}`;
      panel.className = 'inline-form';
      panel.style.cssText = `
        position: absolute;
        min-width: 250px;
        background: white;
        border: 1px solid #dee2e6;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 1000;
      `;

      panel.innerHTML = `
        <div class="inline-form-row">
          <label>Color ${colorNum}:</label>
          <input type="text" class="color-text" placeholder="color (e.g. #ff0000)" style="flex: 1;" />
        </div>
        <div class="inline-form-row">
          <label>Picker:</label>
          <input type="color" class="color-picker" value="#ff00ff" style="width: 50px; height: 30px;" />
        </div>
        <div class="inline-form-row">
          <label>Style:</label>
          <select class="style-select" style="flex: 1;">
            <option value="background">Background</option>
            <option value="color">Text Color</option>
            <option value="underline">Underline</option>
            <option value="border">Border</option>
          </select>
        </div>
        <div class="inline-form-actions">
          <button class="btn btn-success btn-small apply-rule-color">Apply</button>
          <button class="btn btn-danger btn-small cancel-rule-color">Cancel</button>
        </div>
      `;

      // Add event listeners
      const applyBtn = panel.querySelector('.apply-rule-color');
      const cancelBtn = panel.querySelector('.cancel-rule-color');
      const textInput = panel.querySelector('.color-text');
      const picker = panel.querySelector('.color-picker');

      applyBtn.addEventListener('click', () => {
        const color = textInput.value;
        const style = panel.querySelector('.style-select').value;
        const rule = dictionary.rules[ruleIndex];
        if (colorNum === 1) {
          rule.color1 = color;
          rule.style1 = style;
        } else {
          rule.color2 = color;
          rule.style2 = style;
        }
        refreshRuleUI();
        applyRules();
        autoSavePatternHierarchy();
        hideRuleColorPanel(ruleIndex, colorNum);
      });

      cancelBtn.addEventListener('click', () => {
        hideRuleColorPanel(ruleIndex, colorNum);
      });

      // Sync picker with text input
      picker.addEventListener('input', () => {
        textInput.value = picker.value;
      });

      textInput.addEventListener('input', () => {
        if (textInput.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          picker.value = textInput.value;
        }
      });

      return panel;
    }

    function hideRuleColorPanel(ruleIndex, colorNum) {
      const panel = document.getElementById(`ruleColorPanel_${ruleIndex}_${colorNum}`);
      if (panel) {
        panel.classList.remove('show');
      }
    }

    // Event Listeners
    document.addEventListener('DOMContentLoaded', function () {
      // Initialize tabs
      initTabs();

      // Basic event listeners
      document.getElementById('clearBtn').addEventListener('click', () => {
        document.getElementById('sourceText').value = '';
        applyRules();
      });

      // Auto-update preview when input text changes
      document.getElementById('sourceText').addEventListener('input', () => {
        applyRules();
      });
      document.getElementById('addRule').addEventListener('click', () => {
        showCategoryDropdown();
      });

      // Function to show category dropdown
      function showCategoryDropdown() {
        const dropdown = document.getElementById('categoryDropdown');
        const button = document.getElementById('addRule');

        // Clear existing options
        dropdown.innerHTML = '';

        // Add categories from listsData
        if (listsData && listsData.keyValueLists) {
          const categoriesList = listsData.keyValueLists.find(list => list.name === 'categories');
          if (categoriesList && categoriesList.items) {
            categoriesList.items.forEach(item => {
              const option = document.createElement('div');
              option.className = 'dropdown-option';
              option.style.cssText = 'padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0;';
              option.textContent = `${item.value} ${item.key}`;
              option.addEventListener('click', () => {
                createNewGroup(item.key);
                hideCategoryDropdown();
              });
              dropdown.appendChild(option);
            });
          }
        }

        // Show dropdown
        dropdown.style.display = 'block';
      }

      // Function to hide category dropdown
      function hideCategoryDropdown() {
        const dropdown = document.getElementById('categoryDropdown');
        dropdown.style.display = 'none';
      }

      // Function to generate random color
      function generateRandomColor() {
        const colors = [
          '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
          '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
          '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2',
          '#FAD7A0', '#A9CCE3', '#F9E79F', '#D5A6BD', '#A3E4D7'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      // Function to create new group
      function createNewGroup(category) {
        // Get the current default pattern
        const defaultPatternData = buildPatternFromJSON();

        // Create a new rule based on the default pattern with the selected category
        const newRule = {
          match: defaultPatternData.pattern,
          color1: generateRandomColor(),
          color2: '',
          style1: 'background',
          style2: '',
          label: category
        };

        dictionary.rules.push(newRule);
        refreshRuleUI();
        autoSavePatternHierarchy();
      }

      // Hide dropdown when clicking outside
      document.addEventListener('click', (e) => {
        const dropdown = document.getElementById('categoryDropdown');
        const button = document.getElementById('addRule');
        if (!button.contains(e.target) && !dropdown.contains(e.target)) {
          hideCategoryDropdown();
        }
      });
      document.getElementById('downloadMd').addEventListener('click', downloadMarkdown);
      document.getElementById('downloadPdf').addEventListener('click', downloadPDF);
      document.getElementById('copyHtml').addEventListener('click', copyStyledHTML);
      document.getElementById('copyPlain').addEventListener('click', copyPlainText);

      // bob.json operations
      document.getElementById('loadBobJson').addEventListener('click', loadPatternHierarchy);
      document.getElementById('saveBobJson').addEventListener('click', exportPatternHierarchy);

      // Default pattern event listeners
      document.getElementById('defaultPatternEnabled').addEventListener('change', applyRules);

      // Color button and panel functionality
      const defaultColor1Btn = document.getElementById('defaultColor1Btn');
      const defaultColor2Btn = document.getElementById('defaultColor2Btn');
      const defaultColor1Panel = document.getElementById('defaultColor1Panel');
      const defaultColor2Panel = document.getElementById('defaultColor2Panel');
      const defaultColor1Text = document.getElementById('defaultColor1Text');
      const defaultColor2Text = document.getElementById('defaultColor2Text');
      const defaultColor1Picker = document.getElementById('defaultColor1Picker');
      const defaultColor2Picker = document.getElementById('defaultColor2Picker');
      const applyDefaultColor1Btn = document.getElementById('applyDefaultColor1');
      const applyDefaultColor2Btn = document.getElementById('applyDefaultColor2');
      const cancelDefaultColor1Btn = document.getElementById('cancelDefaultColor1');
      const cancelDefaultColor2Btn = document.getElementById('cancelDefaultColor2');

      // Show/hide color panels
      defaultColor1Btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isVisible = defaultColor1Panel.classList.contains('show');
        if (isVisible) {
          hideDefaultColorPanel(1);
        } else {
          showDefaultColorPanel(1);
        }
      });

      defaultColor2Btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isVisible = defaultColor2Panel.classList.contains('show');
        if (isVisible) {
          hideDefaultColorPanel(2);
        } else {
          showDefaultColorPanel(2);
        }
      });

      // Hide panels when clicking outside
      document.addEventListener('click', (e) => {
        if (!defaultColor1Btn.contains(e.target) && !defaultColor1Panel.contains(e.target)) {
          hideDefaultColorPanel(1);
        }
        if (!defaultColor2Btn.contains(e.target) && !defaultColor2Panel.contains(e.target)) {
          hideDefaultColorPanel(2);
        }

        // Hide rule color panels when clicking outside
        const ruleColorPanels = document.querySelectorAll('[id^="ruleColorPanel_"]');
        ruleColorPanels.forEach(panel => {
          if (!panel.contains(e.target)) {
            panel.classList.remove('show');
          }
        });
      });

      // Apply color changes
      applyDefaultColor1Btn.addEventListener('click', () => {
        const color = defaultColor1Text.value;
        const style = document.getElementById('defaultStyle1Select').value;
        defaultPattern.color1 = color;
        defaultPattern.style1 = style;
        updateDefaultColorButtons();
        updatePatternUI();
        applyRules();
        autoSavePatternHierarchy();
        hideDefaultColorPanel(1);
      });

      applyDefaultColor2Btn.addEventListener('click', () => {
        const color = defaultColor2Text.value;
        const style = document.getElementById('defaultStyle2Select').value;
        defaultPattern.color2 = color;
        defaultPattern.style2 = style;
        updateDefaultColorButtons();
        updatePatternUI();
        applyRules();
        autoSavePatternHierarchy();
        hideDefaultColorPanel(2);
      });

      // Cancel color changes
      cancelDefaultColor1Btn.addEventListener('click', () => {
        hideDefaultColorPanel(1);
        defaultColor1Text.value = defaultPattern.color1;
        document.getElementById('defaultColor1Display').textContent = defaultPattern.color1;
      });

      cancelDefaultColor2Btn.addEventListener('click', () => {
        hideDefaultColorPanel(2);
        defaultColor2Text.value = defaultPattern.color2;
        document.getElementById('defaultColor2Display').textContent = defaultPattern.color2 || '-';
      });

      // Sync color pickers with text inputs
      defaultColor1Picker.addEventListener('input', () => {
        defaultColor1Text.value = defaultColor1Picker.value;
      });

      defaultColor2Picker.addEventListener('input', () => {
        defaultColor2Text.value = defaultColor2Picker.value;
      });

      // Sync text inputs with color pickers
      defaultColor1Text.addEventListener('input', () => {
        if (defaultColor1Text.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          defaultColor1Picker.value = defaultColor1Text.value;
        }
      });

      defaultColor2Text.addEventListener('input', () => {
        if (defaultColor2Text.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          defaultColor2Picker.value = defaultColor2Text.value;
        }
      });

      // Pattern building event listeners
      const basePatternInput = document.getElementById('basePatternInput');
      if (basePatternInput) {
        basePatternInput.addEventListener('input', () => {
          defaultPattern.structure.basePattern = basePatternInput.value;
          updatePatternUI();
          applyRules();
          autoSavePatternHierarchy();
        });
      }



      // Wrapper toggle event listeners
      const wrapperToggles = document.querySelectorAll('.wrapper-toggle');
      wrapperToggles.forEach(btn => {
        btn.addEventListener('click', () => {
          const wrapper = btn.dataset.wrapper;
          const isActive = btn.dataset.active === 'true';

          switch (wrapper) {
            case 'word-boundary':
              updatePatternWithWordBoundaries(!isActive);
              break;
            case 'start-anchor':
              updatePatternWithAnchors('start', !isActive);
              break;
            case 'end-anchor':
              updatePatternWithAnchors('end', !isActive);
              break;
          }
          applyRules();
        });
      });

      // Add regex toggle buttons event listeners
      document.getElementById('addPrependRegexToggle').addEventListener('click', () => {
        const form = document.getElementById('inlineRegexForm');
        const toggleModeBtn = document.getElementById('togglePrependMode');
        const newRegexValue = document.getElementById('newRegexValue');
        const newRegexLabel = document.getElementById('newRegexLabel');

        // Set to prepend mode
        toggleModeBtn.textContent = '^';
        toggleModeBtn.title = 'Toggle between append (+) and prepend (^) mode';

        // Clear form
        newRegexValue.value = '';
        newRegexLabel.value = '';

        // Show form
        form.classList.add('show');
        newRegexValue.focus();
      });

      document.getElementById('addRegexToggle').addEventListener('click', () => {
        const form = document.getElementById('inlineRegexForm');
        const toggleModeBtn = document.getElementById('togglePrependMode');
        const newRegexValue = document.getElementById('newRegexValue');
        const newRegexLabel = document.getElementById('newRegexLabel');

        // Set to append mode
        toggleModeBtn.textContent = '+';
        toggleModeBtn.title = 'Toggle between append (+) and prepend (^) mode';

        // Clear form
        newRegexValue.value = '';
        newRegexLabel.value = '';

        // Show form
        form.classList.add('show');
        newRegexValue.focus();
      });

      // Inline regex form event listeners
      document.getElementById('togglePrependMode').addEventListener('click', () => {
        const btn = document.getElementById('togglePrependMode');
        const isPrepend = btn.textContent === '^';
        btn.textContent = isPrepend ? '+' : '^';
        btn.title = isPrepend ? 'Toggle between append (+) and prepend (^) mode' : 'Toggle between append (+) and prepend (^) mode';
      });

      document.getElementById('saveRegexToggle').addEventListener('click', () => {
        const newRegexValue = document.getElementById('newRegexValue').value;
        const newRegexLabel = document.getElementById('newRegexLabel').value;
        const toggleModeBtn = document.getElementById('togglePrependMode');
        const isPrepend = toggleModeBtn.textContent === '^';

        if (newRegexValue.trim()) {
          updatePatternWithRegexToggle(newRegexValue, isPrepend, true, newRegexLabel || 'Custom Toggle');

          // Hide form
          document.getElementById('inlineRegexForm').classList.remove('show');

          // Clear form
          document.getElementById('newRegexValue').value = '';
          document.getElementById('newRegexLabel').value = '';
        }
      });

      document.getElementById('cancelRegexToggle').addEventListener('click', () => {
        document.getElementById('inlineRegexForm').classList.remove('show');
        document.getElementById('newRegexValue').value = '';
        document.getElementById('newRegexLabel').value = '';
      });

      // Lists and arrays event listeners
      document.getElementById('addKeyValueList').addEventListener('click', () => {
        listsData.keyValueLists.push({
          name: 'New Key-Value List',
          items: [{ key: '', value: '' }]
        });
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      document.getElementById('addArray').addEventListener('click', () => {
        listsData.arrays.push({
          name: 'New Array',
          items: ['']
        });
        refreshListsUI();
        autoSavePatternHierarchy();
      });

      // Preview buttons event listeners
      document.getElementById('loadSampleMd').addEventListener('click', loadSampleMd);

      // Refresh button event listener
      document.getElementById('refreshBtn').addEventListener('click', refreshFromBobJson);

      // Initialize UI
      updatePatternUI();
      refreshRuleUI();
      refreshListsUI();
      updateRawJson();

      // Load pattern hierarchy from bob.json on page load
      loadPatternHierarchy();
    });
  </script>
</body>

</html>