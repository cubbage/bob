<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Semantic Structure Test</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif;
      padding: 2rem;
      max-width: 800px;
      margin: auto;
    }

    .test-section {
      margin: 2rem 0;
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .semantic-structure {
      display: inline-block;
      margin: 2px 4px;
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #f8f9fa;
    }
  </style>
</head>

<body>
  <h1>Semantic Structure Parsing Test</h1>

  <div class="test-section">
    <h2>Test Input</h2>
    <textarea id="testInput" rows="10" cols="80">Here is some test text with semantic structures:

⦕Detective fiction, on the other hand, is Horror's polar opposite. Horror is the most primal form, while Detective is the most intellectual. But Detective and Horror are both fundamentally about the mind.⟢Detective fiction contrasts horror as intellectual vs primal mind genres⟣⦖

⦕KEY POINT: Detective fiction highlights the brilliance of the mind while Horror emphasizes its flaws.⟢Detective celebrates mind's power; Horror exposes its flaws⟣⦖

⦕Novels and Films Dawn of the Dead, Deliverance, Shaun of the Dead, Godzilla, Sisters, The Thing, What Ever Happened to Baby Jane?⨭Widely known horror novels and films from gothic to modern classics⨮⦖

⦕This is a mapping example⊏showing how mapping works⊐⦖

⦕This is a combination example⦓showing how combination works⦔⦖</textarea>
  </div>

  <div class="test-section">
    <h2>Parsed Results</h2>
    <div id="results"></div>
  </div>

  <script>
    // Simplified version of the semantic structure parsing
    function parseSemanticStructures(text) {
      const structures = [];

      // Define the semantic structure patterns with their delimiters
      const patterns = [
        {
          relationship: 'supplementary',
          startDelimiter: '⦕',
          endDelimiter: '⦖',
          innerStartDelimiter: '⟢',
          innerEndDelimiter: '⟣'
        },
        {
          relationship: 'linear progression',
          startDelimiter: '⦕',
          endDelimiter: '⦖',
          innerStartDelimiter: '⨴',
          innerEndDelimiter: '⨵'
        },
        {
          relationship: 'parallel set',
          startDelimiter: '⦕',
          endDelimiter: '⦖',
          innerStartDelimiter: '⨭',
          innerEndDelimiter: '⨮'
        },
        {
          relationship: 'mapping',
          startDelimiter: '⦕',
          endDelimiter: '⦖',
          innerStartDelimiter: '⊏',
          innerEndDelimiter: '⊐'
        },
        {
          relationship: 'combination',
          startDelimiter: '⦕',
          endDelimiter: '⦖',
          innerStartDelimiter: '⦓',
          innerEndDelimiter: '⦔'
        }
      ];

      for (const pattern of patterns) {
        const { startDelimiter, endDelimiter, innerStartDelimiter, innerEndDelimiter, relationship } = pattern;

        // Create regex pattern to match the semantic structure
        const regexPattern = `${startDelimiter}(.*?)${innerStartDelimiter}(.*?)${innerEndDelimiter}.*?${endDelimiter}`;

        try {
          const regex = new RegExp(regexPattern, 'g');
          let match;

          while ((match = regex.exec(text)) !== null) {
            const fullMatch = match[0];
            const fragment = match[1];
            const summary = match[2];

            structures.push({
              fullMatch,
              fragment,
              summary,
              relationship,
              startIndex: match.index,
              endIndex: match.index + fullMatch.length
            });
          }
        } catch (e) {
          console.warn('Invalid semantic structure regex:', regexPattern, e);
        }
      }

      return structures;
    }

    function parseSemanticStructureComponents(structure) {
      const { fragment, summary, relationship } = structure;

      // Extract label if present (before the first colon)
      let label = '';
      let sourceText = fragment;

      const colonIndex = fragment.indexOf(':');
      if (colonIndex !== -1) {
        label = fragment.substring(0, colonIndex).trim();
        sourceText = fragment.substring(colonIndex + 1).trim();
      }

      return {
        label,
        summary,
        sourceText,
        relationship
      };
    }

    function displayResults() {
      const text = document.getElementById('testInput').value;
      const structures = parseSemanticStructures(text);
      const resultsDiv = document.getElementById('results');

      resultsDiv.innerHTML = '';

      if (structures.length === 0) {
        resultsDiv.innerHTML = '<p>No semantic structures found.</p>';
        return;
      }

      structures.forEach((structure, index) => {
        const components = parseSemanticStructureComponents(structure);

        const container = document.createElement('div');
        container.className = 'semantic-structure';
        container.style.marginBottom = '1rem';

        let content = '';
        if (components.label) {
          content += `<strong>${components.label}</strong>: `;
        }
        if (components.summary) {
          content += `<em>${components.summary}</em> | `;
        }
        content += components.sourceText;

        container.innerHTML = content;
        resultsDiv.appendChild(container);

        // Also show the raw data
        const rawDiv = document.createElement('div');
        rawDiv.style.fontSize = '0.8em';
        rawDiv.style.color = '#666';
        rawDiv.style.marginTop = '0.5rem';
        rawDiv.innerHTML = `<strong>Relationship:</strong> ${components.relationship}<br>
                                  <strong>Label:</strong> "${components.label}"<br>
                                  <strong>Summary:</strong> "${components.summary}"<br>
                                  <strong>Source:</strong> "${components.sourceText}"`;
        resultsDiv.appendChild(rawDiv);

        const hr = document.createElement('hr');
        resultsDiv.appendChild(hr);
      });
    }

    // Set up event listener
    document.getElementById('testInput').addEventListener('input', displayResults);

    // Initial display
    displayResults();
  </script>
</body>

</html>