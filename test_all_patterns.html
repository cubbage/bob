<!DOCTYPE html>
<html>

<head>
  <title>All Patterns Test</title>
</head>

<body>
  <h1>All Semantic Structure Patterns Test</h1>
  <div id="results"></div>

  <script>
    const testText = `
⦕Detective fiction, on the other hand, is Horror's polar opposite. Horror is the most primal form, while Detective is the most intellectual. But Detective and Horror are both fundamentally about the mind.⟢Detective fiction contrasts horror as intellectual vs primal mind genres⟣⦖

⦕KEY POINT: Detective fiction highlights the brilliance of the mind while Horror emphasizes its flaws.⟢Detective celebrates mind's power; Horror exposes its flaws⟣⦖

⦕Novels and Films Dawn of the Dead, Deliverance, Shaun of the Dead, Godzilla, Sisters, The Thing, What Ever Happened to Baby Jane?⨭Widely known horror novels and films from gothic to modern classics⨮⦖

⦕This is a mapping example⊏showing how mapping works⊐⦖

⦕This is a combination example⦓showing how combination works⦔⦖

⦕Linear progression example⨴showing how linear progression works⨵⦖
        `;

    const patterns = [
      {
        relationship: 'supplementary',
        startDelimiter: '⦕',
        endDelimiter: '⦖',
        innerStartDelimiter: '⟢',
        innerEndDelimiter: '⟣'
      },
      {
        relationship: 'linear progression',
        startDelimiter: '⦕',
        endDelimiter: '⦖',
        innerStartDelimiter: '⨴',
        innerEndDelimiter: '⨵'
      },
      {
        relationship: 'parallel set',
        startDelimiter: '⦕',
        endDelimiter: '⦖',
        innerStartDelimiter: '⨭',
        innerEndDelimiter: '⨮'
      },
      {
        relationship: 'mapping',
        startDelimiter: '⦕',
        endDelimiter: '⦖',
        innerStartDelimiter: '⊏',
        innerEndDelimiter: '⊐'
      },
      {
        relationship: 'combination',
        startDelimiter: '⦕',
        endDelimiter: '⦖',
        innerStartDelimiter: '⦓',
        innerEndDelimiter: '⦔'
      }
    ];

    const results = document.getElementById('results');
    let totalFound = 0;

    patterns.forEach(pattern => {
      const { startDelimiter, endDelimiter, innerStartDelimiter, innerEndDelimiter, relationship } = pattern;

      // Escape special regex characters in delimiters
      const escapedStartDelimiter = startDelimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const escapedEndDelimiter = endDelimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const escapedInnerStartDelimiter = innerStartDelimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const escapedInnerEndDelimiter = innerEndDelimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

      const regexPattern = `${escapedStartDelimiter}(.*?)${escapedInnerStartDelimiter}(.*?)${escapedInnerEndDelimiter}.*?${escapedEndDelimiter}`;

      console.log(`Testing pattern for ${relationship}:`, regexPattern);

      try {
        const regex = new RegExp(regexPattern, 'g');
        const matches = [];
        let match;

        while ((match = regex.exec(testText)) !== null) {
          matches.push({
            fullMatch: match[0],
            fragment: match[1],
            summary: match[2]
          });
        }

        if (matches.length > 0) {
          totalFound += matches.length;
          results.innerHTML += `<h3>${relationship}: ${matches.length} found</h3>`;
          matches.forEach((match, index) => {
            results.innerHTML += `<p><strong>Match ${index + 1}:</strong></p>`;
            results.innerHTML += `<p><strong>Fragment:</strong> ${match.fragment}</p>`;
            results.innerHTML += `<p><strong>Summary:</strong> ${match.summary}</p>`;
            results.innerHTML += `<hr>`;
          });
        } else {
          results.innerHTML += `<p><strong>${relationship}:</strong> No matches found</p>`;
        }
      } catch (e) {
        console.error(`Invalid regex for ${relationship}:`, e);
        results.innerHTML += `<p><strong>${relationship}:</strong> Invalid regex - ${e.message}</p>`;
      }
    });

    results.innerHTML += `<h2>Total matches found: ${totalFound}</h2>`;
  </script>
</body>

</html>